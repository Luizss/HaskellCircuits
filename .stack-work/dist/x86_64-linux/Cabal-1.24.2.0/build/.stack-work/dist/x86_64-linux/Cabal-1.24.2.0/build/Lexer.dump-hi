
==================== FINAL INTERFACE ====================
2018-06-09 19:11:38.176263 UTC

interface HaskellCircuits-0.1.0.0-3mIW93ol3alH6nhlDJ7Hzo:Lexer 8002
  interface hash: e89ec57ee417650540dae8e3bb95baf5
  ABI hash: c6174f684585218aa184faedf4ab7f58
  export-list hash: c0fea5fa50c83f412bfcd8243e0a6172
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 67295d745c579b78317265f16cda9fdd
  sig of: Nothing
  used TH splices: False
  where
exports:
  Lexer.alexGetByte
  Lexer.alexIndexInt16OffAddr
  Lexer.alexIndexInt32OffAddr
  Lexer.alexInputPrevChar
  Lexer.alexScan
  Lexer.alexScanUser
  Lexer.alex_accept
  Lexer.alex_action_0
  Lexer.alex_action_10
  Lexer.alex_action_11
  Lexer.alex_action_12
  Lexer.alex_action_13
  Lexer.alex_action_14
  Lexer.alex_action_15
  Lexer.alex_action_16
  Lexer.alex_action_17
  Lexer.alex_action_18
  Lexer.alex_action_19
  Lexer.alex_action_20
  Lexer.alex_action_5
  Lexer.alex_action_6
  Lexer.alex_action_7
  Lexer.alex_action_8
  Lexer.alex_action_9
  Lexer.alex_actions
  Lexer.alex_base
  Lexer.alex_check
  Lexer.alex_deflt
  Lexer.alex_scan_tkn
  Lexer.alex_tab_size
  Lexer.alex_table
  Lexer.catchEither
  Lexer.changeState
  Lexer.changeStateAndOutput
  Lexer.checkBin
  Lexer.checkHex
  Lexer.consLoc
  Lexer.errorT
  Lexer.funLoc
  Lexer.lexComment
  Lexer.nextSrcLoc
  Lexer.quickIndex
  Lexer.readToken
  Lexer.runT
  Lexer.runTWithoutError
  Lexer.tokenize
  Lexer.unifyMultilineString
  Lexer.Action
  Lexer.AlexAcc{Lexer.AlexAcc Lexer.AlexAccNone Lexer.AlexAccSkip}
  Lexer.AlexAddr{Lexer.AlexA#}
  Lexer.AlexInput{Lexer.AI}
  Lexer.AlexLastAcc{Lexer.AlexLastAcc Lexer.AlexLastSkip Lexer.AlexNone}
  Lexer.AlexResult{Lexer.AR}
  Lexer.AlexReturn{Lexer.AlexEOF Lexer.AlexError Lexer.AlexSkip Lexer.AlexToken}
  Lexer.AlexState
  Lexer.Buffer{Lexer.Buf getBytes getPrevious getString}
  Lexer.Byte
  Lexer.Bytes
  Lexer.Col
  Lexer.FileName
  Lexer.L{Lexer.L getLoc getVal}
  Lexer.LToken
  Lexer.Line
  Lexer.SrcLoc{Lexer.NoLoc Lexer.SrcLoc}
  Lexer.T
  Lexer.Token{Lexer.Arrow Lexer.Bin Lexer.Colon Lexer.Data Lexer.Dec Lexer.EOF Lexer.Equal Lexer.Hex Lexer.LParen Lexer.Low Lexer.Pipe Lexer.RParen Lexer.Semic Lexer.Sym Lexer.TwoColons Lexer.Upp}
module dependencies:
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      ghc-prim-0.5.0.0 integer-gmp-1.0.0.1
                      mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      transformers-0.5.2.0@transformers-0.5.2.0
                      utf8-string-1.0.1.1@utf8-string-1.0.1.1-1DpjxLeTvGg7ttZZojxJR5
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Functor.Identity base-4.9.1.0:Data.List.NonEmpty
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Semigroup
                         base-4.9.1.0:Data.Type.Equality base-4.9.1.0:Data.Version
                         base-4.9.1.0:Data.Void base-4.9.1.0:GHC.Exts
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  array-0.5.1.1@array-0.5.1.1:Data.Array 01310623526f8acc73d1bb69e9d9530a
import  -/  array-0.5.1.1@array-0.5.1.1:Data.Array.Base a1a813de21dd195f39f7a053a2142a3f
import  -/  base-4.9.1.0:Data.Bits d707ac81dd0124c7a7fb3234df2c8548
import  -/  base-4.9.1.0:Data.Char 01433d23661edb6e5ef1536ef1e6774c
import  -/  base-4.9.1.0:Data.Either 20b09ef8d0a5b74fdec011c40c1587f5
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.Word 77f42e01d0fb6b071f1ea2176d87fa6c
import  -/  base-4.9.1.0:GHC.Arr dbae05e7a9c0aba55cc706ecf0406507
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:GHC.Exts 26da1d42716da321d2d8df514b70012a
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:GHC.Unicode a175ecf20bf1272d9ae31337e7da43ab
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:Text.Read 75c59863e882ebaec4532e9465e2ee9b
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State 749dca8ca0e6625b32091d445bd92b01
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State.Class 6d31234b0a911b56412061943d18b89e
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 371607e50dde46b5f4103b3ab334a497
import  -/  utf8-string-1.0.1.1@utf8-string-1.0.1.1-1DpjxLeTvGg7ttZZojxJR5:Codec.Binary.UTF8.String 0bca5fb83721feacbbf5aaee8e372b71
addDependentFile "/home/luiz/.stack/programs/x86_64-linux/ghc-8.0.2/lib/ghc-8.0.2/include/ghcversion.h"
addDependentFile "/usr/include/stdc-predef.h"
addDependentFile "src/Lexer.x"
addDependentFile "/home/luiz/.stack/programs/x86_64-linux/ghc-8.0.2/lib/ghc-8.0.2/include/ghcconfig.h"
addDependentFile "/home/luiz/.stack/programs/x86_64-linux/ghc-8.0.2/lib/ghc-8.0.2/include/ghcplatform.h"
addDependentFile "/home/luiz/.stack/programs/x86_64-linux/ghc-8.0.2/lib/ghc-8.0.2/include/ghcautoconf.h"
addDependentFile ".stack-work/dist/x86_64-linux/Cabal-1.24.2.0/build/autogen/cabal_macros.h"
a30eee500ffeed73c76202d9a53d2902
  $fEqSrcLoc :: GHC.Classes.Eq Lexer.SrcLoc
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lexer.SrcLoc Lexer.$fEqSrcLoc_$c== Lexer.$fEqSrcLoc_$c/= -}
a30eee500ffeed73c76202d9a53d2902
  $fEqSrcLoc_$c/= :: Lexer.SrcLoc -> Lexer.SrcLoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lexer.SrcLoc) (b :: Lexer.SrcLoc) ->
                 case a of wild {
                   Lexer.SrcLoc a1 dt dt1
                   -> case b of wild1 {
                        Lexer.SrcLoc b1 dt2 dt3
                        -> case GHC.Base.eqString a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.True
                             GHC.Types.True
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# dt dt2) of wild3 {
                                  GHC.Types.False -> GHC.Types.True
                                  GHC.Types.True
                                  -> case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# dt1 dt3) of wild4 {
                                       GHC.Types.False -> GHC.Types.True
                                       GHC.Types.True -> GHC.Types.False } } }
                        Lexer.NoLoc -> GHC.Types.True }
                   Lexer.NoLoc
                   -> case b of wild1 {
                        Lexer.SrcLoc ipv ipv1 ipv2 -> GHC.Types.True
                        Lexer.NoLoc -> GHC.Types.False } }) -}
a30eee500ffeed73c76202d9a53d2902
  $fEqSrcLoc_$c== :: Lexer.SrcLoc -> Lexer.SrcLoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Lexer.SrcLoc) (ds1 :: Lexer.SrcLoc) ->
                 case ds of wild {
                   Lexer.SrcLoc a1 dt dt1
                   -> case ds1 of wild1 {
                        Lexer.SrcLoc b1 dt2 dt3
                        -> case GHC.Base.eqString a1 b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.==# dt dt2) of wild3 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True
                                  -> GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.==# dt1 dt3) } }
                        Lexer.NoLoc -> GHC.Types.False }
                   Lexer.NoLoc
                   -> case ds1 of wild1 {
                        Lexer.SrcLoc ipv ipv1 ipv2 -> GHC.Types.False
                        Lexer.NoLoc -> GHC.Types.True } }) -}
062aa1a04d631f02a39ae09e221d0fdc
  $fEqToken :: GHC.Classes.Eq Lexer.Token
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lexer.Token Lexer.$fEqToken_$c== Lexer.$fEqToken_$c/= -}
062aa1a04d631f02a39ae09e221d0fdc
  $fEqToken_$c/= :: Lexer.Token -> Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (a :: Lexer.Token) (b :: Lexer.Token) ->
                 case Lexer.$fEqToken_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
062aa1a04d631f02a39ae09e221d0fdc
  $fEqToken_$c== :: Lexer.Token -> Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (ds :: Lexer.Token) (ds1 :: Lexer.Token) ->
                 case ds of wild {
                   Lexer.LParen
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lexer.LParen -> GHC.Types.True }
                   Lexer.RParen
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lexer.RParen -> GHC.Types.True }
                   Lexer.Equal
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lexer.Equal -> GHC.Types.True }
                   Lexer.Colon
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lexer.Colon -> GHC.Types.True }
                   Lexer.TwoColons
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lexer.TwoColons -> GHC.Types.True }
                   Lexer.Arrow
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lexer.Arrow -> GHC.Types.True }
                   Lexer.Low a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Lexer.Low b1 -> GHC.Base.eqString a1 b1 }
                   Lexer.Upp a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Lexer.Upp b1 -> GHC.Base.eqString a1 b1 }
                   Lexer.Sym a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Lexer.Sym b1 -> GHC.Base.eqString a1 b1 }
                   Lexer.Semic
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lexer.Semic -> GHC.Types.True }
                   Lexer.Pipe
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lexer.Pipe -> GHC.Types.True }
                   Lexer.Bin a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Lexer.Bin b1 -> GHC.Base.eqString a1 b1 }
                   Lexer.Hex a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Lexer.Hex b1 -> GHC.Base.eqString a1 b1 }
                   Lexer.Dec a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Lexer.Dec b1 -> GHC.Classes.eqInt a1 b1 }
                   Lexer.Data
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lexer.Data -> GHC.Types.True }
                   Lexer.EOF
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Lexer.EOF -> GHC.Types.True } }) -}
b349f6a51d347de013d5c5d3a0eb3033
  $fFunctorL :: GHC.Base.Functor Lexer.L
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lexer.L Lexer.$fFunctorL_$cfmap Lexer.$fFunctorL_$c<$ -}
b349f6a51d347de013d5c5d3a0eb3033
  $fFunctorL_$c<$ :: a -> Lexer.L b -> Lexer.L a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U(U,A)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (eta :: a) (ds :: Lexer.L b) ->
                 case ds of wild { Lexer.L s x -> Lexer.L @ a s eta }) -}
b349f6a51d347de013d5c5d3a0eb3033
  $fFunctorL_$cfmap :: (a -> b) -> Lexer.L a -> Lexer.L b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*C1(U)><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (f :: a -> b) (ds :: Lexer.L a) ->
                 case ds of wild { Lexer.L s x -> Lexer.L @ b s (f x) }) -}
a30eee500ffeed73c76202d9a53d2902
  $fOrdSrcLoc :: GHC.Classes.Ord Lexer.SrcLoc
  DFunId
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lexer.SrcLoc
                  Lexer.$fEqSrcLoc
                  Lexer.$fOrdSrcLoc_$ccompare
                  Lexer.$fOrdSrcLoc_$c<
                  Lexer.$fOrdSrcLoc_$c<=
                  Lexer.$fOrdSrcLoc_$c>
                  Lexer.$fOrdSrcLoc_$c>=
                  Lexer.$fOrdSrcLoc_$cmax
                  Lexer.$fOrdSrcLoc_$cmin -}
a30eee500ffeed73c76202d9a53d2902
  $fOrdSrcLoc_$c< :: Lexer.SrcLoc -> Lexer.SrcLoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lexer.SrcLoc) (b :: Lexer.SrcLoc) ->
                 case a of wild {
                   Lexer.SrcLoc a1 dt dt1
                   -> case b of wild1 {
                        Lexer.SrcLoc b1 dt2 dt3
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 of wild2 {
                             GHC.Types.LT -> GHC.Types.True
                             GHC.Types.EQ
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# dt dt2) of wild3 {
                                  GHC.Types.False
                                  -> case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# dt dt2) of wild4 {
                                       GHC.Types.False -> GHC.Types.False
                                       GHC.Types.True
                                       -> GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.<# dt1 dt3) }
                                  GHC.Types.True -> GHC.Types.True }
                             GHC.Types.GT -> GHC.Types.False }
                        Lexer.NoLoc -> GHC.Types.True }
                   Lexer.NoLoc -> case b of wild1 { DEFAULT -> GHC.Types.False } }) -}
a30eee500ffeed73c76202d9a53d2902
  $fOrdSrcLoc_$c<= :: Lexer.SrcLoc -> Lexer.SrcLoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lexer.SrcLoc) (b :: Lexer.SrcLoc) ->
                 case a of wild {
                   Lexer.SrcLoc a1 dt dt1
                   -> case b of wild1 {
                        Lexer.SrcLoc b1 dt2 dt3
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 of wild2 {
                             GHC.Types.LT -> GHC.Types.True
                             GHC.Types.EQ
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# dt dt2) of wild3 {
                                  GHC.Types.False
                                  -> case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# dt dt2) of wild4 {
                                       GHC.Types.False -> GHC.Types.False
                                       GHC.Types.True
                                       -> GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.<=# dt1 dt3) }
                                  GHC.Types.True -> GHC.Types.True }
                             GHC.Types.GT -> GHC.Types.False }
                        Lexer.NoLoc -> GHC.Types.True }
                   Lexer.NoLoc
                   -> case b of wild1 {
                        Lexer.SrcLoc ipv ipv1 ipv2 -> GHC.Types.False
                        Lexer.NoLoc -> GHC.Types.True } }) -}
a30eee500ffeed73c76202d9a53d2902
  $fOrdSrcLoc_$c> :: Lexer.SrcLoc -> Lexer.SrcLoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lexer.SrcLoc) (b :: Lexer.SrcLoc) ->
                 case a of wild {
                   Lexer.SrcLoc a1 dt dt1
                   -> case b of wild1 {
                        Lexer.SrcLoc b1 dt2 dt3
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 of wild2 {
                             GHC.Types.LT -> GHC.Types.False
                             GHC.Types.EQ
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# dt dt2) of wild3 {
                                  GHC.Types.False
                                  -> case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# dt dt2) of wild4 {
                                       GHC.Types.False -> GHC.Types.True
                                       GHC.Types.True
                                       -> GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.># dt1 dt3) }
                                  GHC.Types.True -> GHC.Types.False }
                             GHC.Types.GT -> GHC.Types.True }
                        Lexer.NoLoc -> GHC.Types.False }
                   Lexer.NoLoc
                   -> case b of wild1 {
                        Lexer.SrcLoc ipv ipv1 ipv2 -> GHC.Types.True
                        Lexer.NoLoc -> GHC.Types.False } }) -}
a30eee500ffeed73c76202d9a53d2902
  $fOrdSrcLoc_$c>= :: Lexer.SrcLoc -> Lexer.SrcLoc -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lexer.SrcLoc) (b :: Lexer.SrcLoc) ->
                 case a of wild {
                   Lexer.SrcLoc a1 dt dt1
                   -> case b of wild1 {
                        Lexer.SrcLoc b1 dt2 dt3
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 of wild2 {
                             GHC.Types.LT -> GHC.Types.False
                             GHC.Types.EQ
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# dt dt2) of wild3 {
                                  GHC.Types.False
                                  -> case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# dt dt2) of wild4 {
                                       GHC.Types.False -> GHC.Types.True
                                       GHC.Types.True
                                       -> GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.>=# dt1 dt3) }
                                  GHC.Types.True -> GHC.Types.False }
                             GHC.Types.GT -> GHC.Types.True }
                        Lexer.NoLoc -> GHC.Types.False }
                   Lexer.NoLoc -> case b of wild1 { DEFAULT -> GHC.Types.True } }) -}
a30eee500ffeed73c76202d9a53d2902
  $fOrdSrcLoc_$ccompare ::
    Lexer.SrcLoc -> Lexer.SrcLoc -> GHC.Types.Ordering
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (a :: Lexer.SrcLoc) (b :: Lexer.SrcLoc) ->
                 case a of wild {
                   Lexer.SrcLoc a1 dt dt1
                   -> case b of wild1 {
                        Lexer.SrcLoc b1 dt2 dt3
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 of wild2 {
                             GHC.Types.LT -> GHC.Types.LT
                             GHC.Types.EQ
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# dt dt2) of wild3 {
                                  GHC.Types.False
                                  -> case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# dt dt2) of wild4 {
                                       GHC.Types.False -> GHC.Types.GT
                                       GHC.Types.True -> GHC.Classes.compareInt# dt1 dt3 }
                                  GHC.Types.True -> GHC.Types.LT }
                             GHC.Types.GT -> GHC.Types.GT }
                        Lexer.NoLoc -> GHC.Types.LT }
                   Lexer.NoLoc
                   -> case b of wild1 {
                        Lexer.SrcLoc ipv ipv1 ipv2 -> GHC.Types.GT
                        Lexer.NoLoc -> GHC.Types.EQ } }) -}
a30eee500ffeed73c76202d9a53d2902
  $fOrdSrcLoc_$cmax :: Lexer.SrcLoc -> Lexer.SrcLoc -> Lexer.SrcLoc
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Lexer.SrcLoc) (y :: Lexer.SrcLoc) ->
                 case x of wild {
                   Lexer.SrcLoc a1 dt dt1
                   -> case y of wild1 {
                        Lexer.SrcLoc b1 dt2 dt3
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 of wild2 {
                             GHC.Types.LT -> wild1
                             GHC.Types.EQ
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# dt dt2) of wild3 {
                                  GHC.Types.False
                                  -> case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# dt dt2) of wild4 {
                                       GHC.Types.False -> wild
                                       GHC.Types.True
                                       -> case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.<=# dt1 dt3) of wild5 {
                                            GHC.Types.False -> wild GHC.Types.True -> wild1 } }
                                  GHC.Types.True -> wild1 }
                             GHC.Types.GT -> wild }
                        Lexer.NoLoc -> Lexer.NoLoc }
                   Lexer.NoLoc -> case y of wild1 { DEFAULT -> Lexer.NoLoc } }) -}
a30eee500ffeed73c76202d9a53d2902
  $fOrdSrcLoc_$cmin :: Lexer.SrcLoc -> Lexer.SrcLoc -> Lexer.SrcLoc
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ (x :: Lexer.SrcLoc) (y :: Lexer.SrcLoc) ->
                 case x of wild {
                   Lexer.SrcLoc a1 dt dt1
                   -> case y of wild1 {
                        Lexer.SrcLoc b1 dt2 dt3
                        -> case GHC.Classes.$fOrd[]_$s$ccompare1 a1 b1 of wild2 {
                             GHC.Types.LT -> wild
                             GHC.Types.EQ
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# dt dt2) of wild3 {
                                  GHC.Types.False
                                  -> case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.==# dt dt2) of wild4 {
                                       GHC.Types.False -> wild1
                                       GHC.Types.True
                                       -> case GHC.Prim.tagToEnum#
                                                 @ GHC.Types.Bool
                                                 (GHC.Prim.<=# dt1 dt3) of wild5 {
                                            GHC.Types.False -> wild1 GHC.Types.True -> wild } }
                                  GHC.Types.True -> wild }
                             GHC.Types.GT -> wild1 }
                        Lexer.NoLoc -> wild }
                   Lexer.NoLoc -> y }) -}
8ad762a8f713985ba5a77fe5ffc50e0d
  $fShowAlexResult :: GHC.Show.Show Lexer.AlexResult
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lexer.AlexResult
                  Lexer.$fShowAlexResult_$cshowsPrec1
                  Lexer.$fShowAlexResult_$cshow
                  Lexer.$fShowAlexResult_$cshowList -}
8ad762a8f713985ba5a77fe5ffc50e0d
  $fShowAlexResult1 :: Lexer.AlexResult -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ (w :: Lexer.AlexResult) ->
                 case w of ww { Lexer.AR ww1 ww2 ww3 ->
                 Lexer.$w$cshowsPrec 0# ww1 ww2 ww3 }) -}
9f5c1187d48b0433d4631784196d8c9b
  $fShowAlexResult2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "AR "#) -}
a59107b2d48796b2adc46ebef4fe81b5
  $fShowAlexResult3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NoLoc"#) -}
a8ebfdf9b39f568c7a4852aa9d73f052
  $fShowAlexResult4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SrcLoc "#) -}
75122832e3322fba3fb236bd39440f03
  $fShowAlexResult5 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 11#) -}
8ad762a8f713985ba5a77fe5ffc50e0d
  $fShowAlexResult_$cshow :: Lexer.AlexResult -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,U,U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Lexer.AlexResult) ->
                 Lexer.$fShowAlexResult_$cshowsPrec1
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
8ad762a8f713985ba5a77fe5ffc50e0d
  $fShowAlexResult_$cshowList :: [Lexer.AlexResult] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lexer.AlexResult
                   Lexer.$fShowAlexResult1) -}
a30eee500ffeed73c76202d9a53d2902
  $fShowAlexResult_$cshowsPrec ::
    GHC.Types.Int -> Lexer.SrcLoc -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ (a :: GHC.Types.Int)
                   (ds :: Lexer.SrcLoc)
                   (eta :: GHC.Base.String) ->
                 case ds of wild {
                   Lexer.SrcLoc b1 dt dt1
                   -> case a of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ (x1 :: GHC.Base.String)[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Lexer.$fShowAlexResult4
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.shows6
                               (GHC.Show.showLitString
                                  b1
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.shows6
                                     (GHC.Types.:
                                        @ GHC.Types.Char
                                        GHC.Show.showSpace1
                                        (case GHC.Show.$wshowSignedInt
                                                11#
                                                dt
                                                (GHC.Types.:
                                                   @ GHC.Types.Char
                                                   GHC.Show.showSpace1
                                                   (case GHC.Show.$wshowSignedInt
                                                           11#
                                                           dt1
                                                           x1 of ww4 { (#,#) ww5 ww6 ->
                                                    GHC.Types.:
                                                      @ GHC.Types.Char
                                                      ww5
                                                      ww6 })) of ww4 { (#,#) ww5 ww6 ->
                                         GHC.Types.: @ GHC.Types.Char ww5 ww6 })))))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11#) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows7
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 eta)) } }
                   Lexer.NoLoc
                   -> GHC.Base.++ @ GHC.Types.Char Lexer.$fShowAlexResult3 eta }) -}
8ad762a8f713985ba5a77fe5ffc50e0d
  $fShowAlexResult_$cshowsPrec1 ::
    GHC.Types.Int -> Lexer.AlexResult -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S(S),1*U(U)><S,1*U(1*U,U,U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int) (w1 :: Lexer.AlexResult) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Lexer.AR ww3 ww4 ww5 ->
                 Lexer.$w$cshowsPrec ww1 ww3 ww4 ww5 } }) -}
b349f6a51d347de013d5c5d3a0eb3033
  $fShowL :: GHC.Show.Show a => GHC.Show.Show (Lexer.L a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Lexer.L a)
                  (Lexer.$fShowL_$cshowsPrec @ a $dShow)
                  (Lexer.$fShowL_$cshow @ a $dShow)
                  (Lexer.$fShowL_$cshowList @ a $dShow) -}
538695b1ec73ca8fd681ff27dfe22b65
  $fShowL1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
3b3a040cf60098c175d4d91e0ca72080
  $fShowL2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "getVal = "#) -}
9b99e7ef66267ac0426a4c2a1892d48b
  $fShowL3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
2241161abdfde0bba0c0e681f7e068d7
  $fShowL4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "getLoc = "#) -}
3a3d369f758b5add478d0e25ea4b6de7
  $fShowL5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "L {"#) -}
b349f6a51d347de013d5c5d3a0eb3033
  $fShowL_$cshow :: GHC.Show.Show a => Lexer.L a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,1*U(U,U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a ($dShow :: GHC.Show.Show a) (x :: Lexer.L a) ->
                 Lexer.$fShowL_$cshowsPrec
                   @ a
                   $dShow
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
b349f6a51d347de013d5c5d3a0eb3033
  $fShowL_$cshowList ::
    GHC.Show.Show a => [Lexer.L a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Lexer.L a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Lexer.L a)
                   (Lexer.$fShowL_$cshowsPrec @ a $dShow Lexer.$fShowToken2)
                   eta
                   eta1) -}
b349f6a51d347de013d5c5d3a0eb3033
  $fShowL_$cshowsPrec ::
    GHC.Show.Show a => GHC.Types.Int -> Lexer.L a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Lexer.L a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Lexer.L ww3 ww4 ->
                 Lexer.$w$cshowsPrec1 @ a w ww1 ww3 ww4 } }) -}
a30eee500ffeed73c76202d9a53d2902
  $fShowSrcLoc :: GHC.Show.Show Lexer.SrcLoc
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lexer.SrcLoc
                  Lexer.$fShowAlexResult_$cshowsPrec
                  Lexer.$fShowSrcLoc_$cshow
                  Lexer.$fShowSrcLoc_$cshowList -}
a30eee500ffeed73c76202d9a53d2902
  $fShowSrcLoc1 :: Lexer.SrcLoc -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Lexer.$fShowAlexResult_$cshowsPrec
                   Lexer.$fShowToken2) -}
a30eee500ffeed73c76202d9a53d2902
  $fShowSrcLoc_$cshow :: Lexer.SrcLoc -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Lexer.SrcLoc) ->
                 Lexer.$fShowAlexResult_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a30eee500ffeed73c76202d9a53d2902
  $fShowSrcLoc_$cshowList :: [Lexer.SrcLoc] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lexer.SrcLoc
                   Lexer.$fShowSrcLoc1) -}
062aa1a04d631f02a39ae09e221d0fdc
  $fShowToken :: GHC.Show.Show Lexer.Token
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Lexer.Token
                  Lexer.$fShowToken_$cshowsPrec
                  Lexer.$fShowToken_$cshow
                  Lexer.$fShowToken_$cshowList -}
062aa1a04d631f02a39ae09e221d0fdc
  $fShowToken1 :: Lexer.Token -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Lexer.$fShowToken_$cshowsPrec Lexer.$fShowToken2) -}
af59baf4562063e86b4628bdc6b43a69
  $fShowToken10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Sym "#) -}
8105cf9fa537af9ffddd8f23e16bcc14
  $fShowToken11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Upp "#) -}
1df3f6f09a716cd35834afbdfd371c69
  $fShowToken12 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows6
                   (GHC.Types.[] @ GHC.Types.Char)) -}
9b52b461f4335a20186d0af9f250192f
  $fShowToken13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Low "#) -}
9514bd97b8d5a13b6a359c8ef4f35672
  $fShowToken14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Arrow"#) -}
a430ecbb435c52fd7f29949697bf6540
  $fShowToken15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "TwoColons"#) -}
e074156db5582fe032b31e1d19233f7a
  $fShowToken16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Colon"#) -}
515918a86b14c903fb51b3137da89ff3
  $fShowToken17 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Equal"#) -}
7c947fd7c0e0bc3fe46e7658d07383a5
  $fShowToken18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "RParen"#) -}
be782a1e227808c07468a2d07bf2d720
  $fShowToken19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "LParen"#) -}
a21ccb243a128137eed049b6e09ca5cd
  $fShowToken2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
1bcb823e132fd9df0f8354f7125fd59b
  $fShowToken3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "EOF"#) -}
6db7034c125b750cee32922bcf1459b2
  $fShowToken4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Data"#) -}
3fb0ea3a4fe51bdaf63f4cc3f5d92b3e
  $fShowToken5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Dec "#) -}
d94f82ddd17b06e252d812144458f39f
  $fShowToken6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Hex "#) -}
e8d982888668067c1f59129d6be3b689
  $fShowToken7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Bin "#) -}
732e401ea1705494e8f5ac1c94dcf93a
  $fShowToken8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Pipe"#) -}
696be26209ceed421726ac716c59bc87
  $fShowToken9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Semic"#) -}
062aa1a04d631f02a39ae09e221d0fdc
  $fShowToken_$cshow :: Lexer.Token -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: Lexer.Token) ->
                 case x of wild {
                   Lexer.LParen -> Lexer.$fShowToken19
                   Lexer.RParen -> Lexer.$fShowToken18
                   Lexer.Equal -> Lexer.$fShowToken17
                   Lexer.Colon -> Lexer.$fShowToken16
                   Lexer.TwoColons -> Lexer.$fShowToken15
                   Lexer.Arrow -> Lexer.$fShowToken14
                   Lexer.Low b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Lexer.$fShowToken13
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.shows6
                           (GHC.Show.showLitString b1 Lexer.$fShowToken12))
                   Lexer.Upp b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Lexer.$fShowToken11
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.shows6
                           (GHC.Show.showLitString b1 Lexer.$fShowToken12))
                   Lexer.Sym b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Lexer.$fShowToken10
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.shows6
                           (GHC.Show.showLitString b1 Lexer.$fShowToken12))
                   Lexer.Semic -> Lexer.$fShowToken9
                   Lexer.Pipe -> Lexer.$fShowToken8
                   Lexer.Bin b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Lexer.$fShowToken7
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.shows6
                           (GHC.Show.showLitString b1 Lexer.$fShowToken12))
                   Lexer.Hex b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Lexer.$fShowToken6
                        (GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.shows6
                           (GHC.Show.showLitString b1 Lexer.$fShowToken12))
                   Lexer.Dec b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Lexer.$fShowToken5
                        (case b1 of ww2 { GHC.Types.I# ww3 ->
                         case GHC.Show.$wshowSignedInt
                                11#
                                ww3
                                (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                         GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                   Lexer.Data -> Lexer.$fShowToken4
                   Lexer.EOF -> Lexer.$fShowToken3 }) -}
062aa1a04d631f02a39ae09e221d0fdc
  $fShowToken_$cshowList :: [Lexer.Token] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Lexer.Token
                   Lexer.$fShowToken1) -}
062aa1a04d631f02a39ae09e221d0fdc
  $fShowToken_$cshowsPrec ::
    GHC.Types.Int -> Lexer.Token -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
40a490ce583e81aaf916b170a3cab9b2
  $tc'AI :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   674447939664350073##
                   12146069565427130784##
                   Lexer.$trModule
                   Lexer.$tc'AI1) -}
2ae6748ba89bb59ad4c4fd6c1e6a18cc
  $tc'AI1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AI"#) -}
af059892d207b42513b8f3c6b8ba82ea
  $tc'AR :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12995464887191731320##
                   2477091815413870790##
                   Lexer.$trModule
                   Lexer.$tc'AR1) -}
70c6db097526268bcf358274f87fb950
  $tc'AR1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AR"#) -}
baf73868e2b78a8e2300aee1adbdf7b7
  $tc'AlexA# :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15284129240881443745##
                   15833160983150690054##
                   Lexer.$trModule
                   Lexer.$tc'AlexA#1) -}
0406f8461103b347aba0c599d44db321
  $tc'AlexA#1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AlexA#"#) -}
5c1a429aeff9465a024741a727051cc9
  $tc'AlexAcc :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5059356497587650268##
                   13234694705098401604##
                   Lexer.$trModule
                   Lexer.$tc'AlexAcc1) -}
248b3ee273d402703d8f6b887e3fda9b
  $tc'AlexAcc1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AlexAcc"#) -}
e052178456c1cdce124c44113b7a65eb
  $tc'AlexAccNone :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14197060399824277100##
                   17976035425250274400##
                   Lexer.$trModule
                   Lexer.$tc'AlexAccNone1) -}
65e746ebc1d7b9f3f6cb2081935f70f7
  $tc'AlexAccNone1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AlexAccNone"#) -}
248eee2d2bc47efb6f7085fcaa220c39
  $tc'AlexAccSkip :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2783327732135600729##
                   17368242999854900042##
                   Lexer.$trModule
                   Lexer.$tc'AlexAccSkip1) -}
21614a49f261f727d0c9c638d60407d4
  $tc'AlexAccSkip1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AlexAccSkip"#) -}
cf752a555c84c101dadf5a72f79d2728
  $tc'AlexEOF :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   12297540369476717268##
                   12773875358666628302##
                   Lexer.$trModule
                   Lexer.$tc'AlexEOF1) -}
7468069ecf862afe9cc926416f7b2efa
  $tc'AlexEOF1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AlexEOF"#) -}
62dfa9580e78f3d99b963bd211a5014c
  $tc'AlexError :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11822392216386188610##
                   12259579549961563712##
                   Lexer.$trModule
                   Lexer.$tc'AlexError1) -}
941174a388a36ec9f2d22690956a6a01
  $tc'AlexError1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AlexError"#) -}
0b25f0a80362154d62d466f3c57be734
  $tc'AlexLastAcc :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2531501167317362494##
                   11719743993803393407##
                   Lexer.$trModule
                   Lexer.$tc'AlexLastAcc1) -}
8c9dcd83c8b7cff6ecae9800a4c9af5d
  $tc'AlexLastAcc1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AlexLastAcc"#) -}
089b6068e055f4c952cc2269c75b39fe
  $tc'AlexLastSkip :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15666057826690978548##
                   18118811636740866108##
                   Lexer.$trModule
                   Lexer.$tc'AlexLastSkip1) -}
7122d3119d6b550983ee64d5a426e3e4
  $tc'AlexLastSkip1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AlexLastSkip"#) -}
7da36d88c7981bf63b9ab237fdfecc18
  $tc'AlexNone :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   4208535174138567816##
                   8717858428659401997##
                   Lexer.$trModule
                   Lexer.$tc'AlexNone1) -}
5c5d896448eb267dde1f0b377d4f60e3
  $tc'AlexNone1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AlexNone"#) -}
54cf5fc0279a618d07efcab937654615
  $tc'AlexSkip :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17288347657850922030##
                   14094953330500328617##
                   Lexer.$trModule
                   Lexer.$tc'AlexSkip1) -}
d93e37de2dcb3f46019b6aea5f3f6bbf
  $tc'AlexSkip1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AlexSkip"#) -}
added2a598d35390fbf8b52f4a9109b5
  $tc'AlexToken :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2446538407306634599##
                   10207558901300050045##
                   Lexer.$trModule
                   Lexer.$tc'AlexToken1) -}
d0ccb6071f4378fdc2207fc57c3eab7e
  $tc'AlexToken1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'AlexToken"#) -}
ae9482262de7c12538c95ad4afede2fc
  $tc'Arrow :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10084866151306120549##
                   5029597100194859018##
                   Lexer.$trModule
                   Lexer.$tc'Arrow1) -}
65ba2fe54632f29b58974787985baa14
  $tc'Arrow1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Arrow"#) -}
9468b78ea3209d0eb4c7fa6d06ac42b2
  $tc'Bin :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   6941240187938312507##
                   11999731531433995467##
                   Lexer.$trModule
                   Lexer.$tc'Bin1) -}
04b16afca01eb918afe15bfd691c0848
  $tc'Bin1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Bin"#) -}
1173ecde719004f7f1d118a1e69bab8a
  $tc'Buf :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2793711996697386381##
                   8231932621896821769##
                   Lexer.$trModule
                   Lexer.$tc'Buf1) -}
20e59ee99151f0ca63be019cab09598c
  $tc'Buf1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Buf"#) -}
b9568b8884f8869d10b19a9a83cb01df
  $tc'Colon :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   24507752515565827##
                   18114783712612454308##
                   Lexer.$trModule
                   Lexer.$tc'Colon1) -}
c5943fdbcf6f34aa2754768085d45ccc
  $tc'Colon1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Colon"#) -}
9f7822559ac8fabcbaca3b96ddc9e7f0
  $tc'Data :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15129906571566363549##
                   15786189997473242083##
                   Lexer.$trModule
                   Lexer.$tc'Data1) -}
4f4f2c18758d18837cc066d594f700d7
  $tc'Data1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Data"#) -}
0cc5f31eb05b41361dc5063f0ac43102
  $tc'Dec :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9437375524107092740##
                   17378871600909704902##
                   Lexer.$trModule
                   Lexer.$tc'Dec1) -}
07743c217422ff0bac83b6baba1a5e68
  $tc'Dec1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Dec"#) -}
84d7506304bb2ead09533c2e91bddd59
  $tc'EOF :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   188527566281134549##
                   3517739375098044123##
                   Lexer.$trModule
                   Lexer.$tc'EOF1) -}
6edd0ecaaaa87d6c394d3d86f0f7d51f
  $tc'EOF1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'EOF"#) -}
cd5b851460c357230a33c02a35162ae6
  $tc'Equal :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15953611673550980060##
                   6980120639889958999##
                   Lexer.$trModule
                   Lexer.$tc'Equal1) -}
f69f602da3618f13e77715e4b8e934b0
  $tc'Equal1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Equal"#) -}
2045336a67c77c22efcbdb529c5cbaed
  $tc'Hex :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1205336129941056450##
                   17096215308537682240##
                   Lexer.$trModule
                   Lexer.$tc'Hex1) -}
3471ab1606dfa2aceba12a111307ba70
  $tc'Hex1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Hex"#) -}
1a329294461162a2bb65deb78d2d9db3
  $tc'L :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16528390602912408240##
                   14162430985690394404##
                   Lexer.$trModule
                   Lexer.$tc'L1) -}
9e326c4a8fe919b9cbadc5e822c49259
  $tc'L1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'L"#) -}
3fe3637bec032cb37291df9970b1c275
  $tc'LParen :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   746308326237071828##
                   17255044763968389667##
                   Lexer.$trModule
                   Lexer.$tc'LParen1) -}
6e8c01980f17be061d7aed7d610675f1
  $tc'LParen1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'LParen"#) -}
b0aa6c848406ca02c9116d9df4b809bf
  $tc'Low :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1083509309299494288##
                   6320909240171251414##
                   Lexer.$trModule
                   Lexer.$tc'Low1) -}
0e64c595e77b86ab685052c7cc6631b1
  $tc'Low1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Low"#) -}
5468be81ac374b23068449f05c68b79f
  $tc'NoLoc :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3272320530455830310##
                   10607682005265661522##
                   Lexer.$trModule
                   Lexer.$tc'NoLoc1) -}
0f738220f56322d899924767ffdbb9a3
  $tc'NoLoc1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'NoLoc"#) -}
27a3abcee1ec9c82ad897e8118750a3c
  $tc'Pipe :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14620389695535717103##
                   11376249810009274287##
                   Lexer.$trModule
                   Lexer.$tc'Pipe1) -}
e1e318b49a9292f269005fc161914f12
  $tc'Pipe1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Pipe"#) -}
200f3fd2a03b3389acb15b88c0487983
  $tc'RParen :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   3459576752413605673##
                   13690654374894672634##
                   Lexer.$trModule
                   Lexer.$tc'RParen1) -}
970a7d7025c7b65a5608b85fe1f0cf06
  $tc'RParen1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'RParen"#) -}
13828de7d989c72cfc7453c7ba076381
  $tc'Semic :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8983681570190087533##
                   4794682951259129582##
                   Lexer.$trModule
                   Lexer.$tc'Semic1) -}
fc7d22363b5dacbc6a9dd92979952eb8
  $tc'Semic1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Semic"#) -}
f4efa676b7755127ba87be72796baaea
  $tc'SrcLoc :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11988833090740676908##
                   2042961037228187536##
                   Lexer.$trModule
                   Lexer.$tc'SrcLoc1) -}
20142ced24a259910ed80fc886ff2c7c
  $tc'SrcLoc1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'SrcLoc"#) -}
61b72f4b197e7e598de08463a16f2440
  $tc'Sym :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15626566320578796951##
                   3769748056383407479##
                   Lexer.$trModule
                   Lexer.$tc'Sym1) -}
6c8b43e13628bc737fef2f2ba01830f5
  $tc'Sym1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Sym"#) -}
69dab43532ab5d40823ac6ec1a6521fe
  $tc'TwoColons :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13902184887102259305##
                   7486911350865628130##
                   Lexer.$trModule
                   Lexer.$tc'TwoColons1) -}
d50a35149d0492fcf86ee4c2712f6dd6
  $tc'TwoColons1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'TwoColons"#) -}
3e99401d4c242df577318a1844c7b33e
  $tc'Upp :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11845528477873290380##
                   10669847799163809650##
                   Lexer.$trModule
                   Lexer.$tc'Upp1) -}
274e45a1cb8e498dee142ce414d3bc93
  $tc'Upp1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Upp"#) -}
abd834f34972eaa7643c71903f7588c8
  $tcAlexAcc :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14573310754418320329##
                   8534606142513544839##
                   Lexer.$trModule
                   Lexer.$tcAlexAcc1) -}
a68491b2135f1d750f434dfdc08cb18d
  $tcAlexAcc1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "AlexAcc"#) -}
7c613fae44c36cb89b7320e89d53c389
  $tcAlexAddr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   5235106696403666259##
                   10869871651844846517##
                   Lexer.$trModule
                   Lexer.$tcAlexAddr1) -}
7416dd27c4244bb41b260cf1e381af46
  $tcAlexAddr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "AlexAddr"#) -}
69d61d328226f3ce1f836fd9a4e74c79
  $tcAlexInput :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15148101594725265316##
                   2757795147889544763##
                   Lexer.$trModule
                   Lexer.$tcAlexInput1) -}
ee62cda61b67c9b3b6a9cc913e7c0120
  $tcAlexInput1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "AlexInput"#) -}
ab7fad61bf6c20ee2e8327b6184d1461
  $tcAlexLastAcc :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9841905772250171357##
                   16575896827321470179##
                   Lexer.$trModule
                   Lexer.$tcAlexLastAcc1) -}
cf2fd895c661e0f0c7db671dffeff937
  $tcAlexLastAcc1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "AlexLastAcc"#) -}
8923af202718ea8f2ea1a8d50b861516
  $tcAlexResult :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9321083324528725993##
                   15720296007207933530##
                   Lexer.$trModule
                   Lexer.$tcAlexResult1) -}
b3f8147b4ce3d8bd9cf17a531326c49b
  $tcAlexResult1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "AlexResult"#) -}
5e31ca860c21279af76319c25c622fee
  $tcAlexReturn :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7707402819338392##
                   6739431211655691165##
                   Lexer.$trModule
                   Lexer.$tcAlexReturn1) -}
b33efc6d081f00d7cb9bd5922c920a23
  $tcAlexReturn1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "AlexReturn"#) -}
6708dc8ad263231af1e24c58ece8730d
  $tcBuffer :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10972115391680208244##
                   14927456982934383860##
                   Lexer.$trModule
                   Lexer.$tcBuffer1) -}
2121ab47b67f888e4013c89b74a42d89
  $tcBuffer1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Buffer"#) -}
596d33a270af8032b818e4214ef98a17
  $tcL :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   13456863654627787380##
                   10830287590207501482##
                   Lexer.$trModule
                   Lexer.$tcL1) -}
09cdd991a47c1151a4c202b99079d043
  $tcL1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "L"#) -}
9127939fc78bda8684d89d2f361b69d8
  $tcSrcLoc :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8178995266517882813##
                   14236651930823630489##
                   Lexer.$trModule
                   Lexer.$tcSrcLoc1) -}
e4a064ff4b2a683090772068e71be9b6
  $tcSrcLoc1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "SrcLoc"#) -}
b1a2cce36a67dda617ee722b85bd3d34
  $tcToken :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16909412753999441771##
                   12314138686525141203##
                   Lexer.$trModule
                   Lexer.$tcToken1) -}
cbba649bee802b6c441aa8cd90f17d29
  $tcToken1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Token"#) -}
faf06c3ca68b2a931ff5aab8d5154989
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Lexer.$trModule2 Lexer.$trModule1) -}
7ae21b50ad30eee6b980a8dde2ead6cb
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Lexer"#) -}
22b92b41bf7c5672cb2779f3a2f700a7
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "HaskellCircuits-0.1.0.0-3mIW93ol3alH6nhlDJ7Hzo"#) -}
e582ed4e930af24af2e913451ff6bf6e
  $w$cshowsPrec ::
    GHC.Prim.Int#
    -> GHC.Base.Maybe Lexer.Token
    -> Lexer.SrcLoc
    -> Lexer.AlexState
    -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <S,U><L,1*U><L,U><L,U(U)>, Inline: [0],
     Unfolding: (\ (ww :: GHC.Prim.Int#)
                   (ww1 :: GHC.Base.Maybe Lexer.Token)
                   (ww2 :: Lexer.SrcLoc)
                   (ww3 :: Lexer.AlexState) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.$fShowMaybe_$cshowsPrec
                       @ Lexer.Token
                       Lexer.$fShowToken
                       Lexer.$fShowAlexResult5
                       ww1
                 } in
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                     {- Arity: 1, Strictness: <L,U> -}
                   = \ (x :: GHC.Base.String) ->
                     f (GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.showSpace1
                          (Lexer.$fShowAlexResult_$cshowsPrec
                             Lexer.$fShowAlexResult5
                             ww2
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.showSpace1
                                (case ww3 of ww4 { GHC.Types.I# ww5 ->
                                 case GHC.Show.$wshowSignedInt 11# ww5 x of ww6 { (#,#) ww7 ww8 ->
                                 GHC.Types.: @ GHC.Types.Char ww7 ww8 } }))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Base.++ @ GHC.Types.Char Lexer.$fShowAlexResult2 (g x)
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Lexer.$fShowAlexResult2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x))) }) -}
bb9192ca9405acb118804af1436dddb0
  $w$cshowsPrec1 ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> Lexer.SrcLoc -> a -> GHC.Show.ShowS
  {- Arity: 4, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (ww1 :: Lexer.SrcLoc)
                   (ww2 :: a) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec @ a w Lexer.$fShowToken2 ww2
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Lexer.$fShowL5
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Lexer.$fShowL4
                          (Lexer.$fShowAlexResult_$cshowsPrec
                             Lexer.$fShowToken2
                             ww1
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Lexer.$fShowL3
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   Lexer.$fShowL2
                                   (f (GHC.Base.++ @ GHC.Types.Char Lexer.$fShowL1 x))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }) -}
29e1ba4e68385ef904f883fc51100f5c
  $walexGetByte ::
    Lexer.SrcLoc
    -> GHC.Types.Char
    -> Lexer.Bytes
    -> GHC.Base.String
    -> Lexer.AlexState
    -> GHC.Base.Maybe (Lexer.Byte, Lexer.AlexInput)
  {- Arity: 5, Strictness: <L,U><L,U><S,1*U><L,U><L,U>, Inline: [0],
     Unfolding: (\ (ww :: Lexer.SrcLoc)
                   (ww1 :: GHC.Types.Char)
                   (ww2 :: Lexer.Bytes)
                   (ww3 :: GHC.Base.String)
                   (ww4 :: Lexer.AlexState) ->
                 case ww2 of wild {
                   []
                   -> case ww3 of wild1 {
                        [] -> GHC.Base.Nothing @ (Lexer.Byte, Lexer.AlexInput)
                        : c s
                        -> GHC.Base.Just
                             @ (GHC.Word.Word8, Lexer.AlexInput)
                             (let {
                                ds :: (GHC.Word.Word8, [GHC.Word.Word8])
                                = case c of wild2 { GHC.Types.C# c# ->
                                  let {
                                    ww5 :: GHC.Prim.Int# = GHC.Prim.ord# c#
                                  } in
                                  case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.<=# ww5 127#) of wild3 {
                                    GHC.Types.False
                                    -> case GHC.Prim.tagToEnum#
                                              @ GHC.Types.Bool
                                              (GHC.Prim.<=# ww5 2047#) of wild4 {
                                         GHC.Types.False
                                         -> case GHC.Prim.tagToEnum#
                                                   @ GHC.Types.Bool
                                                   (GHC.Prim.<=# ww5 65535#) of wild5 {
                                              GHC.Types.False
                                              -> case GHC.Base.map
                                                        @ GHC.Types.Int
                                                        @ GHC.Word.Word8
                                                        Codec.Binary.UTF8.String.encodeChar2
                                                        (GHC.Types.:
                                                           @ GHC.Types.Int
                                                           (GHC.Types.I#
                                                              (GHC.Prim.+#
                                                                 240#
                                                                 (GHC.Prim.uncheckedIShiftRA#
                                                                    ww5
                                                                    18#)))
                                                           (GHC.Types.:
                                                              @ GHC.Types.Int
                                                              (GHC.Types.I#
                                                                 (GHC.Prim.+#
                                                                    128#
                                                                    (GHC.Prim.andI#
                                                                       (GHC.Prim.uncheckedIShiftRA#
                                                                          ww5
                                                                          12#)
                                                                       63#)))
                                                              (GHC.Types.:
                                                                 @ GHC.Types.Int
                                                                 (GHC.Types.I#
                                                                    (GHC.Prim.+#
                                                                       128#
                                                                       (GHC.Prim.andI#
                                                                          (GHC.Prim.uncheckedIShiftRA#
                                                                             ww5
                                                                             6#)
                                                                          63#)))
                                                                 (GHC.Types.:
                                                                    @ GHC.Types.Int
                                                                    (GHC.Types.I#
                                                                       (GHC.Prim.+#
                                                                          128#
                                                                          (GHC.Prim.andI# ww5 63#)))
                                                                    (GHC.Types.[]
                                                                       @ GHC.Types.Int))))) of wild6 {
                                                   [] -> Lexer.alexGetByte1 : b bs -> (b, bs) }
                                              GHC.Types.True
                                              -> case GHC.Base.map
                                                        @ GHC.Types.Int
                                                        @ GHC.Word.Word8
                                                        Codec.Binary.UTF8.String.encodeChar2
                                                        (GHC.Types.:
                                                           @ GHC.Types.Int
                                                           (GHC.Types.I#
                                                              (GHC.Prim.+#
                                                                 224#
                                                                 (GHC.Prim.uncheckedIShiftRA#
                                                                    ww5
                                                                    12#)))
                                                           (GHC.Types.:
                                                              @ GHC.Types.Int
                                                              (GHC.Types.I#
                                                                 (GHC.Prim.+#
                                                                    128#
                                                                    (GHC.Prim.andI#
                                                                       (GHC.Prim.uncheckedIShiftRA#
                                                                          ww5
                                                                          6#)
                                                                       63#)))
                                                              (GHC.Types.:
                                                                 @ GHC.Types.Int
                                                                 (GHC.Types.I#
                                                                    (GHC.Prim.+#
                                                                       128#
                                                                       (GHC.Prim.andI# ww5 63#)))
                                                                 (GHC.Types.[]
                                                                    @ GHC.Types.Int)))) of wild6 {
                                                   [] -> Lexer.alexGetByte1 : b bs -> (b, bs) } }
                                         GHC.Types.True
                                         -> case GHC.Base.map
                                                   @ GHC.Types.Int
                                                   @ GHC.Word.Word8
                                                   Codec.Binary.UTF8.String.encodeChar2
                                                   (GHC.Types.:
                                                      @ GHC.Types.Int
                                                      (GHC.Types.I#
                                                         (GHC.Prim.+#
                                                            192#
                                                            (GHC.Prim.uncheckedIShiftRA# ww5 6#)))
                                                      (GHC.Types.:
                                                         @ GHC.Types.Int
                                                         (GHC.Types.I#
                                                            (GHC.Prim.+#
                                                               128#
                                                               (GHC.Prim.andI# ww5 63#)))
                                                         (GHC.Types.[] @ GHC.Types.Int))) of wild5 {
                                              [] -> Lexer.alexGetByte1 : b bs -> (b, bs) } }
                                    GHC.Types.True
                                    -> case GHC.Base.map
                                              @ GHC.Types.Int
                                              @ GHC.Word.Word8
                                              Codec.Binary.UTF8.String.encodeChar2
                                              (GHC.Types.:
                                                 @ GHC.Types.Int
                                                 (GHC.Types.I# ww5)
                                                 (GHC.Types.[] @ GHC.Types.Int)) of wild4 {
                                         [] -> Lexer.alexGetByte1 : b bs -> (b, bs) } } }
                              } in
                              (case ds of ds1 { (,) b bs -> b },
                               Lexer.AI
                                 (Lexer.nextSrcLoc ww c)
                                 (Lexer.Buf c (case ds of ds1 { (,) b bs -> bs }) s)
                                 ww4)) }
                   : b bs
                   -> GHC.Base.Just
                        @ (Lexer.Byte, Lexer.AlexInput)
                        (b, Lexer.AI ww (Lexer.Buf ww1 bs ww3) ww4) }) -}
3a89b955195b3d91131867c7b6db193e
  $walexScanUser ::
    Lexer.SrcLoc
    -> GHC.Types.Char
    -> Lexer.Bytes
    -> GHC.Base.String
    -> Lexer.AlexState
    -> GHC.Prim.Int#
    -> Lexer.AlexReturn Lexer.Action
  {- Arity: 6, Strictness: <L,U><L,U><S,U><L,U><L,U><S,U>,
     Inline: [0],
     Unfolding: (\ @ t
                   (ww :: Lexer.SrcLoc)
                   (ww1 :: GHC.Types.Char)
                   (ww2 :: Lexer.Bytes)
                   (ww3 :: GHC.Base.String)
                   (ww4 :: Lexer.AlexState)
                   (ww5 :: GHC.Prim.Int#) ->
                 case Lexer.$walex_scan_tkn
                        @ Lexer.AlexInput
                        @ t
                        0#
                        ww
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        Lexer.AlexNone of ww6 { (#,#) ww7 ww8 ->
                 case ww7 of wild {
                   Lexer.AlexNone
                   -> case Lexer.$walexGetByte ww ww1 ww2 ww3 ww4 of wild1 {
                        GHC.Base.Nothing -> Lexer.AlexEOF @ Lexer.Action
                        GHC.Base.Just ds -> Lexer.$WAlexError @ Lexer.Action ww8 }
                   Lexer.AlexLastAcc dt input''' dt1
                   -> Lexer.AlexToken
                        @ Lexer.Action
                        input'''
                        dt1
                        (case Lexer.alex_actions of wild1 { GHC.Arr.Array l u dt2 ds ->
                         case l of wild2 { GHC.Types.I# m ->
                         case u of wild3 { GHC.Types.I# n ->
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<=# m dt) of wild4 {
                           GHC.Types.False
                           -> case Lexer.alexScanUser1 wild3 wild2 dt
                              ret_ty Lexer.Action
                              of {}
                           GHC.Types.True
                           -> case GHC.Prim.tagToEnum#
                                     @ GHC.Types.Bool
                                     (GHC.Prim.<=# dt n) of wild5 {
                                GHC.Types.False
                                -> case Lexer.alexScanUser1 wild3 wild2 dt
                                   ret_ty Lexer.Action
                                   of {}
                                GHC.Types.True
                                -> case GHC.Prim.indexArray#
                                          @ Lexer.Action
                                          ds
                                          (GHC.Prim.-# dt m) of ds4 { Unit# ipv ->
                                   ipv } } } } } })
                   Lexer.AlexLastSkip input'' dt
                   -> Lexer.AlexSkip @ Lexer.Action input'' dt } }) -}
2eda15d437874c1e66d9ebf394a3d3ae
  $walex_scan_tkn ::
    GHC.Prim.Int#
    -> Lexer.SrcLoc
    -> GHC.Types.Char
    -> Lexer.Bytes
    -> GHC.Base.String
    -> Lexer.AlexState
    -> GHC.Prim.Int#
    -> Lexer.AlexLastAcc
    -> (# Lexer.AlexLastAcc, Lexer.AlexInput #)
  {- Arity: 8,
     Strictness: <L,U><L,U><L,U><S,U><L,U><L,U><S,U><L,1*U>,
     Inline: [0] -}
028aa9430fe1232b090b20ba89de7a92
  $wgo ::
    [Lexer.L Lexer.Token]
    -> Lexer.SrcLoc
    -> GHC.Types.Char
    -> Lexer.Bytes
    -> GHC.Base.String
    -> GHC.Prim.Int#
    -> Data.Either.Either
         GHC.Base.String ([Lexer.L Lexer.Token], Lexer.AlexInput)
  {- Arity: 6, Strictness: <L,U><L,U><L,U><S,U><L,U><S,U>,
     Inline: [0] -}
6e556804bc8c4b1819174a2c70a5970b
  $wreadToken ::
    Lexer.SrcLoc
    -> GHC.Types.Char
    -> Lexer.Bytes
    -> GHC.Base.String
    -> GHC.Prim.Int#
    -> Data.Either.Either
         GHC.Base.String (Lexer.LToken, Lexer.AlexInput)
  {- Arity: 5, Strictness: <L,U><L,U><S,U><L,U><S,U>, Inline: [0] -}
29060f4c0c30b681ced02abb83287898
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
d5bd6d53968224804141f60276dcf6d8
  $wunsafeDrop1 :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
14d5ae0219466ce475bb9c5b47cdaab1
  type Action =
    GHC.Base.String
    -> Lexer.SrcLoc -> Lexer.AlexState -> Lexer.AlexResult
a4d22d7183fb87cfd735eb0048a3a9d5
  type role AlexAcc phantom
  data AlexAcc user
    = AlexAccNone | AlexAcc GHC.Types.Int | AlexAccSkip
77d3dc44b34456449e89cfca493825f3
  data AlexAddr = AlexA# GHC.Prim.Addr#
560795dbde69675daf9497cc0680e866
  data AlexInput = AI Lexer.SrcLoc Lexer.Buffer Lexer.AlexState
6f6a28d05e5c9d05d0160a2035f7ac4c
  data AlexLastAcc
    = AlexNone
    | AlexLastAcc {-# UNPACK #-}GHC.Types.Int
                  !Lexer.AlexInput
                  {-# UNPACK #-}GHC.Types.Int
    | AlexLastSkip !Lexer.AlexInput {-# UNPACK #-}GHC.Types.Int
8ad762a8f713985ba5a77fe5ffc50e0d
  data AlexResult
    = AR (GHC.Base.Maybe Lexer.Token) Lexer.SrcLoc Lexer.AlexState
158810f0c5d609856e5d1461d733385b
  data AlexReturn a
    = AlexEOF
    | AlexError !Lexer.AlexInput
    | AlexSkip !Lexer.AlexInput {-# UNPACK #-}GHC.Types.Int
    | AlexToken !Lexer.AlexInput {-# UNPACK #-}GHC.Types.Int a
d7c20cdc2d40cc91ef46f2f803a61e79
  type AlexState = GHC.Types.Int
45af2470f588d7c76736ab6fd3c885a8
  data Buffer
    = Buf {getPrevious :: GHC.Types.Char,
           getBytes :: Lexer.Bytes,
           getString :: GHC.Base.String}
d4ed460ff3f0390e17a2afbb06b3bf9e
  type Byte = GHC.Word.Word8
2ff7b9b73b2749ab365414cf88ac0c53
  type Bytes = [Lexer.Byte]
43ed7a4a7a9553551f276897cec19687
  type Col = GHC.Types.Int
b0f4cfad5acaad4e8f83268e2b10a218
  type FileName = GHC.Base.String
b349f6a51d347de013d5c5d3a0eb3033
  data L a = L {getLoc :: Lexer.SrcLoc, getVal :: a}
fd141e29e5214152a04ab8dbc6cb5857
  type LToken = Lexer.L Lexer.Token
b547a8632e5265d768bf098a9ad42f01
  type Line = GHC.Types.Int
a30eee500ffeed73c76202d9a53d2902
  data SrcLoc
    = SrcLoc Lexer.FileName
             {-# UNPACK #-}Lexer.Line
             {-# UNPACK #-}Lexer.Col
    | NoLoc
71b5fd2ca90986c273ae132ba7da046b
  type T a =
    Control.Monad.Trans.State.Lazy.StateT
      Lexer.AlexInput (Data.Either.Either GHC.Base.String) a
062aa1a04d631f02a39ae09e221d0fdc
  data Token
    = LParen
    | RParen
    | Equal
    | Colon
    | TwoColons
    | Arrow
    | Low GHC.Base.String
    | Upp GHC.Base.String
    | Sym GHC.Base.String
    | Semic
    | Pipe
    | Bin GHC.Base.String
    | Hex GHC.Base.String
    | Dec GHC.Types.Int
    | Data
    | EOF
338ac8e27937996970f8cf00f829dbdf
  alexGetByte ::
    Lexer.AlexInput -> GHC.Base.Maybe (Lexer.Byte, Lexer.AlexInput)
  {- Arity: 1, Strictness: <S(LS(LSL)L),1*U(U,1*U(U,1*U,U),U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lexer.AlexInput) ->
                 case w of ww { Lexer.AI ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lexer.Buf ww5 ww6 ww7 ->
                 Lexer.$walexGetByte ww1 ww5 ww6 ww7 ww3 } }) -}
73783ddb073678521610a81bdf5e1d56
  alexGetByte1 :: (GHC.Word.Word8, [GHC.Word.Word8])
  {- Strictness: x -}
3c57fc86d85aadf0796cba9e2ba0521b
  alexIndexInt16OffAddr ::
    Lexer.AlexAddr -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (ds :: Lexer.AlexAddr) (off :: GHC.Prim.Int#) ->
                 case ds of wild { Lexer.AlexA# arr ->
                 GHC.Prim.indexInt16OffAddr# arr off }) -}
a7a0b6b92d35f53b81cf76db0aa868eb
  alexIndexInt32OffAddr ::
    Lexer.AlexAddr -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S,U>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (ds :: Lexer.AlexAddr) (off :: GHC.Prim.Int#) ->
                 case ds of wild { Lexer.AlexA# arr ->
                 GHC.Prim.indexInt32OffAddr# arr off }) -}
4617b005345acfbdab33754f9eae7381
  alexInputPrevChar :: Lexer.AlexInput -> GHC.Types.Char
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(SLL)L),1*U(A,1*U(1*U(U),A,A),A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lexer.AlexInput) ->
                 case ds of wild { Lexer.AI ds1 ds2 ds3 ->
                 case ds2 of wild1 { Lexer.Buf c ds4 ds5 -> c } }) -}
739bf413030db47bfce4c2cb18a83a5f
  alexScan ::
    Lexer.AlexInput -> GHC.Types.Int -> Lexer.AlexReturn Lexer.Action
  {- Arity: 2,
     Strictness: <S(LS(LSL)L),U(U,U(U,U,U),U)><S(S),1*U(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (input :: Lexer.AlexInput) (ds :: GHC.Types.Int) ->
                 case ds of wild { GHC.Types.I# sc ->
                 Lexer.alexScanUser
                   @ GHC.Prim.Any
                   Lexer.alexScan1
                   input
                   (GHC.Types.I# sc) }) -}
afc79a01ef8c1c94f2718b275484b024
  alexScan1 :: GHC.Prim.Any
  {- Strictness: x -}
9fca64015931a2c010063a5b229229a9
  alexScanUser ::
    t
    -> Lexer.AlexInput
    -> GHC.Types.Int
    -> Lexer.AlexReturn Lexer.Action
  {- Arity: 3,
     Strictness: <L,A><S(LS(LSL)L),U(U,U(U,U,U),U)><S(S),1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ t (w :: t) (w1 :: Lexer.AlexInput) (w2 :: GHC.Types.Int) ->
                 case w1 of ww { Lexer.AI ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lexer.Buf ww5 ww6 ww7 ->
                 case w2 of ww8 { GHC.Types.I# ww9 ->
                 Lexer.$walexScanUser @ t ww1 ww5 ww6 ww7 ww3 ww9 } } }) -}
7f3efbfd1f71f5cd64496d05b4d2308d
  alexScanUser1 ::
    GHC.Types.Int -> GHC.Types.Int -> GHC.Prim.Int# -> GHC.Types.Int
  {- Arity: 3, Strictness: <L,U><L,U><L,U>x -}
ab360d9237c9527023dfc0c682f769be
  alex_accept :: GHC.Arr.Array GHC.Types.Int (Lexer.AlexAcc user)
  {- Unfolding: (\ @ user ->
                 case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (GHC.Arr.Array GHC.Types.Int (Lexer.AlexAcc user))
                        (Lexer.alex_accept1 @ user) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
5ee33b898fbc5de4c8cbfb9b92c133a0
  alex_accept1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Arr.Array GHC.Types.Int (Lexer.AlexAcc user) #)
  {- Arity: 1,
     Unfolding: (\ @ user
                   (s1# :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.Prim.newArray#
                        @ (Lexer.AlexAcc user)
                        @ GHC.Prim.RealWorld
                        50#
                        (GHC.Arr.arrEleBottom @ (Lexer.AlexAcc user))
                        s1# of ds1 { (#,#) ipv ipv1 ->
                 letrec {
                   go :: [Lexer.AlexAcc user]
                         -> GHC.Prim.Int#
                         -> GHC.Prim.State# GHC.Prim.RealWorld
                         -> GHC.Prim.State# GHC.Prim.RealWorld
                     {- Arity: 3, Strictness: <S,1*U><L,U><S,U> -}
                   = \ (ds :: [Lexer.AlexAcc user])
                       (eta :: GHC.Prim.Int#)
                       (eta1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                     case ds of wild {
                       [] -> eta1
                       : y ys
                       -> case GHC.Prim.writeArray#
                                 @ GHC.Prim.RealWorld
                                 @ (Lexer.AlexAcc user)
                                 ipv1
                                 eta
                                 y
                                 eta1 of s4# { DEFAULT ->
                          case eta of wild1 {
                            DEFAULT -> go ys (GHC.Prim.+# wild1 1#) s4# 49# -> s4# } } }
                 } in
                 case go (Lexer.alex_accept3 @ user) 0# ipv of wild4 { DEFAULT ->
                 case GHC.Prim.unsafeFreezeArray#
                        @ GHC.Prim.RealWorld
                        @ (Lexer.AlexAcc user)
                        ipv1
                        wild4 of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2,
                    GHC.Arr.Array
                      @ GHC.Types.Int
                      @ (Lexer.AlexAcc user)
                      Lexer.$fShowToken2
                      Lexer.alex_accept2
                      50#
                      ipv3 #) } } }) -}
1c4feedcb3c67b3662dade701c48df3d
  alex_accept10 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept11 @ user)) -}
cbf6d69b65e5ed9f072d74d93343649a
  alex_accept11 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept12 @ user)) -}
ad72c4074140e58a1922e2b28e3cdec9
  alex_accept12 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept13 @ user)) -}
7fd453e5c52689e38d7652d1da919876
  alex_accept13 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept14 @ user)) -}
06f1019be5f98fe39b6b07fcb9a3be0c
  alex_accept14 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept15 @ user)) -}
711a7cc659975cae86835a34ee0c8be9
  alex_accept15 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept16 @ user)) -}
cc55931118401ad0f7a65d4cea59397d
  alex_accept16 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept17 @ user)) -}
5c3e6dd2c2f77d8dba7f732ae00d557b
  alex_accept17 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept18 @ user)) -}
f2c3688fdfb20260976c2a3ba54a78e1
  alex_accept18 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept19 @ user)) -}
5bdf83de97bc890761ae6efe686a50fa
  alex_accept19 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept20 @ user)) -}
d28c0dd5e2461a33bd43e166006e78d4
  alex_accept2 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 49#) -}
9d784e19767c732776bb41d8b2e207d9
  alex_accept20 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept21 @ user)) -}
811b5035fcd548e01b89bab2594ad8c1
  alex_accept21 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept22 @ user)) -}
9925a3a7b646ac021fe0bb656e1df2a1
  alex_accept22 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept23 @ user)) -}
056be23eb59abc5e449af4316c4d8ef8
  alex_accept23 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept24 @ user)) -}
ee547a5b6d1b70f8d7f78baf08a96994
  alex_accept24 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept25 @ user)) -}
9142c55b06d27e98ab4baaa6f719c682
  alex_accept25 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept26 @ user)) -}
8bd4d5119a3ef39c58dc8577e6c928bc
  alex_accept26 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept91 @ user)
                   (Lexer.alex_accept27 @ user)) -}
d32871a4a87530a3dc809eb7f46b63f1
  alex_accept27 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccSkip @ user)
                   (Lexer.alex_accept28 @ user)) -}
92ab689a36af60d5acba23a76160d2e4
  alex_accept28 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccSkip @ user)
                   (Lexer.alex_accept29 @ user)) -}
d0f9243f8cb81d254ecccfae12a749db
  alex_accept29 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccSkip @ user)
                   (Lexer.alex_accept30 @ user)) -}
d7d6b0504f8b27241cafd9e4918eb50e
  alex_accept3 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept4 @ user)) -}
ed1a65bf164d1185ceaae6c8d03bf7fe
  alex_accept30 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccSkip @ user)
                   (Lexer.alex_accept31 @ user)) -}
bc00a1065af4e2b4e425c5a7b3b531a6
  alex_accept31 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccSkip @ user)
                   (Lexer.alex_accept32 @ user)) -}
37454a83408bf19ebf0ed85864d59093
  alex_accept32 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept89 @ user)
                   (Lexer.alex_accept33 @ user)) -}
5e1ed91d4a02d6800b1e3940d6b3bf5b
  alex_accept33 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept87 @ user)
                   (Lexer.alex_accept34 @ user)) -}
83baa035359fa60b35c7933641c5808d
  alex_accept34 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept85 @ user)
                   (Lexer.alex_accept35 @ user)) -}
94d8d9f8cbc3f31a68e920f116eda8cc
  alex_accept35 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept83 @ user)
                   (Lexer.alex_accept36 @ user)) -}
d018b03f10f5c830a630c3f429fcff78
  alex_accept36 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept81 @ user)
                   (Lexer.alex_accept37 @ user)) -}
7202beb5dbe9fff312d5a74df7b892a4
  alex_accept37 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept79 @ user)
                   (Lexer.alex_accept38 @ user)) -}
7297823bb7739f0090d7a389d7da5917
  alex_accept38 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept77 @ user)
                   (Lexer.alex_accept39 @ user)) -}
44c802c5ff35a37412e7de9732447cee
  alex_accept39 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept75 @ user)
                   (Lexer.alex_accept40 @ user)) -}
85ef3d4c7633c564df79606cc931e4b8
  alex_accept4 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept5 @ user)) -}
af6664b71efa9701a4ff5a13ec64d621
  alex_accept40 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept73 @ user)
                   (Lexer.alex_accept41 @ user)) -}
5046e3a1455a6ab858b89961c8817555
  alex_accept41 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept72 @ user)
                   (Lexer.alex_accept42 @ user)) -}
e067c9d1c526ccafdc058fe33a47c791
  alex_accept42 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept70 @ user)
                   (Lexer.alex_accept43 @ user)) -}
e4e59c408b91548a9f7ee3fa873bae65
  alex_accept43 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept68 @ user)
                   (Lexer.alex_accept44 @ user)) -}
de51ebce8363747037fea68ccae9ba52
  alex_accept44 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept67 @ user)
                   (Lexer.alex_accept45 @ user)) -}
2b50180500b41d1ce5193a0b70774423
  alex_accept45 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept65 @ user)
                   (Lexer.alex_accept46 @ user)) -}
3de838c243e9e148f8ab4cd4c9c6be44
  alex_accept46 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept63 @ user)
                   (Lexer.alex_accept47 @ user)) -}
6718058cbbeedbace516e8de748805a7
  alex_accept47 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept61 @ user)
                   (Lexer.alex_accept48 @ user)) -}
4fb253f2d7ec97b0496c771c03b3905a
  alex_accept48 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept59 @ user)
                   (Lexer.alex_accept49 @ user)) -}
370e4fde037bdc633e97f626f4ecd0b1
  alex_accept49 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept57 @ user)
                   (Lexer.alex_accept50 @ user)) -}
67bb930daedf55963ce6b3ff23b705ab
  alex_accept5 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept6 @ user)) -}
d9efe516793b97806d502b68a231d8c9
  alex_accept50 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept55 @ user)
                   (Lexer.alex_accept51 @ user)) -}
5c5bce90fd1f81089a8900e55846320a
  alex_accept51 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept54 @ user)
                   (Lexer.alex_accept52 @ user)) -}
cb601980efa30637f0f14b06b03bec3b
  alex_accept52 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.alex_accept53 @ user)
                   (GHC.Types.[] @ (Lexer.AlexAcc user))) -}
4aa72a2f4f6a939a79c52bd8e55ccca1
  alex_accept53 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user -> Lexer.AlexAcc @ user Lexer.$fShowToken2) -}
2049e04cda1fdd14e699581e8a8e4b73
  alex_accept54 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user -> Lexer.AlexAcc @ user Lexer.lexComment) -}
a56e0135e45b218d2300b2c9dd414ad6
  alex_accept55 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept56) -}
293d667aab30c0d52789a65ea26ac8cb
  alex_accept56 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 2#) -}
3c30a1c8226d9e509ebb392a4ff4b3d3
  alex_accept57 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept58) -}
b107ecfeb28c0766fd8a694906b26817
  alex_accept58 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 3#) -}
868d2f65d40773e36e6c6976594fc8bd
  alex_accept59 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept60) -}
09b75bda47718343376dbec9bc519cae
  alex_accept6 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept7 @ user)) -}
7ed19ed22c449225d453b7ce3f5eaf56
  alex_accept60 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 4#) -}
b8478a35bd1447b74995a46fbc8c451c
  alex_accept61 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept62) -}
21514400c28ba8346d2156fc9c14d313
  alex_accept62 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 5#) -}
15dab902d2035297202305fb9a83fafe
  alex_accept63 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept64) -}
4f6172b78a134366233ff662fc4d3a95
  alex_accept64 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 6#) -}
d35bbb467704506327a00ef4e931d072
  alex_accept65 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept66) -}
e29a61b41f7b723e8026374bf24f28b9
  alex_accept66 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 7#) -}
db57c6a65768c3230d33e34d2c1b4ba8
  alex_accept67 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_tab_size) -}
131442801acb1a009be484be74fd7dcb
  alex_accept68 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept69) -}
b0135a4fd6252278b1281624d9003b8a
  alex_accept69 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 9#) -}
78465ada704c468c49571a6d5d21c97b
  alex_accept7 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept8 @ user)) -}
e15505bb20b343de9a4b80a7aea27332
  alex_accept70 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept71) -}
964f6b9648c085cf22b6e5ebcc100af0
  alex_accept71 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 10#) -}
380d68440e0f6cce6de0b8d0c8ef4f0e
  alex_accept72 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.$fShowAlexResult5) -}
4835aab1fe74006dfd7a293084870bd1
  alex_accept73 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept74) -}
e9cae2e182622446014d22eaafee70b1
  alex_accept74 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 12#) -}
2f9298f14503bf55f0bfbd5779665f06
  alex_accept75 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept76) -}
dd4057da6e8efe4e397f31d4a835b398
  alex_accept76 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 13#) -}
16847454d6a28d9a819c7cc5aa34cbc2
  alex_accept77 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept78) -}
bd7d4283472e86e663c2fe21db3a0ce6
  alex_accept78 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 14#) -}
8f3090ad58c143613881c9b7ccf7fc75
  alex_accept79 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept80) -}
80a00c8e613e18589b99ee8ce50b495f
  alex_accept8 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept9 @ user)) -}
e1b4acd0d4260989d94fa8c23af45bbe
  alex_accept80 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 15#) -}
f2d85969c99679eb09c8b326247a262d
  alex_accept81 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept82) -}
eba67e856251af97f06a4bdfc3da4428
  alex_accept82 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 16#) -}
6ff102e9132e63e351d1f0834282d587
  alex_accept83 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept84) -}
ef4f51a01009b51e70e1afee9c60abae
  alex_accept84 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 17#) -}
cc73c04d17bcac31480b8914794e6f3c
  alex_accept85 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept86) -}
90861aa6e6546b9af387e76645ddb54e
  alex_accept86 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 18#) -}
c6e3388be65164d05e31b10ac49af2a0
  alex_accept87 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept88) -}
8c23fb49065e4a412ae2b83d400dc3ec
  alex_accept88 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 19#) -}
f5c53918cbc8fbf95e023b38e3e92f86
  alex_accept89 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept90) -}
61e705f404324d02b3a2597942f0e7fb
  alex_accept9 :: [Lexer.AlexAcc user]
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 GHC.Types.:
                   @ (Lexer.AlexAcc user)
                   (Lexer.AlexAccNone @ user)
                   (Lexer.alex_accept10 @ user)) -}
9a7c3f777ff40dfdf92e43c49cfd37d3
  alex_accept90 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 20#) -}
f54e09f2ba46e3f201563f5095a1ca8f
  alex_accept91 :: Lexer.AlexAcc user
  {- HasNoCafRefs,
     Unfolding: (\ @ user ->
                 Lexer.AlexAcc @ user Lexer.alex_accept92) -}
58992feb37ee4c2ec14c384178e5bf7d
  alex_accept92 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 21#) -}
6ccf145a17a734d5164be93a74e1da73
  alex_action_0 :: Lexer.Action
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>m,
     Unfolding: InlineRule (3, True, True)
                (\ (s :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (ds :: Lexer.AlexState) ->
                 Lexer.AR
                   (GHC.Base.Nothing @ Lexer.Token)
                   Lexer.NoLoc
                   Lexer.$fShowToken2) -}
f3c7d69fd1c1ccdb713dddee56293458
  alex_action_1 :: GHC.Types.Int
  {- Strictness: x -}
ebe2cf4b2b863962b87b05fd121f4a54
  alex_action_10 :: Lexer.Action
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (st :: Lexer.AlexState) ->
                 Lexer.AR (GHC.Base.Just @ Lexer.Token Lexer.LParen) l st) -}
90c4ada6bffd353eaf5cf42a143dc11c
  alex_action_11 :: Lexer.Action
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (st :: Lexer.AlexState) ->
                 Lexer.AR (GHC.Base.Just @ Lexer.Token Lexer.RParen) l st) -}
3be3c0af63786a8c2cb4e4aa72fed439
  alex_action_12 :: Lexer.Action
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (st :: Lexer.AlexState) ->
                 Lexer.AR (GHC.Base.Just @ Lexer.Token Lexer.Semic) l st) -}
749045fe87a32904ec6b448813215893
  alex_action_13 :: Lexer.Action
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (st :: Lexer.AlexState) ->
                 Lexer.AR (GHC.Base.Just @ Lexer.Token Lexer.Equal) l st) -}
9b041e0a745b5644d11d9369b73e400d
  alex_action_14 :: Lexer.Action
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (st :: Lexer.AlexState) ->
                 Lexer.AR (GHC.Base.Just @ Lexer.Token Lexer.Pipe) l st) -}
4c16b9610c928d8d92d829111c4fdbff
  alex_action_15 :: Lexer.Action
  {- Arity: 3, Strictness: <L,1*U><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (s :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (st :: Lexer.AlexState) ->
                 Lexer.AR
                   (GHC.Base.Just @ Lexer.Token (Lexer.Bin (Lexer.checkBin s)))
                   l
                   st) -}
df771bb67c8c4468dfdb671d042c3e73
  alex_action_16 :: Lexer.Action
  {- Arity: 3, Strictness: <L,1*U><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (s :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (st :: Lexer.AlexState) ->
                 Lexer.AR
                   (GHC.Base.Just @ Lexer.Token (Lexer.Hex (Lexer.checkHex s)))
                   l
                   st) -}
1650ba81f595cc2d5c37618465e205df
  alex_action_17 :: Lexer.Action
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (s :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (st :: Lexer.AlexState) ->
                 Lexer.AR (GHC.Base.Just @ Lexer.Token (Lexer.Sym s)) l st) -}
0ee165fb7e1ef791b5e71e2f2ea9137e
  alex_action_18 :: Lexer.Action
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (s :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (st :: Lexer.AlexState) ->
                 Lexer.AR (GHC.Base.Just @ Lexer.Token (Lexer.Low s)) l st) -}
71031cd0e609132daf5df02db2ac1bc8
  alex_action_19 :: Lexer.Action
  {- Arity: 3, HasNoCafRefs, Strictness: <L,U><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (s :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (st :: Lexer.AlexState) ->
                 Lexer.AR (GHC.Base.Just @ Lexer.Token (Lexer.Upp s)) l st) -}
c79c559de3bb8c3f045f5fe94984253c
  alex_action_2 :: GHC.Types.Int
  {- Strictness: x -}
aad2a8e94b88a439cd65ee84ee940635
  alex_action_20 :: Lexer.Action
  {- Arity: 3, Strictness: <L,U><L,U><L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Base.String)
                   (w1 :: Lexer.SrcLoc)
                   (w2 :: Lexer.AlexState) ->
                 Lexer.AR
                   (GHC.Base.Just
                      @ Lexer.Token
                      (Lexer.Dec
                         (case Text.Read.readEither6
                                 @ GHC.Types.Int
                                 (Text.ParserCombinators.ReadP.run
                                    @ GHC.Types.Int
                                    Lexer.alex_action_3
                                    w) of wild {
                            [] -> Lexer.alex_action_2
                            : x ds
                            -> case ds of wild1 {
                                 [] -> x : ipv ipv1 -> Lexer.alex_action_1 } })))
                   w1
                   w2) -}
64012627d7308eebf3641cfeb6c9a99d
  alex_action_3 :: Text.ParserCombinators.ReadP.P GHC.Types.Int
  {- Unfolding: (GHC.Read.$fReadInt3
                   GHC.Read.$fReadInt_$sconvertInt
                   Text.ParserCombinators.ReadPrec.minPrec
                   @ GHC.Types.Int
                   (Text.Read.readEither5 @ GHC.Types.Int)) -}
0c5984e1470f3148c5f6cad1f5e3dd01
  alex_action_4 :: GHC.Types.Int
  {- Unfolding: (Lexer.lexComment) -}
98cf8bdc545592d1edf147cfd94a86ad
  alex_action_5 :: Lexer.Action
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,A><L,A>m,
     Unfolding: InlineRule (3, True, True)
                (\ (s :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (ds :: Lexer.AlexState) ->
                 Lexer.AR
                   (GHC.Base.Nothing @ Lexer.Token)
                   Lexer.NoLoc
                   Lexer.alex_action_4) -}
162225b83db3fabe082f161620dd50e2
  alex_action_6 :: Lexer.Action
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (st :: Lexer.AlexState) ->
                 Lexer.AR (GHC.Base.Just @ Lexer.Token Lexer.Colon) l st) -}
571009a405668e96b7c7a70a5d0b79f5
  alex_action_7 :: Lexer.Action
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (st :: Lexer.AlexState) ->
                 Lexer.AR (GHC.Base.Just @ Lexer.Token Lexer.TwoColons) l st) -}
aa37491ca34da86252d9e5e53ab465d9
  alex_action_8 :: Lexer.Action
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (st :: Lexer.AlexState) ->
                 Lexer.AR (GHC.Base.Just @ Lexer.Token Lexer.Arrow) l st) -}
c638c34f5e95cf007adbecfd3381a81b
  alex_action_9 :: Lexer.Action
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><L,U><L,U>m,
     Unfolding: InlineRule (3, True, False)
                (\ (ds :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (st :: Lexer.AlexState) ->
                 Lexer.AR (GHC.Base.Just @ Lexer.Token Lexer.Data) l st) -}
3526af2a8c3db2d767cf4714a9e01d71
  alex_actions :: GHC.Arr.Array GHC.Types.Int Lexer.Action
  {- Unfolding: (case GHC.Magic.runRW#
                        @ 'GHC.Types.PtrRepLifted
                        @ (GHC.Arr.Array GHC.Types.Int Lexer.Action)
                        Lexer.alex_actions1 of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
45fa1e658a3535d7b13f991ceb15af52
  alex_actions1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Arr.Array GHC.Types.Int Lexer.Action #)
  {- Arity: 1,
     Unfolding: (\ (s1# :: GHC.Prim.State#
                             GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.Prim.newArray#
                        @ Lexer.Action
                        @ GHC.Prim.RealWorld
                        23#
                        (GHC.Arr.arrEleBottom @ Lexer.Action)
                        s1# of ds1 { (#,#) ipv ipv1 ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        21#
                        Lexer.alex_action_0
                        ipv of s2# { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        20#
                        Lexer.alex_action_5
                        s2# of s2#1 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        19#
                        Lexer.alex_action_6
                        s2#1 of s2#2 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        18#
                        Lexer.alex_action_7
                        s2#2 of s2#3 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        17#
                        Lexer.alex_action_8
                        s2#3 of s2#4 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        16#
                        Lexer.alex_action_9
                        s2#4 of s2#5 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        15#
                        Lexer.alex_action_10
                        s2#5 of s2#6 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        14#
                        Lexer.alex_action_11
                        s2#6 of s2#7 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        13#
                        Lexer.alex_action_12
                        s2#7 of s2#8 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        12#
                        Lexer.alex_action_13
                        s2#8 of s2#9 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        11#
                        Lexer.alex_action_14
                        s2#9 of s2#10 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        10#
                        Lexer.alex_action_15
                        s2#10 of s2#11 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        9#
                        Lexer.alex_action_16
                        s2#11 of s2#12 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        8#
                        Lexer.alex_action_17
                        s2#12 of s2#13 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        7#
                        Lexer.alex_action_17
                        s2#13 of s2#14 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        6#
                        Lexer.alex_action_18
                        s2#14 of s2#15 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        5#
                        Lexer.alex_action_18
                        s2#15 of s2#16 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        4#
                        Lexer.alex_action_18
                        s2#16 of s2#17 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        3#
                        Lexer.alex_action_18
                        s2#17 of s2#18 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        2#
                        Lexer.alex_action_19
                        s2#18 of s2#19 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        1#
                        Lexer.alex_action_20
                        s2#19 of s2#20 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        0#
                        Lexer.alex_action_20
                        s2#20 of s2#21 { DEFAULT ->
                 case GHC.Prim.unsafeFreezeArray#
                        @ GHC.Prim.RealWorld
                        @ Lexer.Action
                        ipv1
                        s2#21 of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2,
                    GHC.Arr.Array
                      @ GHC.Types.Int
                      @ Lexer.Action
                      Lexer.$fShowToken2
                      Lexer.alex_actions_u
                      23#
                      ipv3 #) } } } } } } } } } } } } } } } } } } } } } } } }) -}
d96ff1dea6122a0bf35b4573e252945f
  alex_actions_u :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 22#) -}
7aa90a7af41abd2d14cfe7b658534c08
  alex_base :: Lexer.AlexAddr
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Lexer.AlexA#
                   "\\248\\255\\255\\255\\247\\255\\255\\255\\217\\255\\255\\255w\NUL\NUL\NUL\\247\NUL\NUL\NULw\SOH\NUL\NUL\\232\SOH\NUL\NUL\NUL\NUL\NUL\NULh\STX\NUL\NUL\NUL\NUL\NUL\NUL\\217\STX\NUL\NUL\NUL\NUL\NUL\NUL\SUB\ETX\NUL\NUL\NUL\NUL\NUL\NUL[\ETX\NUL\NUL+\EOT\NUL\NULv\EOT\NUL\NUL\\241\EOT\NUL\NUL\\177\EOT\NUL\NUL\NUL\NUL\NUL\NUL\\177\ENQ\NUL\NULq\ENQ\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\\138\\255\\255\\255\NUL\NUL\NUL\NUL\\255\\255\\255\\255h\ACK\NUL\NULl\ACK\NUL\NUL\NUL\NUL\NUL\NULV\ACK\NUL\NULK\a\NUL\NULn\a\NUL\NUL\\140\a\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\\230\a\NUL\NUL\t\b\NUL\NUL'\b\NUL\NULr\b\NUL\NUL\\204\b\NUL\NUL\\239\b\NUL\NUL\r\t\NUL\NULa\t\NUL\NUL\\181\t\NUL\NUL\t\n\
                   \\NUL\NUL]\n\
                   \\NUL\NUL\\221\\255\\255\\255g\ACK\NUL\NUL"#) -}
bc92ec1e00834c199c2fbced877f23e2
  alex_check :: Lexer.AlexAddr
  {- HasNoCafRefs, Strictness: m -}
a791df6dd2e09b1ee677ebf29e552eb0
  alex_deflt :: Lexer.AlexAddr
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (Lexer.AlexA#
                   "\\255\\255\EM\NUL\\255\\255\\255\\255\\255\\255\\255\\255\v\NUL\v\NUL\\255\\255\r\NUL\r\NUL\DC3\NUL\DC3\NUL\SYN\NUL\SYN\NUL\\255\\255\\255\\255\FS\NUL\FS\NUL\FS\NUL\EM\NUL\EM\NUL\EM\NUL\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\FS\NUL\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255\\255"#) -}
c5388a6138152f1e20ab160674848d16
  alex_scan_tkn ::
    t1
    -> t
    -> GHC.Prim.Int#
    -> Lexer.AlexInput
    -> GHC.Prim.Int#
    -> Lexer.AlexLastAcc
    -> (Lexer.AlexLastAcc, Lexer.AlexInput)
  {- Arity: 6,
     Strictness: <L,A><L,A><L,U><S(LS(LSL)L),1*U(U,U(U,U,U),U)><S,U><L,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (6, True, False)
                (\ @ t
                   @ t1
                   (w :: t1)
                   (w1 :: t)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: Lexer.AlexInput)
                   (w4 :: GHC.Prim.Int#)
                   (w5 :: Lexer.AlexLastAcc) ->
                 case w3 of ww { Lexer.AI ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lexer.Buf ww5 ww6 ww7 ->
                 case Lexer.$walex_scan_tkn
                        @ t
                        @ t1
                        w2
                        ww1
                        ww5
                        ww6
                        ww7
                        ww3
                        w4
                        w5 of ww8 { (#,#) ww9 ww10 ->
                 (ww9, ww10) } } }) -}
706541889e0370a3c465acefaa0912b3
  alex_tab_size :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 8#) -}
492740265c75373598c80eeb368aa739
  alex_table :: Lexer.AlexAddr
  {- HasNoCafRefs, Strictness: m -}
c5e0d83f1eb0b0c62ad23712805e5b6a
  catchEither :: Data.Either.Either GHC.Base.String a -> a
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (e :: Data.Either.Either GHC.Base.String a) ->
                 case e of wild {
                   Data.Either.Left err -> Lexer.catchEither1 @ a err
                   Data.Either.Right res -> res }) -}
8cb4c1672359a82fca3b83f52f93968c
  catchEither1 :: GHC.Base.String -> a
  {- Arity: 1, Strictness: <B,U>x -}
231858b4c630ae0036ba95e61f1a1993
  changeState :: GHC.Types.Int -> Lexer.Action
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,A><L,A><L,A>m,
     Unfolding: InlineRule (4, True, True)
                (\ (newState :: GHC.Types.Int)
                   (s :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (ds :: Lexer.AlexState) ->
                 Lexer.AR (GHC.Base.Nothing @ Lexer.Token) Lexer.NoLoc newState) -}
0dd1c19e6df4ce46c1aebc63e9f89128
  changeStateAndOutput ::
    GHC.Types.Int -> (GHC.Base.String -> Lexer.Token) -> Lexer.Action
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U><L,1*C1(U)><L,U><L,U><L,A>m,
     Unfolding: InlineRule (5, True, False)
                (\ (newState :: GHC.Types.Int)
                   (tf :: GHC.Base.String -> Lexer.Token)
                   (s :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (ds :: Lexer.AlexState) ->
                 Lexer.AR (GHC.Base.Just @ Lexer.Token (tf s)) l newState) -}
0837b01ae3b04b31dbc8d0bc0c17eaa7
  checkBin :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 let {
                   num :: [GHC.Types.Char]
                   = GHC.Base.map
                       @ GHC.Types.Char
                       @ GHC.Types.Char
                       GHC.Unicode.toLower
                       (Lexer.$wunsafeDrop1 @ GHC.Types.Char 2# s)
                 } in
                 case (Lexer.checkBin_go num)
                        `cast`
                      (Data.Monoid.N:All[0]) of wild {
                   GHC.Types.False -> Lexer.checkBin1 GHC.Types.True -> num }) -}
70662291cf8ecd9e68033937a1fb4332
  checkBin1 :: [GHC.Types.Char]
  {- Strictness: x -}
f60d9c8181f881dec0784b210fb26ade
  checkBin_go :: [GHC.Types.Char] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
44967b9eb062686eec67d1d6d144f98a
  checkHex :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (s :: GHC.Base.String) ->
                 let {
                   num :: [GHC.Types.Char]
                   = GHC.Base.map
                       @ GHC.Types.Char
                       @ GHC.Types.Char
                       GHC.Unicode.toLower
                       (Lexer.$wunsafeDrop @ GHC.Types.Char 2# s)
                 } in
                 case (Lexer.checkHex_go num)
                        `cast`
                      (Data.Monoid.N:All[0]) of wild {
                   GHC.Types.False -> Lexer.checkHex1 GHC.Types.True -> num }) -}
740438d05ceae4b5cf6d4c34df9ccb6e
  checkHex1 :: [GHC.Types.Char]
  {- Strictness: x -}
e94c7268d104ab2738e664eacbf2eb26
  checkHex_go :: [GHC.Types.Char] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
cf7504a00cb5ac1e6df13cebd2b96663
  consLoc :: Lexer.Token -> Lexer.Action
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,A><L,U><L,U>m,
     Unfolding: InlineRule (4, True, False)
                (\ (t :: Lexer.Token)
                   (ds :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (st :: Lexer.AlexState) ->
                 Lexer.AR (GHC.Base.Just @ Lexer.Token t) l st) -}
9c17cb7df6c195a28083ae22a701d360
  errorT :: GHC.Base.String -> Lexer.T a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m1,
     Unfolding: InlineRule (0, True, True)
                Lexer.errorT1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Base.String>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Lexer.AlexInput>_N
                               <Data.Either.Either GHC.Base.String>_R
                               <a>_N)) -}
a03f37a25788636ec928303eae8cf517
  errorT1 ::
    GHC.Base.String
    -> Lexer.AlexInput
    -> Data.Either.Either GHC.Base.String (a, Lexer.AlexInput)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m1,
     Unfolding: InlineRule (2, True, True)
                (\ @ a (err :: GHC.Base.String) (s :: Lexer.AlexInput) ->
                 Data.Either.Left @ GHC.Base.String @ (a, Lexer.AlexInput) err) -}
29ec51a6bd3a2ae64e3711c855be4d7d
  funLoc :: (GHC.Base.String -> Lexer.Token) -> Lexer.Action
  {- Arity: 4, HasNoCafRefs, Strictness: <L,1*C1(U)><L,U><L,U><L,U>m,
     Unfolding: InlineRule (4, True, False)
                (\ (tf :: GHC.Base.String -> Lexer.Token)
                   (s :: GHC.Base.String)
                   (l :: Lexer.SrcLoc)
                   (st :: Lexer.AlexState) ->
                 Lexer.AR (GHC.Base.Just @ Lexer.Token (tf s)) l st) -}
c09cfb8cb6714d1074b1fe1128cff8a0
  getBytes :: Lexer.Buffer -> Lexer.Bytes
  RecSel Left Lexer.Buffer
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lexer.Buffer) ->
                 case ds of wild { Lexer.Buf ds1 ds2 ds3 -> ds2 }) -}
09a79ed036326baf711de38c66d809b8
  getLoc :: Lexer.L a -> Lexer.SrcLoc
  RecSel Left Lexer.L
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Lexer.L a) ->
                 case ds of wild { Lexer.L ds1 ds2 -> ds1 }) -}
c866b57dafc4892e4c538a62c5e39890
  getPrevious :: Lexer.Buffer -> GHC.Types.Char
  RecSel Left Lexer.Buffer
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLL),1*U(1*U(U),A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lexer.Buffer) ->
                 case ds of wild { Lexer.Buf ds1 ds2 ds3 -> ds1 }) -}
e4c3d6e0dc62072a97c89eac03980f96
  getString :: Lexer.Buffer -> GHC.Base.String
  RecSel Left Lexer.Buffer
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLS),1*U(A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Lexer.Buffer) ->
                 case ds of wild { Lexer.Buf ds1 ds2 ds3 -> ds3 }) -}
569eb0fca1fc7d6ce36599b9fd57c1ac
  getVal :: Lexer.L a -> a
  RecSel Left Lexer.L
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: Lexer.L a) ->
                 case ds of wild { Lexer.L ds1 ds2 -> ds2 }) -}
5baf98cffc0fda34d20987c3839909e8
  lexComment :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 1#) -}
62616eac986c5ac87fd97ec153b18ac0
  nextSrcLoc :: Lexer.SrcLoc -> GHC.Types.Char -> Lexer.SrcLoc
  {- Arity: 2, Strictness: <S,1*U><S(S),1*U(1*U)>m1,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Lexer.SrcLoc) (w1 :: GHC.Types.Char) ->
                 case w1 of ww { GHC.Types.C# ww1 ->
                 case w of wild {
                   Lexer.SrcLoc f dt dt1
                   -> case ww1 of ds {
                        DEFAULT -> Lexer.SrcLoc f dt (GHC.Prim.+# dt1 1#)
                        '\t'#
                        -> Lexer.SrcLoc
                             f
                             dt
                             (GHC.Prim.+#
                                (GHC.Prim.uncheckedIShiftL#
                                   (GHC.Prim.+#
                                      (GHC.Prim.uncheckedIShiftRA# (GHC.Prim.-# dt1 1#) 3#)
                                      1#)
                                   3#)
                                1#)
                        '\n'# -> Lexer.SrcLoc f (GHC.Prim.+# dt 1#) 1# }
                   Lexer.NoLoc -> Lexer.nextSrcLoc1 } }) -}
01bce569ddf0943ba9af20ac7a9dcbdd
  nextSrcLoc1 :: Lexer.SrcLoc
  {- Strictness: x -}
8b7cdd9b4999edd70691e5c86f351941
  quickIndex ::
    GHC.Arr.Array GHC.Types.Int (Lexer.AlexAcc GHC.Prim.Any)
    -> GHC.Types.Int -> Lexer.AlexAcc GHC.Prim.Any
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LLLS),1*U(A,A,A,U)><S(S),1*U(U)>,
     Unfolding: InlineRule (0, True, True)
                (GHC.Arr.unsafeAt
                   @ GHC.Types.Int
                   @ (Lexer.AlexAcc GHC.Prim.Any)) -}
ecff78d45cab2b72973a19b58fe3c210
  readToken :: Lexer.T Lexer.LToken
  {- Arity: 1, Strictness: <S(LS(LSL)S(S)),1*U(U,U(U,U,U),U(U))>,
     Unfolding: InlineRule (0, True, True)
                Lexer.readToken1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <Lexer.AlexInput>_N
                          <Data.Either.Either GHC.Base.String>_R
                          <Lexer.LToken>_N)) -}
bde6a6aa99e03ddef9fc22bff0ae6a53
  readToken1 ::
    Lexer.AlexInput
    -> Data.Either.Either
         GHC.Base.String (Lexer.LToken, Lexer.AlexInput)
  {- Arity: 1, Strictness: <S(LS(LSL)S(S)),1*U(U,U(U,U,U),U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Lexer.AlexInput) ->
                 case w of ww { Lexer.AI ww1 ww2 ww3 ->
                 case ww2 of ww4 { Lexer.Buf ww5 ww6 ww7 ->
                 case ww3 of ww8 { GHC.Types.I# ww9 ->
                 Lexer.$wreadToken ww1 ww5 ww6 ww7 ww9 } } }) -}
1b77ba3662f22af49dfeca35784d51c9
  runT :: Lexer.T a -> GHC.Base.String -> a
  {- Arity: 2, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (p :: Lexer.T a) (eta :: GHC.Base.String) ->
                 case p `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <Lexer.AlexInput>_N <Data.Either.Either GHC.Base.String>_R <a>_N)
                        (Lexer.AI
                           Lexer.runT2
                           (Lexer.Buf Lexer.runT1 (GHC.Types.[] @ Lexer.Byte) eta)
                           Lexer.$fShowToken2) of wild {
                   Data.Either.Left l -> Lexer.catchEither1 @ a l
                   Data.Either.Right r -> case r of wild1 { (,) a1 ds1 -> a1 } }) -}
676d5757abf610cc0ccbbd270cd6d9eb
  runT1 :: GHC.Types.Char
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.C# '\n'#) -}
cde011e7f3091aadcf39d01916d217b3
  runT2 :: Lexer.SrcLoc
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Lexer.SrcLoc (GHC.Types.[] @ GHC.Types.Char) 1# 1#) -}
ad58bbc19f781a4855be2a77c79ebe30
  runTWithoutError ::
    Lexer.T a
    -> GHC.Base.String -> Data.Either.Either GHC.Base.String a
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (p :: Lexer.T a) (str :: GHC.Base.String) ->
                 case p `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <Lexer.AlexInput>_N <Data.Either.Either GHC.Base.String>_R <a>_N)
                        (Lexer.AI
                           Lexer.runT2
                           (Lexer.Buf Lexer.runT1 (GHC.Types.[] @ Lexer.Byte) str)
                           Lexer.$fShowToken2) of wild {
                   Data.Either.Left l -> Data.Either.Left @ [GHC.Types.Char] @ a l
                   Data.Either.Right r
                   -> Data.Either.Right
                        @ [GHC.Types.Char]
                        @ a
                        (case r of wild1 { (,) a1 ds1 -> a1 }) }) -}
4839af7e89c32874a5ca68529408bef1
  tokenize :: GHC.Base.String -> [Lexer.LToken]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (eta :: GHC.Base.String) ->
                 case Lexer.$wgo
                        (GHC.Types.[] @ (Lexer.L Lexer.Token))
                        Lexer.runT2
                        Lexer.runT1
                        (GHC.Types.[] @ Lexer.Byte)
                        eta
                        0# of wild {
                   Data.Either.Left l -> Lexer.tokenize1 @ [Lexer.LToken] l
                   Data.Either.Right r -> case r of wild1 { (,) a1 ds1 -> a1 } }) -}
e06bff8b5ba239028e7ef2ac7317f6f2
  tokenize1 :: GHC.Base.String -> a
  {- Arity: 1, Strictness: <L,U>x -}
f861b686f9b302d8e20df2565caf484b
  unifyMultilineString :: GHC.Base.String -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: GHC.Base.String) ->
                 GHC.List.reverse1
                   @ GHC.Types.Char
                   (Lexer.unifyMultilineString_go
                      (GHC.Types.[] @ GHC.Types.Char)
                      GHC.Types.False
                      x)
                   (GHC.Types.[] @ GHC.Types.Char)) -}
ef3214bb9d68a82651b2d085cd85e34b
  unifyMultilineString_go ::
    GHC.Base.String
    -> GHC.Types.Bool -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><S,1*U><S,1*U> -}
instance GHC.Classes.Eq [Lexer.SrcLoc] = Lexer.$fEqSrcLoc
instance GHC.Classes.Eq [Lexer.Token] = Lexer.$fEqToken
instance GHC.Base.Functor [Lexer.L] = Lexer.$fFunctorL
instance GHC.Classes.Ord [Lexer.SrcLoc] = Lexer.$fOrdSrcLoc
instance GHC.Show.Show [Lexer.AlexResult] = Lexer.$fShowAlexResult
instance GHC.Show.Show [Lexer.L] = Lexer.$fShowL
instance GHC.Show.Show [Lexer.SrcLoc] = Lexer.$fShowSrcLoc
instance GHC.Show.Show [Lexer.Token] = Lexer.$fShowToken
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

