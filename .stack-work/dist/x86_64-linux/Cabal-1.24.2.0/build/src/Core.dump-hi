
==================== FINAL INTERFACE ====================
2018-06-09 19:11:56.392554 UTC

interface HaskellCircuits-0.1.0.0-3mIW93ol3alH6nhlDJ7Hzo:Core 8002
  interface hash: ae994227e937c44bea3cb533ba1488da
  ABI hash: 03c045ec4b103f009edcb2fde995889a
  export-list hash: 2b088c47911ca173a5aab6906552164b
  orphan hash: 5de641fba868dce44c7b9b179084f248
  flag hash: 91cd76246f60d900fce8e309e594df82
  sig of: Nothing
  used TH splices: False
  where
exports:
  Core.andExpr
  Core.concatExpr
  Core.concatGuards
  Core.destroy
  Core.destroyPats
  Core.df
  Core.dropFunctionDef
  Core.fixedFunctions
  Core.funcName
  Core.gatherFunctions
  Core.getName
  Core.glueFunctions
  Core.isData
  Core.isFixed
  Core.isNumFunc
  Core.isPAExpr
  Core.isRecursiveData
  Core.isSameFunc
  Core.makeExpr
  Core.noLoc
  Core.noLocDec
  Core.noLocLow
  Core.noLocUpp
  Core.putDataDefsInState
  Core.putFunctionTypesInState
  Core.replaceBy
  Core.storeCoreInState
  Core.storeDataInState
  Core.substExpr
  Core.substFunctions
  Core.substIntFixed
  Core.takeFunctionDef
  Core.toCFTy
  Core.toCFTy'
  Core.toCore
  Core.trueCond
  Core.typeCheck
  Core.typeCheck'
  Core.typeCheckEach
  Core.varsFromPats
module dependencies: Aux Lexer Parser TransformationMonad Types
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      transformers-0.5.2.0@transformers-0.5.2.0
                      utf8-string-1.0.1.1@utf8-string-1.0.1.1-1DpjxLeTvGg7ttZZojxJR5
orphans: HaskellCircuits-0.1.0.0-3mIW93ol3alH6nhlDJ7Hzo:Parser
         base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
import  -/  Aux 19066227c591c3746fddc67fa02fb706
  exports: 3c8f8ea3f0430e062a77584d5651b09f
  both c5190165eceb2be382c42c00d04b3bf2
  for 107006115f446d6f8efc30b27b249087
  mok 0adafff0b584d92b2b919079497c3e70
import  -/  Lexer c6174f684585218aa184faedf4ab7f58
  exports: c0fea5fa50c83f412bfcd8243e0a6172
  Bin 1f25e29df2873757e51103aa7c29951d
  Dec 8b0f2277218f753a903427d84acf225f
  Hex 48ae9fca0c791aa2ab7be7a483770cf8
  L aeabd488767cc0257d48246b31a3c8eb
  LToken fd141e29e5214152a04ab8dbc6cb5857
  Low a60819b3a41da7c3fbdecdba34a169db
  NoLoc 1192b825a1bbdd5c089dbb8aeba295bc
  SrcLoc a30eee500ffeed73c76202d9a53d2902
  Upp 894a86340c775c101c75dc2b77ce46e2
  getLoc 09a79ed036326baf711de38c66d809b8
  getVal 569eb0fca1fc7d6ce36599b9fd57c1ac
import  -/  Parser f25442964b616089abfc3d7b05acabc3
  exports: 518f87c40b39394a3af3d07ea4f63fc3
  ConsPat 86ce9511e30933d88ea328dc1f176d21
  P2Result eec0b135101c4ca4ce6d35445a836756
  P2Result 3f8bebefee360831a01c29169be3d601
  PAExpr e7e97261e2121857a03e90e772b3effe
  PApp d6c8e6df7dfe8ed9d18edbdf7b717607
  PConstr 1e38ee104fa95ab8bbf9538f833f7b99
  PDataType 9548acdf3595399c92b19bba65b582d7
  PDecl 8a4e025f1345a013269fcf3344482c9d
  PExpr 1b1c5a1d1f9ac4cca7f01f2fa0906802
  PFType 51a6638646156923516f39d2a769e2ed
  PFType 88be636705ee31796543d17c44532d43
  PFunc 1426ac53202d7798afe85a7af3ceb257
  PGuards a437a71c4a638a2f39b9c36fa453ff10
  PGuards ab0dc2d497ba317170847ccac7a2e7de
  PNoGuards 4281adc11eb2d7da92305fe3864f0f02
  PTAExpr 91f6b9fd9959f84b86f7772b77c8c18d
  PTApp e325a170e4dd8b2f0c68a27b03d04622
  PTArrow c73cf880c1d2a1040aa006bd734f463f
  Pat 96468f17b6394648ef025c8675ac74e4
  Pat 1b7878c2c967f8adf26aa1b34e8a140a
import  -/  TransformationMonad 9a41a082a5198ad8166e58e36aa95114
  exports: a2f2911707e7fb33be1f875278a27f62
  addCFuncType 8ed20ecec98f8f0b49bf2d27c640593e
  addData 8f4c7a67603fabef57711a50bb589d14
  cont 15ef40196d547ee7c1c037a71afb7acd
  cont1 863999094999483849ffafa9f0237d73
  cont2 4c4faac896508b22afecd9aa4fb01dbf
  cont_ eeaa22547872c98097fe900855fef26c
  debug f46f4739191d885fb6b73c306966ed95
  debugs 49755239830dc452d4e4b0a31d3ed2f3
  getCore 21daede51fb79e659b4e46f69a8ed81a
  getDataDecls 3d049fd385338ccf03562269b2106ef2
  getIt cea5706c11a76509825eab1a7f4f872a
  getTypeCheckState 9f6d2c40ea84fc6e07a9f87ccf413bd3
  isTypeRecursive 392217388e700cc7d0911caec794fbb3
  modifyTypeCheckState 6d78a97f7a7e3b2b67ecb0b058248b91
  noRet f27a766fc8906feee50ef508c6ef3ff0
  popTypeCheckState 752190041fb14bc403158b3131a2d630
  putTCore 4d3b26ae8230244c0323bb0950777ee4
  putTypeCheckState 008c3803a7b1a36d151f678ab35f8b74
  ret 8f8ddfb5f423bc7b265fdcea5121253c
  searchCFuncType b2983a43f90db815a4fe20763340de2e
  setCore cda73ea8ca7c82e99078637a27e1a3e1
  throw fd22a7ad31f6177a0a7c3d0b74f70074
import  -/  Types 757470cca10fe0c859acdd7db069deaa
  exports: 34058aae7a6fb4ed664b025b184c161d
  CConstr adef17e1148e8e3c6a827ee9426ed671
  CConstr 406345940f930081e4da3d7c6154c2ec
  CFType 8104f895f8b3e96ad3976476ae2f7330
  CFunc 05de295f7c43a30a2b49b0f9d15c0537
  CFunc 1710acfef62a9879edfeaff433f44f9c
  CGuards 1ba576142e045f9eb45841711b51ba0b
  CGuards 294e122f69eabf0fb6865528d745d6f2
  CNoGuards 82d303280b3be822916d37c81a02734c
  CTAExpr d3b8dc074bbd299cf33cd3d29a5ca0ab
  CTApp 350ec496e570c115280dc3989c163e27
  CTArrow caaffa29e74dbde0c396f789ac81cc28
  CantMatchTypes 62725a59c5e926a5e8a3353899c5e606
  Constraint b52d039eaf4ef6d1a19dae86e8762e00
  Core 9c7c62ec0c604fff9ecbd871a815ad75
  Core 438d7d9868420ea466e01d42ff11e8f8
  Name 4bbc3da5ef1d02db55291a2a33a7c002
  TCAExpr bf65e3832d1491991d50ea07dd13fdc9
  TCApp d56da741ba2c53a35ea56cd630b24940
  TCExpr bc264b66c5f5c83a739a7acdd40704ca
  TCFunc 236ace8089fb950d30f904265d640bff
  TCFunc 12aff70e921393996a769ff39cd06cc8
  TCGuards 35b9a802ae2adc96712065e8c8d0f0ae
  TCGuards 56a436ce47366ace40afb5bf26b6afb6
  TCNoGuards dcd13d5a2f1accf45989980da2998bf5
  TCore fe7322336a92ee2429b6cab0045090f5
  TCore 37b29aaac158f03681018e20b16bb37a
  TErr bd3b322a3f06039eedd1569007f14c0c
  TM f4ba4f96d9f8dffc5235169391939992
  TMM a7c38748359d680c785978249d7123ff
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.Functor 5ab1dc703df5b482e77efb697833ca3c
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:Data.Traversable 556020d7cf3c4a34a774600512918a37
import  -/  base-4.9.1.0:Data.Tuple 7dc4bbb45d2e69c991ffac438beeca11
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
340069e557191edc6ab065ef6623397a
  $s$fEqL :: GHC.Classes.Eq (Lexer.L Lexer.Token)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ (Lexer.L Lexer.Token)
                  Core.$s$fEqL_$s$fEqL_$c==
                  Core.$s$fEqL_$s$fEqL_$c/= -}
50ef6c786abc59dfe9e8f06d74ff3755
  $s$fEqL_$s$fEqL_$c/= ::
    Lexer.L Lexer.Token -> Lexer.L Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS),1*U(A,1*U)><S(LS),1*U(A,1*U)>,
     Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: Lexer.L Lexer.Token) (y :: Lexer.L Lexer.Token) ->
                 GHC.Classes.not (Core.$s$fEqL_$s$fEqL_$c== x y)) -}
34e1ee6b18fad6a0b24ae22204dd4511
  $s$fEqL_$s$fEqL_$c== ::
    Lexer.L Lexer.Token -> Lexer.L Lexer.Token -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LS),1*U(A,1*U)><S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Lexer.L Lexer.Token) (ds1 :: Lexer.L Lexer.Token) ->
                 case ds of wild { Lexer.L ds2 x ->
                 case ds1 of wild1 { Lexer.L ds3 y ->
                 Lexer.$fEqToken_$c== x y } }) -}
57daf0b397a760e753b025132cbfcd76
  $s$fShow(,)_$s$fShow(,)_$cshowList1 ::
    [([GHC.Types.Char], [GHC.Types.Char])] -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: [([GHC.Types.Char], [GHC.Types.Char])])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ ([GHC.Types.Char], [GHC.Types.Char])
                   (GHC.Show.$fShow(,)_$cshowsPrec
                      @ [GHC.Types.Char]
                      @ [GHC.Types.Char]
                      GHC.Show.$fShow[]_$s$fShow[]1
                      GHC.Show.$fShow[]_$s$fShow[]1
                      GHC.Show.shows22)
                   eta
                   eta1) -}
77fade516d03a46cfb61d79df08ffaf7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Core.$trModule2 Core.$trModule1) -}
ca34497da7d049c2d9c15141f2a93f06
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Core"#) -}
c3fa86f0db4995c98d4e9507cde3984c
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "HaskellCircuits-0.1.0.0-3mIW93ol3alH6nhlDJ7Hzo"#) -}
566aa506e3f2f5a872df23fdcbd6b2f3
  $wconcatExpr ::
    Types.Name
    -> Parser.PExpr
    -> GHC.Types.Int
    -> (# Lexer.LToken, [Parser.PExpr] #)
  {- Arity: 3, HasNoCafRefs, Strictness: <L,1*U><L,U><L,1*U(U)>,
     Inline: [0],
     Unfolding: (\ (w :: Types.Name)
                   (w1 :: Parser.PExpr)
                   (ww :: GHC.Types.Int) ->
                 (# Lexer.L
                      @ Lexer.Token
                      Lexer.NoLoc
                      (Lexer.Low
                         (GHC.CString.unpackAppendCString#
                            "__get__"#
                            (GHC.Base.++
                               @ GHC.Types.Char
                               w
                               (GHC.CString.unpackAppendCString#
                                  "__"#
                                  (case ww of ww2 { GHC.Types.I# ww3 ->
                                   case GHC.Show.$wshowSignedInt
                                          0#
                                          ww3
                                          (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                                   GHC.Types.: @ GHC.Types.Char ww5 ww6 } }))))),
                    GHC.Types.: @ Parser.PExpr w1 (GHC.Types.[] @ Parser.PExpr) #)) -}
c8eb16a89b510fcb6fab4cf05365bf66
  $wdf ::
    Types.Name
    -> Parser.PExpr
    -> Parser.PGuards
    -> (# [(Parser.PExpr, Parser.PExpr)] #)
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Types.Name)
                   (ww1 :: Parser.PExpr)
                   (w :: Parser.PGuards) ->
                 let {
                   cond :: [GHC.Types.Char]
                   = GHC.CString.unpackAppendCString# "__is__"# ww
                 } in
                 let {
                   cond1 :: Lexer.Token = Lexer.Low cond
                 } in
                 let {
                   cond2 :: Lexer.L Lexer.Token {- Strictness: m -}
                   = Lexer.L @ Lexer.Token Lexer.NoLoc cond1
                 } in
                 let {
                   cond3 :: [Parser.PExpr]
                   = GHC.Types.: @ Parser.PExpr ww1 (GHC.Types.[] @ Parser.PExpr)
                 } in
                 let {
                   cond4 :: Parser.PExpr = Parser.PApp cond2 cond3
                 } in
                 case w of wild {
                   Parser.PNoGuards expr
                   -> (# GHC.Types.:
                           @ (Parser.PExpr, Parser.PExpr)
                           (cond4, expr)
                           (GHC.Types.[] @ (Parser.PExpr, Parser.PExpr)) #)
                   Parser.PGuards ces
                   -> (# GHC.Base.map
                           @ (Parser.PExpr, Parser.PExpr)
                           @ (Parser.PExpr, Parser.PExpr)
                           (\ (ds :: (Parser.PExpr, Parser.PExpr)) ->
                            case ds of wild1 { (,) c e ->
                            (Parser.PApp
                               Core.andExpr1
                               (GHC.Types.:
                                  @ Parser.PExpr
                                  cond4
                                  (GHC.Types.: @ Parser.PExpr c (GHC.Types.[] @ Parser.PExpr))),
                             e) })
                           ces #) }) -}
32c1f334b1b665f4fef531f616ed2191
  $wgatherFunctions ::
    [Parser.PDecl]
    -> Types.TMM
         [(Types.Name, Parser.PFType, [Types.Name], Parser.PGuards)]
  {- Arity: 1, Strictness: <L,1*U>, Inline: [0],
     Unfolding: (\ (ww :: [Parser.PDecl]) ->
                 let {
                   m1 :: Control.Monad.Trans.State.Lazy.StateT
                           Types.TState
                           Data.Functor.Identity.Identity
                           [(Types.Name, Parser.PFType, [([Parser.Pat], Parser.PGuards)])]
                   = Core.glueFunctions
                       (GHC.List.filter @ Parser.PDecl Core.gatherFunctions1 ww)
                 } in
                 (\ (s1 :: Types.TState) ->
                  let {
                    ds :: Data.Functor.Identity.Identity
                            ([(Types.Name, Parser.PFType, [([Parser.Pat], Parser.PGuards)])],
                             Types.TState)
                    = m1
                        `cast`
                      (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <Types.TState>_N
                           <Data.Functor.Identity.Identity>_R
                           <[(Types.Name, Parser.PFType,
                              [([Parser.Pat], Parser.PGuards)])]>_N)
                        s1
                  } in
                  (GHC.Base.Just
                     @ [(Types.Name, Parser.PFType, [Types.Name], Parser.PGuards)]
                     (case ds
                             `cast`
                           (Data.Functor.Identity.N:Identity[0]
                                <([(Types.Name, Parser.PFType, [([Parser.Pat], Parser.PGuards)])],
                                  Types.TState)>_R) of wild { (,) a1 s' ->
                      GHC.Base.map
                        @ (Types.Name, Parser.PFType, [([Parser.Pat], Parser.PGuards)])
                        @ (Types.Name, Parser.PFType, [Types.Name], Parser.PGuards)
                        (Core.gatherFunctions_patternsToGuards @ Types.Name)
                        a1 }),
                   case ds
                          `cast`
                        (Data.Functor.Identity.N:Identity[0]
                             <([(Types.Name, Parser.PFType, [([Parser.Pat], Parser.PGuards)])],
                               Types.TState)>_R) of wild { (,) a1 s' ->
                   s' })
                    `cast`
                  (Sym (Data.Functor.Identity.N:Identity[0]
                            <(GHC.Base.Maybe
                                [(Types.Name, Parser.PFType, [Types.Name], Parser.PGuards)],
                              Types.TState)>_R)))
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <Types.TState>_N
                           <Data.Functor.Identity.Identity>_R
                           <GHC.Base.Maybe
                              [(Types.Name, Parser.PFType, [Types.Name],
                                Parser.PGuards)]>_N))) -}
8c4a935da29fa64dbccdc7656db691a2
  $wgo ::
    GHC.Integer.Type.Integer -> (# Parser.PExpr, [Parser.PExpr] #)
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0] -}
53b292c36af6ebf5d8e3df85e7da0950
  $wgo1 ::
    [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used)]
    -> Types.TState -> (# (), Types.TState #)
  {- Arity: 2,
     Strictness: <S,1*U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [0] -}
4fc744e7e502905f415664deff538e00
  $wgo2 ::
    [Types.CFunc]
    -> Types.TState
    -> (# [GHC.Base.Maybe Types.TCFunc], Types.TState #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
7b5cfa0bced8c1ac4800b85c56b134ce
  $wreplaceBy ::
    Types.Name
    -> Parser.PExpr
    -> GHC.Types.Int
    -> Parser.PGuards
    -> Parser.PGuards
  {- Arity: 4, HasNoCafRefs, Strictness: <L,U><L,U><L,1*U(U)><S,1*U>,
     Inline: [0],
     Unfolding: (\ (w :: Types.Name)
                   (ww :: Parser.PExpr)
                   (ww1 :: GHC.Types.Int)
                   (w1 :: Parser.PGuards) ->
                 let {
                   lvl130 :: [GHC.Types.Char]
                   = GHC.CString.unpackAppendCString#
                       "__i"#
                       (case ww1 of ww2 { GHC.Types.I# ww3 ->
                        case GHC.Show.$wshowSignedInt
                               0#
                               ww3
                               (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                        GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                 } in
                 let {
                   lvl131 :: Lexer.Token = Lexer.Low lvl130
                 } in
                 letrec {
                   replace :: Parser.PExpr -> Parser.PExpr
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (e :: Parser.PExpr) ->
                     case e of wild {
                       Parser.PApp ds exps
                       -> case ds of wild1 { Lexer.L l ds1 ->
                          case ds1 of wild2 {
                            DEFAULT
                            -> Parser.PApp
                                 wild1
                                 (GHC.Base.map @ Parser.PExpr @ Parser.PExpr replace exps)
                            Lexer.Low x
                            -> case GHC.Base.eqString x w of wild3 {
                                 GHC.Types.False
                                 -> Parser.PApp
                                      wild1
                                      (GHC.Base.map @ Parser.PExpr @ Parser.PExpr replace exps)
                                 GHC.Types.True
                                 -> Parser.PApp
                                      (Lexer.L @ Lexer.Token l lvl131)
                                      (GHC.Base.map
                                         @ Parser.PExpr
                                         @ Parser.PExpr
                                         replace
                                         exps) } } }
                       Parser.PAExpr ds
                       -> case ds of wild1 { Lexer.L ds1 ds2 ->
                          case ds2 of wild2 {
                            DEFAULT -> wild
                            Lexer.Low x
                            -> case GHC.Base.eqString x w of wild3 {
                                 GHC.Types.False -> wild GHC.Types.True -> ww } } } }
                 } in
                 case w1 of wild {
                   Parser.PNoGuards e -> Parser.PNoGuards (replace e)
                   Parser.PGuards ces
                   -> Parser.PGuards
                        (GHC.Base.map
                           @ (Parser.PExpr, Parser.PExpr)
                           @ (Parser.PExpr, Parser.PExpr)
                           (\ (ds :: (Parser.PExpr, Parser.PExpr)) ->
                            case ds of wild1 { (,) c e -> (replace c, replace e) })
                           ces) }) -}
9289c2ed90a0438dda38d43166026891
  $wtoCFTy :: Parser.PFType -> (# Types.CFType, [Types.CFType] #)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>, Inline: [0] -}
f88c2a7ae94128de9ee8da8be73115df
  $wtypeCheckEach ::
    Lexer.LToken
    -> [Lexer.LToken]
    -> Types.CGuards
    -> [Types.CFType]
    -> Types.TMM Types.TCFunc
  {- Arity: 4, Strictness: <L,U(U,U)><L,U><L,1*U><L,U>,
     Inline: [0] -}
4d5697fbca95dbb36f3b3bd99608ca10
  andExpr :: Parser.PExpr -> Parser.PExpr -> Parser.PExpr
  {- Arity: 2, Strictness: <L,U><L,U>m1,
     Unfolding: InlineRule (2, True, False)
                (\ (e1 :: Parser.PExpr) (e2 :: Parser.PExpr) ->
                 Parser.PApp
                   Core.andExpr1
                   (GHC.Types.:
                      @ Parser.PExpr
                      e1
                      (GHC.Types.: @ Parser.PExpr e2 (GHC.Types.[] @ Parser.PExpr)))) -}
7de078a46031001a883fed2cba4885db
  andExpr1 :: Lexer.L Lexer.Token
  {- Strictness: m,
     Unfolding: (Lexer.L @ Lexer.Token Lexer.NoLoc Core.andExpr2) -}
49669e7f20534a2f41f8e64bdf8c0e3d
  andExpr2 :: Lexer.Token
  {- Strictness: m7, Unfolding: (Lexer.Low Core.andExpr3) -}
c832a4dda907a4f6e0edffc136158951
  andExpr3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "and"#) -}
6d834237ae59659344bb3ce7cfba1677
  concatExpr ::
    Types.Name
    -> Parser.PExpr -> (Parser.Pat, GHC.Types.Int) -> Parser.PExpr
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,1*U><L,U><S,1*U(A,1*U(U))>m1, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.Name)
                   (w1 :: Parser.PExpr)
                   (w2 :: (Parser.Pat, GHC.Types.Int)) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 case Core.$wconcatExpr w w1 ww2 of ww3 { (#,#) ww4 ww5 ->
                 Parser.PApp ww4 ww5 } }) -}
12365d521ba1b50d91a8be67fbc69c65
  concatGuards :: [Parser.PGuards] -> Parser.PGuards
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (pgs :: [Parser.PGuards]) ->
                 case pgs of wild {
                   [] -> GHC.List.foldl2 @ Parser.PGuards
                   : x xs -> Core.concatGuards_go xs x }) -}
16a648bfeb3889a68aaa1ba9625a10f7
  concatGuards_go ::
    [Parser.PGuards] -> Parser.PGuards -> Parser.PGuards
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
1001db9e5f4896832cf24a0d0bc14b8a
  destroy ::
    [(Parser.Pat, Parser.PExpr, GHC.Types.Int)]
    -> Parser.PGuards -> Parser.PGuards
  {- Arity: 2, Strictness: <S,1*U><S,1*U> -}
5667392aafd4c6fd60d805a035a63927
  destroyPats :: ([Parser.Pat], Parser.PGuards) -> Parser.PGuards
  {- Arity: 1, Strictness: <S(SS),1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ([Parser.Pat], Parser.PGuards)) ->
                 case ds of wild { (,) pats pgs ->
                 Core.destroy
                   (GHC.List.zip3
                      @ Parser.Pat
                      @ Parser.PExpr
                      @ GHC.Types.Int
                      pats
                      Core.destroyPats2
                      Core.destroyPats1)
                   pgs }) -}
6d93257624f238a29e756cafc6ac6b86
  destroyPats1 :: [GHC.Types.Int]
  {- Unfolding: (GHC.Enum.eftInt 0# 9223372036854775807#) -}
a9803ecb6658c6aeccc02f61514a3ed9
  destroyPats2 :: [Parser.PExpr]
  {- Unfolding: (case Core.$wgo
                        Core.destroyPats3 of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ Parser.PExpr ww1 ww2 }) -}
6f201100b17c5176149dde3d569043e7
  destroyPats3 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (0) -}
51896769699b30316a8a14a8305540f1
  df ::
    (Types.Name, Parser.PExpr) -> Parser.PGuards -> Parser.PGuards
  {- Arity: 2, Strictness: <S,1*U(U,U)><S,1*U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: (Types.Name, Parser.PExpr)) (w1 :: Parser.PGuards) ->
                 case w of ww { (,) ww1 ww2 ->
                 case Core.$wdf ww1 ww2 w1 of ww3 { Unit# ww4 ->
                 Parser.PGuards ww4 } }) -}
41117bd0aba2676f2d39c2fe1bbab5d0
  dropFunctionDef :: Types.Name -> [Parser.PDecl] -> [Parser.PDecl]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (name :: Types.Name) (eta :: [Parser.PDecl]) ->
                 GHC.List.dropWhile @ Parser.PDecl (Core.isSameFunc name) eta) -}
9dbfecb25534aeea9c9f8c646493de12
  fixedFunctions :: Types.TCore -> Types.TCore
  {- Arity: 1, Strictness: <S,1*U(1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.TCore) ->
                 case ds of wild { Types.TCore tcfs ->
                 Types.TCore
                   (GHC.Base.build
                      @ Types.TCFunc
                      (\ @ b1
                         (c :: Types.TCFunc -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ Types.TCFunc
                         @ b1
                         (GHC.Base.mapFB
                            @ Types.TCFunc
                            @ b1
                            @ Types.TCFunc
                            c
                            Core.substFunctions)
                         n
                         tcfs)) }) -}
956703f39fb5ec1874eddb1b97957036
  funcName :: Types.CFunc -> GHC.Base.String
  {- Arity: 1, Strictness: <S(S(LS)LLL),1*U(1*U(A,1*U),A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Types.CFunc) ->
                 case ds of wild { Types.CFunc ds1 ds2 ds3 ds4 ->
                 case ds1 of wild1 { Lexer.L ds5 ds6 ->
                 case ds6 of wild2 {
                   DEFAULT -> Core.funcName1 Lexer.Low name -> name } } }) -}
a8a01b6aa43656cb9191cf9e946c5860
  funcName1 :: GHC.Base.String
  {- Strictness: x -}
e3f4dcd60a7f4f7f8d67f81d291295c9
  gatherFunctions ::
    Parser.P2Result
    -> Types.TMM
         [(Types.Name, Parser.PFType, [Types.Name], Parser.PGuards)]
  {- Arity: 1, Strictness: <S,1*U(1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Parser.P2Result) ->
                 case w of ww { Parser.P2Result ww1 ->
                 Core.$wgatherFunctions ww1 }) -}
50bb8d7f9a103c82638d69e3bea28cf5
  gatherFunctions1 :: Parser.PDecl -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Parser.PDecl) ->
                 case x of wild {
                   DEFAULT -> GHC.Types.True
                   Parser.PDataType ds ds1 -> GHC.Types.False }) -}
a94ac6872daec88c8fe28e3e82671696
  gatherFunctions_patternsToGuards ::
    (t, Parser.PFType, [([Parser.Pat], Parser.PGuards)])
    -> (t, Parser.PFType, [Types.Name], Parser.PGuards)
  {- Arity: 1, Strictness: <S,1*U(U,1*U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ t
                   (w :: (t, Parser.PFType, [([Parser.Pat], Parser.PGuards)])) ->
                 case w of ww { (,,) ww1 ww2 ww3 ->
                 (ww1, Core.substIntFixed ww2,
                  Core.varsFromPats @ Parser.PGuards ww3,
                  case GHC.Base.map
                         @ ([Parser.Pat], Parser.PGuards)
                         @ Parser.PGuards
                         Core.destroyPats
                         ww3 of wild {
                    [] -> GHC.List.foldl2 @ Parser.PGuards
                    : x xs -> Core.concatGuards_go xs x }) }) -}
b4548ecbf5cff629f16387372d1891cd
  getName :: Lexer.LToken -> Types.Name
  {- Arity: 1, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Lexer.L Lexer.Token) ->
                 case x of wild { Lexer.L ds1 ds2 ->
                 case ds2 of wild1 {
                   DEFAULT -> Core.getName1 Lexer.Low n -> n Lexer.Upp n -> n } }) -}
13beba5569023c2ac7789340d3eeae36
  getName1 :: GHC.Base.String
  {- Strictness: x -}
d1f99549172d1cf70eddaab1a7eb7c1d
  glueFunctions ::
    [Parser.PDecl]
    -> Types.TM
         [(Types.Name, Parser.PFType, [([Parser.Pat], Parser.PGuards)])]
  {- Arity: 1, Strictness: <S,1*U> -}
a8e82cea6955d01fe81d1af7025d26db
  isData :: Parser.PDecl -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Parser.PDecl) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.False
                   Parser.PDataType ds1 ds2 -> GHC.Types.True }) -}
d6f5df9a1dd8f0df16ccd098211c1188
  isFixed :: Types.CFType -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ty :: Types.CFType) ->
                 case ty of wild {
                   DEFAULT -> GHC.Types.False
                   Types.CTApp ds ds1
                   -> case ds of wild1 { Lexer.L ds2 ds3 ->
                      case ds3 of wild2 {
                        DEFAULT -> GHC.Types.False
                        Lexer.Upp ds4 -> GHC.Base.eqString ds4 Core.substExpr2 } } }) -}
97aebd952edf7b287593010b87b7b170
  isNumFunc :: [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (f :: [GHC.Types.Char]) ->
                 GHC.List.elem
                   @ [GHC.Types.Char]
                   GHC.Classes.$fEq[]_$s$fEq[]1
                   f
                   Core.substExpr3) -}
f7466fddd9aa41be5f5178b5ebc739b3
  isPAExpr :: Parser.PExpr -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Parser.PExpr) ->
                 case ds of wild {
                   Parser.PApp ipv ipv1 -> GHC.Types.False
                   Parser.PAExpr ds1 -> GHC.Types.True }) -}
d66d6bdd6b6ecf416e09892b59c943ae
  isRecursiveData :: Types.Name -> [Types.CConstr] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (name :: Types.Name) (cconstrs :: [Types.CConstr]) ->
                 letrec {
                   go10 :: [Types.CFType] -> Data.Monoid.Any
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Types.CFType]) ->
                     case ds of wild {
                       [] -> GHC.Types.False `cast` (Sym (Data.Monoid.N:Any[0]))
                       : y ys
                       -> case y of wild1 {
                            DEFAULT -> go10 ys
                            Types.CTAExpr ds1
                            -> case ds1 of wild2 { Lexer.L ds2 ds3 ->
                               case ds3 of wild3 {
                                 DEFAULT -> go10 ys
                                 Lexer.Upp x
                                 -> case GHC.Base.eqString x name of wild4 {
                                      GHC.Types.False -> go10 ys
                                      GHC.Types.True
                                      -> GHC.Types.True
                                           `cast`
                                         (Sym (Data.Monoid.N:Any[0])) } } } } }
                 } in
                 letrec {
                   go11 :: [Types.CConstr] -> Data.Monoid.Any
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Types.CConstr]) ->
                     case ds of wild {
                       [] -> GHC.Types.False `cast` (Sym (Data.Monoid.N:Any[0]))
                       : y ys
                       -> case y of wild1 { Types.CConstr ds1 cfts ->
                          case (go10 cfts) `cast` (Data.Monoid.N:Any[0]) of wild2 {
                            GHC.Types.False -> go11 ys
                            GHC.Types.True
                            -> GHC.Types.True `cast` (Sym (Data.Monoid.N:Any[0])) } } }
                 } in
                 (go11 cconstrs) `cast` (Data.Monoid.N:Any[0])) -}
06c51860b53a96742b5806c0ecaaa60a
  isSameFunc :: Types.Name -> Parser.PDecl -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ (name :: Types.Name) (p :: Parser.PDecl) ->
                 case p of wild {
                   DEFAULT -> GHC.Types.False
                   Parser.PFunc ds pats pgs
                   -> case ds of wild1 { Lexer.L ds1 ds2 ->
                      case ds2 of wild2 {
                        DEFAULT -> GHC.Types.False
                        Lexer.Low n -> GHC.Base.eqString n name } } }) -}
c54392bac8b6c6305796bf2607ba4131
  makeExpr :: GHC.Show.Show a => a -> Parser.PExpr
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*C1(U),A)><L,U>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ @ a (w :: GHC.Show.Show a) (w1 :: a) ->
                 Parser.PAExpr
                   (Lexer.L
                      @ Lexer.Token
                      Lexer.NoLoc
                      (Lexer.Low
                         (GHC.CString.unpackAppendCString#
                            "__i"#
                            (GHC.Show.show @ a w w1))))) -}
747c8129c3bb1dd4f0f8a659c23f7181
  noLoc :: a -> Lexer.L a
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ @ a -> Lexer.L @ a Lexer.NoLoc) -}
63aff68c3c8998044e33ca95b8f4fd85
  noLocDec :: GHC.Types.Int -> Lexer.L Lexer.Token
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: GHC.Types.Int) ->
                 Lexer.L @ Lexer.Token Lexer.NoLoc (Lexer.Dec x)) -}
947b6e8b34a8402f5f0762e210771316
  noLocLow :: GHC.Base.String -> Lexer.L Lexer.Token
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: GHC.Base.String) ->
                 Lexer.L @ Lexer.Token Lexer.NoLoc (Lexer.Low x)) -}
8d24fedcfd27fa67afe8eab1536e325c
  noLocUpp :: GHC.Base.String -> Lexer.L Lexer.Token
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: GHC.Base.String) ->
                 Lexer.L @ Lexer.Token Lexer.NoLoc (Lexer.Upp x)) -}
10de569ccd5d38c9bc129df4f376f847
  putDataDefsInState :: Types.TM ()
  {- Arity: 1,
     Strictness: <S(LSLLLLLLLLLLLLLLLL),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                Core.putDataDefsInState1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N)) -}
b6efdf670aae9baca40ad483c4e85dcf
  putDataDefsInState1 ::
    Types.TState -> Data.Functor.Identity.Identity ((), Types.TState)
  {- Arity: 1,
     Strictness: <S(LSLLLLLLLLLLLLLLLL),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Types.TState) ->
                 case w of ww { Types.TState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ->
                 case Core.$wgo1
                        ww2
                        (Types.TState
                           ww1
                           ww2
                           ww3
                           ww4
                           ww5
                           ww6
                           ww7
                           ww8
                           ww9
                           ww10
                           ww11
                           ww12
                           ww13
                           ww14
                           ww15
                           ww16
                           ww17
                           ww18) of ww19 { (#,#) ww20 ww21 ->
                 (ww20, ww21)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <((), Types.TState)>_R)) } }) -}
d6d4f313dd25a39f636417d8e8576314
  putFunctionTypesInState :: Types.TM ()
  {- Arity: 1,
     Strictness: <S(LLLLLLLLLLLLLLLLLS(S)),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U(U))>m,
     Unfolding: InlineRule (0, True, True)
                Core.putFunctionTypesInState1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N)) -}
1dda0b49644abdc98845f3b4d1f5bf02
  putFunctionTypesInState1 ::
    Types.TState -> Data.Functor.Identity.Identity ((), Types.TState)
  {- Arity: 1,
     Strictness: <S(LLLLLLLLLLLLLLLLLS(S)),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Types.TState) ->
                 case w of ww { Types.TState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ->
                 case ww18 of ww19 { Types.Core ww20 ->
                 letrec {
                   $wgo6 :: [Types.CFunc] -> Types.TState -> (# (), Types.TState #)
                     {- Arity: 2,
                        Strictness: <S,1*U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
                        Inline: [0] -}
                   = \ (w1 :: [Types.CFunc]) (w2 :: Types.TState) ->
                     case w1 of wild {
                       [] -> (# GHC.Tuple.(), w2 #)
                       : y ys
                       -> $wgo6
                            ys
                            (case y of wild1 { Types.CFunc ds ds1 ds2 cts ->
                             case ds of wild2 { Lexer.L ds3 ds4 ->
                             case ds4 of wild3 {
                               DEFAULT
                               -> case Core.putFunctionTypesInState2 ret_ty Types.TState of {}
                               Lexer.Low name
                               -> case w2 of wild4 { Types.TState ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ds21 ds22 ->
                                  Types.TState
                                    ds5
                                    ds6
                                    (GHC.Types.:
                                       @ (Types.Name, [Types.Constraint], [Types.CFType])
                                       (name, GHC.Types.[] @ Types.Constraint, cts)
                                       ds7)
                                    ds8
                                    ds9
                                    ds10
                                    ds11
                                    ds12
                                    ds13
                                    ds14
                                    ds15
                                    ds16
                                    ds17
                                    ds18
                                    ds19
                                    ds20
                                    ds21
                                    ds22 } } } }) }
                 } in
                 case $wgo6
                        ww20
                        (Types.TState
                           ww1
                           ww2
                           ww3
                           ww4
                           ww5
                           ww6
                           ww7
                           ww8
                           ww9
                           ww10
                           ww11
                           ww12
                           ww13
                           ww14
                           ww15
                           ww16
                           ww17
                           (Types.Core ww20)) of ww21 { (#,#) ww22 ww23 ->
                 (ww22, ww23)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <((), Types.TState)>_R)) } } }) -}
79037e6882e84d85b32acd2b9c9cdc76
  putFunctionTypesInState2 ::
    Control.Monad.Trans.State.Lazy.StateT
      Types.TState Data.Functor.Identity.Identity ()
  {- Strictness: x -}
17614537d1e4aeb8fd8007f04957ebce
  replaceBy ::
    Types.Name
    -> (Parser.PExpr, GHC.Types.Int)
    -> Parser.PGuards
    -> Parser.PGuards
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><S,1*U(U,1*U(U))><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.Name)
                   (w1 :: (Parser.PExpr, GHC.Types.Int))
                   (w2 :: Parser.PGuards) ->
                 case w1 of ww { (,) ww1 ww2 -> Core.$wreplaceBy w ww1 ww2 w2 }) -}
6a673880711557149bd39798c16f4714
  storeCoreInState :: Parser.P2Result -> Types.TMM ()
  {- Arity: 1, Strictness: <L,1*U(1*U)>,
     Unfolding: (\ (expr :: Parser.P2Result) ->
                 let {
                   m1 :: Control.Monad.Trans.State.Lazy.StateT
                           Types.TState
                           Data.Functor.Identity.Identity
                           (GHC.Base.Maybe
                              [(Types.Name, Parser.PFType, [Types.Name], Parser.PGuards)])
                   = case expr of ww { Parser.P2Result ww1 ->
                     Core.$wgatherFunctions ww1 }
                 } in
                 (\ (s1 :: Types.TState) ->
                  case (m1
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <Types.TState>_N
                             <Data.Functor.Identity.Identity>_R
                             <GHC.Base.Maybe
                                [(Types.Name, Parser.PFType, [Types.Name], Parser.PGuards)]>_N)
                          s1)
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <(GHC.Base.Maybe
                                [(Types.Name, Parser.PFType, [Types.Name], Parser.PGuards)],
                              Types.TState)>_R) of wild { (,) a1 s' ->
                  case a1 of wild1 {
                    GHC.Base.Nothing
                    -> (TransformationMonad.cont4 @ () s')
                         `cast`
                       (Sym (Data.Functor.Identity.N:Identity[0]
                                 <(GHC.Base.Maybe (), Types.TState)>_R))
                    GHC.Base.Just ds1
                    -> (Core.storeCoreInState2,
                        case s' of wild2 { Types.TState ds ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                        Types.TState
                          ds
                          ds2
                          ds3
                          ds4
                          ds5
                          ds6
                          ds7
                          ds8
                          ds9
                          ds10
                          ds11
                          ds12
                          ds13
                          ds14
                          ds15
                          ds16
                          ds17
                          (Types.Core
                             (GHC.Base.map
                                @ (Types.Name, Parser.PFType, [Types.Name], Parser.PGuards)
                                @ Types.CFunc
                                Core.storeCoreInState1
                                ds1)) })
                         `cast`
                       (Sym (Data.Functor.Identity.N:Identity[0]
                                 <(GHC.Base.Maybe (), Types.TState)>_R)) } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <Types.TState>_N
                           <Data.Functor.Identity.Identity>_R
                           <GHC.Base.Maybe ()>_N))) -}
e826150887c2238a5d1d2ae8393d09d8
  storeCoreInState1 ::
    (Types.Name, Parser.PFType, [Types.Name], Parser.PGuards)
    -> Types.CFunc
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,1*U,1*U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: (Types.Name, Parser.PFType, [Types.Name],
                          Parser.PGuards)) ->
                 case w of ww { (,,,) ww1 ww2 ww3 ww4 ->
                 Types.CFunc
                   (Lexer.L @ Lexer.Token Lexer.NoLoc (Lexer.Low ww1))
                   (GHC.Base.map
                      @ [GHC.Types.Char]
                      @ (Lexer.L Lexer.Token)
                      Core.noLocLow
                      ww3)
                   (case ww4 of wild {
                      Parser.PNoGuards x -> Types.CNoGuards x
                      Parser.PGuards xys -> Types.CGuards xys })
                   (Core.toCFTy ww2) }) -}
aa2760cca1af9f9a4d8a4735215b0293
  storeCoreInState2 :: GHC.Base.Maybe ()
  {- HasNoCafRefs, Unfolding: (GHC.Base.Just @ () GHC.Tuple.()) -}
2a091b7b3baa646f4e9d1c1bacffb91e
  storeDataInState :: Parser.P2Result -> Types.TM ()
  {- Arity: 1, Strictness: <S(S),1*U(1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Parser.P2Result) ->
                 case w of ww { Parser.P2Result ww1 ->
                 Core.storeDataInState_go ww1 }) -}
d30a3af3103399ae753411dd5335a076
  storeDataInState_go ::
    [Parser.PDecl]
    -> Control.Monad.Trans.State.Lazy.StateT
         Types.TState Data.Functor.Identity.Identity ()
  {- Arity: 1, Strictness: <S,1*U> -}
b039feacbfb8e06e0b6ee9ab925395f6
  substExpr :: Types.TCExpr -> Types.TCExpr
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (tcexpr :: Types.TCExpr) ->
                 case tcexpr of wild {
                   Types.TCApp ds args ty
                   -> case ds of wild1 { Lexer.L l ds1 ->
                      case ds1 of wild2 {
                        DEFAULT -> wild
                        Lexer.Low name
                        -> case GHC.List.elem
                                  @ [GHC.Types.Char]
                                  GHC.Classes.$fEq[]_$s$fEq[]1
                                  name
                                  Core.substExpr3 of wild3 {
                             GHC.Types.False -> wild
                             GHC.Types.True
                             -> case ty of wild4 {
                                  DEFAULT -> wild
                                  Types.CTApp ds2 ds3
                                  -> case ds2 of wild5 { Lexer.L ds4 ds5 ->
                                     case ds5 of wild6 {
                                       DEFAULT -> wild
                                       Lexer.Upp ds6
                                       -> case GHC.Base.eqString ds6 Core.substExpr2 of wild7 {
                                            GHC.Types.False -> wild
                                            GHC.Types.True
                                            -> Types.TCApp
                                                 (Lexer.L
                                                    @ Lexer.Token
                                                    l
                                                    (Lexer.Low
                                                       (GHC.Base.++
                                                          @ GHC.Types.Char
                                                          name
                                                          Core.substExpr1)))
                                                 args
                                                 wild4 } } } } } } }
                   Types.TCAExpr ipv -> wild }) -}
f1318b372a189d4592a97fa05359e9d1
  substExpr1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "F"#) -}
3896d1415617ffc69c178e7d52bcd836
  substExpr2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Fixed"#) -}
416e55eb07e2057091131dff7e76ebee
  substExpr3 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   Core.substExpr8
                   Core.substExpr4) -}
0c47f633218ef9f21967760911139aa4
  substExpr4 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   Core.substExpr7
                   Core.substExpr5) -}
fd1b78ff836b0adee085b32a9d190a4a
  substExpr5 :: [[GHC.Types.Char]]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [GHC.Types.Char]
                   Core.substExpr6
                   (GHC.Types.[] @ [GHC.Types.Char])) -}
60c6a5333af48fe7a1ad1d4101d6efa7
  substExpr6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "mul"#) -}
bd84b43fba7f270a653358a96c9afd66
  substExpr7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "sub"#) -}
3ea94b06dec6eed439e94ba521178048
  substExpr8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "add"#) -}
8a0437bcdcd818f17569b3cd555a1527
  substFunctions :: Types.TCFunc -> Types.TCFunc
  {- Arity: 1, Strictness: <S,1*U(U,U,1*U,U)>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Types.TCFunc) ->
                 case w of ww { Types.TCFunc ww1 ww2 ww3 ww4 ->
                 Types.TCFunc
                   ww1
                   ww2
                   (case ww3 of wild {
                      Types.TCNoGuards e -> Types.TCNoGuards (Core.substExpr e)
                      Types.TCGuards ces
                      -> Types.TCGuards
                           (GHC.Base.map
                              @ (Types.TCExpr, Types.TCExpr)
                              @ (Types.TCExpr, Types.TCExpr)
                              Core.substFunctions1
                              ces) })
                   ww4 }) -}
65de59431cb9670f07356a2b61c5ad2e
  substFunctions1 ::
    (Types.TCExpr, Types.TCExpr) -> (Types.TCExpr, Types.TCExpr)
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Types.TCExpr, Types.TCExpr)) ->
                 case ds of wild { (,) a1 a2 ->
                 (Core.substExpr a1, Core.substExpr a2) }) -}
4c8e1e10290c5dfbb96b1829f5ef842b
  substIntFixed :: Parser.PFType -> Parser.PFType
  {- Arity: 1, Strictness: <S,1*U> -}
6891a1b4d80fe59513b54e6ae4e82310
  takeFunctionDef ::
    Types.Name -> [Parser.PDecl] -> [([Parser.Pat], Parser.PGuards)]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><S,1*U>,
     Unfolding: (\ (name :: Types.Name) (eta :: [Parser.PDecl]) ->
                 letrec {
                   go10 :: [Parser.PDecl] -> [([Parser.Pat], Parser.PGuards)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [Parser.PDecl]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ ([Parser.Pat], Parser.PGuards)
                       : y ys
                       -> case y of wild1 {
                            DEFAULT -> GHC.Types.[] @ ([Parser.Pat], Parser.PGuards)
                            Parser.PFunc ds1 pats pgs
                            -> case ds1 of wild2 { Lexer.L ds2 ds3 ->
                               case ds3 of wild3 {
                                 DEFAULT -> GHC.Types.[] @ ([Parser.Pat], Parser.PGuards)
                                 Lexer.Low n
                                 -> case GHC.Base.eqString n name of wild4 {
                                      GHC.Types.False
                                      -> GHC.Types.[] @ ([Parser.Pat], Parser.PGuards)
                                      GHC.Types.True
                                      -> GHC.Types.:
                                           @ ([Parser.Pat], Parser.PGuards)
                                           (pats, pgs)
                                           (go10 ys) } } } } }
                 } in
                 go10 eta) -}
8e0ec4084c296446eb8f8fa1279f21ab
  toCFTy :: Parser.PFType -> [Types.CFType]
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>m2,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Parser.PFType) ->
                 case Core.$wtoCFTy w of ww { (#,#) ww1 ww2 ->
                 GHC.Types.: @ Types.CFType ww1 ww2 }) -}
ade40d4dc64d49cd3e24993fb9d0abf3
  toCFTy' :: Parser.PFType -> Types.CFType
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
4f9ad25ae3ebaa4e36f89ad1d72c3fa7
  toCore ::
    [(Types.Name, Parser.PFType, [Types.Name], Parser.PGuards)]
    -> Types.Core
  {- Arity: 1, HasNoCafRefs, Strictness: <L,1*U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (dcs :: [(Types.Name, Parser.PFType, [Types.Name],
                             Parser.PGuards)]) ->
                 Types.Core
                   (GHC.Base.build
                      @ Types.CFunc
                      (\ @ b1
                         (c :: Types.CFunc -> b1 -> b1)[OneShot]
                         (n :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ (Types.Name, Parser.PFType, [Types.Name], Parser.PGuards)
                         @ b1
                         (GHC.Base.mapFB
                            @ Types.CFunc
                            @ b1
                            @ (Types.Name, Parser.PFType, [Types.Name], Parser.PGuards)
                            c
                            Core.storeCoreInState1)
                         n
                         dcs))) -}
8b03ea0f7ae9f16617f4301ab3368d0d
  trueCond :: Parser.PExpr
  {- Strictness: m2, Unfolding: (Parser.PAExpr Core.trueCond1) -}
d79649b5f1caa0e0875bad8df68133b9
  trueCond1 :: Lexer.L Lexer.Token
  {- Strictness: m,
     Unfolding: (Lexer.L @ Lexer.Token Lexer.NoLoc Core.trueCond2) -}
bde743fd7f0cb505e2fa97df18734a77
  trueCond2 :: Lexer.Token
  {- Strictness: m7, Unfolding: (Lexer.Low Core.trueCond3) -}
8b5ebc7044f9028ff09ff8e263959cb7
  trueCond3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "otherwise"#) -}
fd519ea8d03bd683e20575baf6b1e3b7
  typeCheck :: Types.TMM ()
  {- Arity: 1,
     Strictness: <S(LLLLLLLLLLLLLLLLLS(S)),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U(U))>m,
     Unfolding: InlineRule (0, True, True)
                Core.typeCheck1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <Types.TState>_N
                          <Data.Functor.Identity.Identity>_R
                          <GHC.Base.Maybe ()>_N)) -}
56b13480f13cddf8cc5addf42cd36c54
  typeCheck' :: Types.TMM Types.TCore
  {- Arity: 1,
     Strictness: <S(LLLLLLLLLLLLLLLLLS(S)),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U(U))>m,
     Unfolding: InlineRule (0, True, True)
                Core.typeCheck'1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <Types.TState>_N
                          <Data.Functor.Identity.Identity>_R
                          <GHC.Base.Maybe Types.TCore>_N)) -}
af8460bfa0c87ef8aaa1faa9229cc81f
  typeCheck'1 ::
    Types.TState
    -> Data.Functor.Identity.Identity
         (GHC.Base.Maybe Types.TCore, Types.TState)
  {- Arity: 1,
     Strictness: <S(LLLLLLLLLLLLLLLLLS(S)),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U(U))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) ->
                 case s1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                 Core.typeCheck'2 ds18 wild }) -}
2b134b35164f5fae9288f543095ce625
  typeCheck'2 ::
    Types.Core
    -> Types.TState
    -> Data.Functor.Identity.Identity
         (GHC.Base.Maybe Types.TCore, Types.TState)
  {- Arity: 2, Strictness: <S(S),1*U(1*U)><L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Core) (w1 :: Types.TState) ->
                 case w of ww { Types.Core ww1 ->
                 case Core.$wgo2 ww1 w1 of ww2 { (#,#) ww3 ww4 ->
                 case (TransformationMonad.cont_1 @ Types.TCFunc ww3)
                        `cast`
                      (Data.Monoid.N:All[0]) of wild {
                   GHC.Types.False
                   -> (GHC.Base.Nothing @ Types.TCore, ww4)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Base.Maybe Types.TCore, Types.TState)>_R))
                   GHC.Types.True
                   -> (GHC.Base.Just
                         @ Types.TCore
                         (Types.TCore
                            (GHC.Base.map
                               @ (GHC.Base.Maybe Types.TCFunc)
                               @ Types.TCFunc
                               Core.typeCheck2
                               ww3)),
                       ww4)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Base.Maybe Types.TCore, Types.TState)>_R)) } } }) -}
c014375314ed63f190419c35696950c1
  typeCheck1 ::
    Types.TState
    -> Data.Functor.Identity.Identity (GHC.Base.Maybe (), Types.TState)
  {- Arity: 1,
     Strictness: <S(LLLLLLLLLLLLLLLLLS(S)),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Types.TState) ->
                 case w of ww { Types.TState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ->
                 case ww18 of ww19 { Types.Core ww20 ->
                 case Core.$wgo2
                        ww20
                        (Types.TState
                           ww1
                           ww2
                           ww3
                           ww4
                           ww5
                           ww6
                           ww7
                           ww8
                           ww9
                           ww10
                           ww11
                           ww12
                           ww13
                           ww14
                           ww15
                           ww16
                           ww17
                           (Types.Core ww20)) of ww21 { (#,#) ww22 ww23 ->
                 let {
                   $j :: GHC.Base.Maybe Types.TCore
                         -> Types.TState
                         -> Data.Functor.Identity.Identity (GHC.Base.Maybe (), Types.TState)
                     {- Arity: 2 -}
                   = \ (ww24 :: GHC.Base.Maybe Types.TCore)[OneShot]
                       (ww25 :: Types.TState)[OneShot] ->
                     case ww24 of wild {
                       GHC.Base.Nothing
                       -> (GHC.Base.Nothing @ (), ww25)
                            `cast`
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <(GHC.Base.Maybe (), Types.TState)>_R))
                       GHC.Base.Just ds1
                       -> (GHC.Base.Just @ () GHC.Tuple.(),
                           case ww25 of wild1 { Types.TState ds ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                           Types.TState
                             ds
                             ds2
                             ds3
                             ds4
                             ds5
                             ds6
                             ds1
                             (GHC.Types.:
                                @ Types.TLog
                                (Types.TLogDebug
                                   (case ds1 of wild2 { Types.TCore b1 ->
                                    GHC.Base.++
                                      @ GHC.Types.Char
                                      Types.$fShowTCore2
                                      (GHC.Show.showList__
                                         @ Types.TCFunc
                                         Types.$fShowTCFunc1
                                         b1
                                         (GHC.Types.[] @ GHC.Types.Char)) })
                                   ds5)
                                ds8)
                             ds9
                             ds10
                             ds11
                             ds12
                             ds13
                             ds14
                             ds15
                             ds16
                             ds17
                             ds18 })
                            `cast`
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <(GHC.Base.Maybe (), Types.TState)>_R)) }
                 } in
                 case (TransformationMonad.cont_1 @ Types.TCFunc ww22)
                        `cast`
                      (Data.Monoid.N:All[0]) of wild {
                   GHC.Types.False -> $j (GHC.Base.Nothing @ Types.TCore) ww23
                   GHC.Types.True
                   -> $j
                        (GHC.Base.Just
                           @ Types.TCore
                           (Types.TCore
                              (GHC.Base.map
                                 @ (GHC.Base.Maybe Types.TCFunc)
                                 @ Types.TCFunc
                                 Core.typeCheck2
                                 ww22)))
                        ww23 } } } }) -}
d78178c55c253c7f6291fcc137289f63
  typeCheck2 :: GHC.Base.Maybe Types.TCFunc -> Types.TCFunc
  {- Arity: 1,
     Unfolding: (\ (x :: GHC.Base.Maybe Types.TCFunc) ->
                 case x of wild {
                   GHC.Base.Nothing -> case Aux.just1 ret_ty Types.TCFunc of {}
                   GHC.Base.Just x1
                   -> case x1 of ww { Types.TCFunc ww1 ww2 ww3 ww4 ->
                      Types.TCFunc
                        ww1
                        ww2
                        (case ww3 of wild1 {
                           Types.TCNoGuards e -> Types.TCNoGuards (Core.substExpr e)
                           Types.TCGuards ces
                           -> Types.TCGuards
                                (GHC.Base.map
                                   @ (Types.TCExpr, Types.TCExpr)
                                   @ (Types.TCExpr, Types.TCExpr)
                                   Core.substFunctions1
                                   ces) })
                        ww4 } }) -}
3eb5205ced221d5cedc42a2973edcd84
  typeCheckEach :: Types.CFunc -> Types.TMM Types.TCFunc
  {- Arity: 1, Strictness: <S,1*U(U(U,U),U,1*U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Types.CFunc) ->
                 case w of ww { Types.CFunc ww1 ww2 ww3 ww4 ->
                 Core.$wtypeCheckEach ww1 ww2 ww3 ww4 }) -}
66e3e65c418acedfc1e00285e4c1a365
  varsFromPats :: [([Parser.Pat], a)] -> [Types.Name]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ @ a (xs :: [([Parser.Pat], a)]) ->
                 case xs of wild {
                   [] -> case GHC.List.badHead ret_ty [[GHC.Types.Char]] of {}
                   : x ds1
                   -> case x of wild1 { (,) pats ds ->
                      case GHC.List.$wlenAcc @ Parser.Pat pats 0# of ww2 { DEFAULT ->
                      let {
                        y :: GHC.Prim.Int# = GHC.Prim.-# ww2 1#
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.># 0# y) of wild2 {
                        GHC.Types.False
                        -> letrec {
                             go10 :: GHC.Prim.Int# -> [[GHC.Types.Char]]
                               {- Arity: 1, Strictness: <L,U> -}
                             = \ (x1 :: GHC.Prim.Int#) ->
                               GHC.Types.:
                                 @ [GHC.Types.Char]
                                 (GHC.CString.unpackAppendCString#
                                    "__i"#
                                    (case GHC.Show.$wshowSignedInt
                                            0#
                                            x1
                                            (GHC.Types.[]
                                               @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                                     GHC.Types.: @ GHC.Types.Char ww5 ww6 }))
                                 (case GHC.Prim.tagToEnum#
                                         @ GHC.Types.Bool
                                         (GHC.Prim.==# x1 y) of wild3 {
                                    GHC.Types.False -> go10 (GHC.Prim.+# x1 1#)
                                    GHC.Types.True -> GHC.Types.[] @ [GHC.Types.Char] })
                           } in
                           go10 0#
                        GHC.Types.True -> GHC.Types.[] @ [GHC.Types.Char] } } } }) -}
"SPEC/Core $fEqL @ Token" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                     Lexer.Token)
  Parser.$fEqL @ Lexer.Token $dEq = Core.$s$fEqL
"SPEC/Core $fEqL_$c/= @ Token" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                          Lexer.Token)
  Parser.$fEqL_$c/= @ Lexer.Token $dEq = Core.$s$fEqL_$s$fEqL_$c/=
"SPEC/Core $fEqL_$c== @ Token" [ALWAYS] forall ($dEq :: GHC.Classes.Eq
                                                          Lexer.Token)
  Parser.$fEqL_$c== @ Lexer.Token $dEq = Core.$s$fEqL_$s$fEqL_$c==
"SPEC/Core $fShow(,)_$cshowList @ [Char] @ [Char]" [ALWAYS] forall ($dShow1 :: GHC.Show.Show
                                                                                 [GHC.Types.Char])
                                                                   ($dShow :: GHC.Show.Show
                                                                                [GHC.Types.Char])
  GHC.Show.$fShow(,)_$cshowList @ [GHC.Types.Char]
                                @ [GHC.Types.Char]
                                $dShow
                                $dShow1
  = Core.$s$fShow(,)_$s$fShow(,)_$cshowList1
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

