
==================== FINAL INTERFACE ====================
2018-06-09 19:12:14.479772 UTC

interface HaskellCircuits-0.1.0.0-3mIW93ol3alH6nhlDJ7Hzo:ToSystemC 8002
  interface hash: 3a45f983cffe29c1fd9591a9667fa341
  ABI hash: 1b99009a89807cc2d802fba543f21942
  export-list hash: f5c882500f60c061935f8c19725064c8
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 91cd76246f60d900fce8e309e594df82
  sig of: Nothing
  used TH splices: False
  where
exports:
  ToSystemC.changeIfMain
  ToSystemC.closingBraces
  ToSystemC.componentToSystemC
  ToSystemC.endif
  ToSystemC.ifndef
  ToSystemC.includeInstances
  ToSystemC.includeSystemC
  ToSystemC.inputs
  ToSystemC.instanceDeclaration
  ToSystemC.instanceFromFile
  ToSystemC.interSignal
  ToSystemC.intermediarySignals
  ToSystemC.makeConstBinFile
  ToSystemC.makeConstDecFile
  ToSystemC.makeConstHexFile
  ToSystemC.makeConstStrFile
  ToSystemC.makeForkFile
  ToSystemC.makeSpecialFile
  ToSystemC.makeSpecialFileArith
  ToSystemC.makeSpecialFileCat
  ToSystemC.makeSpecialFileLogic
  ToSystemC.makeSpecialFileMRest
  ToSystemC.makeSpecialFileNot
  ToSystemC.makeSpecialFileSli
  ToSystemC.makeTypeInput
  ToSystemC.makeTypeOutput
  ToSystemC.makeTypePure
  ToSystemC.makeTypeSignal
  ToSystemC.makeTypeVector
  ToSystemC.outputs
  ToSystemC.procedureSignals
  ToSystemC.procedureToSystemC
  ToSystemC.processDeclaration
  ToSystemC.scCtor
  ToSystemC.scModule
  ToSystemC.scThread
  ToSystemC.sconnections
  ToSystemC.toHeader
  ToSystemC.toSystemC
  ToSystemC.topLevel
module dependencies: Aux Components Function Lexer Parser
                     TransformationMonad Types
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      transformers-0.5.2.0@transformers-0.5.2.0
                      utf8-string-1.0.1.1@utf8-string-1.0.1.1-1DpjxLeTvGg7ttZZojxJR5
orphans: HaskellCircuits-0.1.0.0-3mIW93ol3alH6nhlDJ7Hzo:Parser
         base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
import  -/  Aux 19066227c591c3746fddc67fa02fb706
  exports: 3c8f8ea3f0430e062a77584d5651b09f
  just 8567f0152f7fceaf161de552d8c51a58
  ok 8b975d9be36db7c5fc6bef7069b4d150
import  -/  Components 257a0cfffc068c97f9e15323cdf63c39
  exports: 6f607770d5ef399b4670f10bc6255744
import  -/  Lexer c6174f684585218aa184faedf4ab7f58
  exports: c0fea5fa50c83f412bfcd8243e0a6172
  L aeabd488767cc0257d48246b31a3c8eb
  NoLoc 1192b825a1bbdd5c089dbb8aeba295bc
import  -/  Parser f25442964b616089abfc3d7b05acabc3
  exports: 518f87c40b39394a3af3d07ea4f63fc3
import  -/  TransformationMonad 9a41a082a5198ad8166e58e36aa95114
  exports: a2f2911707e7fb33be1f875278a27f62
  addSystemCFile 3dc53e7627b3226cd384c0224f42cd72
  cont 15ef40196d547ee7c1c037a71afb7acd
  cont1 863999094999483849ffafa9f0237d73
  debug f46f4739191d885fb6b73c306966ed95
  debugs 49755239830dc452d4e4b0a31d3ed2f3
  getComponents 38dd7bff2f354a252badf35042538148
  noRet f27a766fc8906feee50ef508c6ef3ff0
  ret 8f8ddfb5f423bc7b265fdcea5121253c
  searchComponent 33483cce5ecac629c9e4358ef89e1cd1
  throw fd22a7ad31f6177a0a7c3d0b74f70074
import  -/  Types 757470cca10fe0c859acdd7db069deaa
  exports: 34058aae7a6fb4ed664b025b184c161d
  BLOB 32a7ddec4ac03f3caa8c0ecc1f97980b
  BREAK f77429305a1643e9ba03fa413a0d1c8b
  Bit 0aab82c6cc5be9036a05f222d64d8c22
  BitVec cfe16d092987a9210a1b4afcbc43986a
  C d7dce717eb86a00d084af1bb10012bc1
  CConn 4d6bbc82c553fb41fbacc4cdf5b0ccd3
  CInput b15cfca94f4dc3ad079e15edc56ec4f5
  CLEARV 8c1c4f648611c91233149a20c4cb6860
  COND a584a2dfe76c83286f6d8081133a3271
  COPY 5999e9350d458a1dfd327ca734dced75
  COPYV b841039bfa65950019fe249cedf007a3
  COutput 12ee0a46c72555244884369b26156a79
  CProc 0476a9cdd54a10555b6e6674e2dabfae
  CProcUnit 0476a9cdd54a10555b6e6674e2dabfae
  ConstBinI 9a85677d9e11b0b8bd2ccd3bde8bc9a5
  ConstDecI 1ab4e8ed42673b9c3ef3199b740bffc2
  ConstHexI 75da09479eb877b7bd02b589e3a0f1b3
  ConstStrI 44036cb791d80fab9de16ab3980597fd
  DESTROY 6171338292db8983d96165584b3319bb
  DESTROYV 43cece2b973e67e35cecf1e26787569c
  ELSE 9d984aea5ea1e4ff8d8251558c49fc31
  ELSEIF 56807093db360aca03eea3e06247e253
  FBin 975f77e4c3e62d783cb5649621fda325
  FDec a2084987e9febf473fb853fd698e7ce1
  FForeverWait 937312539964504697af04e29f3464c8
  FHex 629ee593c6950aa8a26c32ab09dc76ee
  FType 8b9bd064502b5d5eb590940bf149b133
  FifoI 7006349d4b199cd1bba42ab41080578e
  File 7880caf15877d8eb60f0074a434f4fff
  ForkI 240a61bfc5c93f35049f26a7daf984d8
  GET f34d479faa4094220c4cc877058cb150
  GETINPUT 7bd6cb49a022652815001ec481038aef
  GETSTREAMSAFE 33f1345d34a3294ef954e8a05259bd9a
  GETSTREAMV c6c719d8d57f7c0b60f64e25fa8562af
  I 9a19eef980603aa0a5e07ddad1e80cb4
  IF fe54593d89b104d01b9d6903c0a57f55
  ImpossibleConnection 3ef141024e648fbefd7167f39a1e2892
  LOOP 56989acce685e08b2700859f89ae55ae
  MAKEV bc3818cf2763b776609b8f4cd18736e2
  Name 4bbc3da5ef1d02db55291a2a33a7c002
  NameId 206aacfbf28fd58314dcb848f8801aed
  NameId 4aa1b762a773a120e02f482bc8631e08
  Nat d9bb63a66ef2c7ee29fdfa61f0058ffd
  PCOPY d71ce2b7cddf07eb4fbfe982b6892a73
  PUT f8321bc111a9ee990f6a165d1905ff22
  PUTOUTPUT 35553dcce06c4dabfd537bc4f699eef6
  PUTOUTPUTSTREAM bce311dffc03f194299849080c6d09ff
  PUTOUTPUTSTREAMV 7e0d0d7be530f343c2d1e9263d83f200
  PUTSTATE be4191f7db030b1ba33b4c6072705b14
  PUTSTREAM 393a1536d20d70631ba8e6d82c27fa15
  PUTV 4f46ec57bd5a380078968aafbd7aa002
  RESTV 4fff6ea4a1bf3d2cae559405cbcf3cca
  SAVE da94a5a487227f1b2edde854fa22791f
  SAVEV a059e762ae9f5628609e5cd525c2f235
  SWITCH 74a8432813643de5c2f27f805d74b3b5
  SpecialI 02e1dae7178509249efdff774860103f
  Stream 7ba2ceb5dafc7e4c7a3c3232086b9552
  TComp 512c2abf100124d914051cfc1b1240b4
  TErr bd3b322a3f06039eedd1569007f14c0c
  TInst 17bef6e9e2329998cd16deab3a7bfd4a
  TM f4ba4f96d9f8dffc5235169391939992
  TMM a7c38748359d680c785978249d7123ff
import  -/  base-4.9.1.0:Control.Monad a6784c5dab0d75c63dabec5a37843f98
import  -/  base-4.9.1.0:Data.Char 01433d23661edb6e5ef1536ef1e6774c
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:Data.String b34df69c7b6358cd40a379c8a0a78dcf
import  -/  base-4.9.1.0:Data.Traversable 556020d7cf3c4a34a774600512918a37
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Real 82e4e59051a13dba1da63e1e970a69e6
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:GHC.Unicode a175ecf20bf1272d9ae31337e7da43ab
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  containers-0.5.7.1@containers-0.5.7.1:Data.Map 20d4ffbee41965d03d6a989425473dc4
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
09afaaf946897d3c4a0ee63baea299d0
  $s$fShow[]2 ::
    ([GHC.Types.Char], Types.C) -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ (w3 :: ([GHC.Types.Char], Types.C))
                   (w4 :: GHC.Base.String)[OneShot] ->
                 case w3 of ww { (,) ww1 ww2 ->
                 GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows7
                   (GHC.Types.:
                      @ GHC.Types.Char
                      GHC.Show.shows6
                      (GHC.Show.showLitString
                         ww1
                         (GHC.Types.:
                            @ GHC.Types.Char
                            GHC.Show.shows6
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.shows5
                               (GHC.Show.$fShow(,)_$sgo
                                  (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 w4)
                                  (\ (w2 :: GHC.Base.String) ->
                                   case ww2 of ww4 { Types.C ww3 ww5 ww6 ww7 ww8 ww9 ->
                                   Types.$w$cshowsPrec 0# ww3 ww5 ww6 ww7 ww8 ww9 w2 })
                                  (GHC.Types.[] @ GHC.Show.ShowS)))))) }) -}
58407ba17454d89637f01037b021ea5c
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   ToSystemC.$trModule2
                   ToSystemC.$trModule1) -}
b7eea4f60e2b758c922686365cd83a95
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "ToSystemC"#) -}
5179d6b90b8a2d2bc271ace45ed1583a
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "HaskellCircuits-0.1.0.0-3mIW93ol3alH6nhlDJ7Hzo"#) -}
36f477024769eb951d87a3203c83a6de
  $w$smakeConstBinFile ::
    Types.Id
    -> Types.Name
    -> [GHC.Types.Char]
    -> [GHC.Types.Char]
    -> Types.FType
    -> (# [GHC.Types.Char], [GHC.Types.Char] #)
  {- Arity: 5, Strictness: <L,1*U(U)><L,1*U><L,1*U><L,U><L,1*U>,
     Inline: [0] -}
312e4e934bd740af6087108fc7b2ad1f
  $w$smakeConstDecFile ::
    Types.Id
    -> Types.Name
    -> GHC.Types.Int
    -> [GHC.Types.Char]
    -> Types.FType
    -> (# [GHC.Types.Char], [GHC.Types.Char] #)
  {- Arity: 5, Strictness: <L,1*U(U)><L,1*U><L,1*U(U)><L,U><L,1*U>,
     Inline: [0] -}
985d696d2977ef98dc5ac19b52c219d2
  $w$smakeConstHexFile ::
    Types.Id
    -> Types.Name
    -> [GHC.Types.Char]
    -> [GHC.Types.Char]
    -> Types.FType
    -> (# [GHC.Types.Char], [GHC.Types.Char] #)
  {- Arity: 5, Strictness: <L,1*U(U)><L,1*U><L,1*U><L,U><L,1*U>,
     Inline: [0] -}
8dd8041ecb610f0be2864d58dd4a688d
  $w$smakeConstStrFile ::
    Types.Id
    -> Types.Name
    -> [Types.FCons]
    -> [GHC.Types.Char]
    -> Types.FType
    -> (# [GHC.Types.Char], [GHC.Types.Char] #)
  {- Arity: 5, Strictness: <L,1*U(U)><L,1*U><L,1*U><L,U><L,1*U>,
     Inline: [0] -}
b9be79efb868ccd042a9afe63a25b8b5
  $w$smakeSpecialFile ::
    Types.Id
    -> Types.Name
    -> [(GHC.Base.String, Types.FType)]
    -> GHC.Base.String
    -> Types.FType
    -> [GHC.Types.Int]
    -> (# [GHC.Types.Char], GHC.Base.String #)
  {- Arity: 6, Strictness: <L,1*U(U)><S,U><S,1*U><L,U><L,U><L,1*U>,
     Inline: [0] -}
19f4ee67cc2926cc850d1946d2edae75
  $w$smakeSpecialFileArith ::
    Types.Id
    -> Types.Name
    -> [(GHC.Base.String, Types.FType)]
    -> GHC.Base.String
    -> Types.FType
    -> (# [GHC.Types.Char], [GHC.Types.Char] #)
  {- Arity: 5, Strictness: <L,1*U(U)><L,U><S,1*U><L,U><L,U>,
     Inline: [0] -}
6b5b1abc14ddc7becc4a9f1303394c82
  $w$smakeSpecialFileCat ::
    Types.Id
    -> Types.Name
    -> [(GHC.Base.String, Types.FType)]
    -> GHC.Base.String
    -> Types.FType
    -> (# [GHC.Types.Char], GHC.Base.String #)
  {- Arity: 5, Strictness: <L,1*U(U)><L,1*U><S,1*U><L,U><L,U>,
     Inline: [0] -}
2ae78fd1495c983e131b9003ff79f6a9
  $w$smakeSpecialFileLogic ::
    Types.Id
    -> Types.Name
    -> [(GHC.Base.String, Types.FType)]
    -> GHC.Base.String
    -> Types.FType
    -> (# [GHC.Types.Char], [GHC.Types.Char] #)
  {- Arity: 5, Strictness: <L,1*U(U)><L,U><S,1*U><L,U><L,U>,
     Inline: [0] -}
b95225b1526fab8bf8af411bbcc90e2b
  $w$smakeSpecialFileMRest ::
    Types.Id
    -> Types.Name
    -> [(GHC.Base.String, Types.FType)]
    -> GHC.Base.String
    -> Types.FType
    -> [GHC.Types.Int]
    -> (# [GHC.Types.Char], GHC.Base.String #)
  {- Arity: 6, Strictness: <L,1*U(U)><L,1*U><S,1*U><L,U><L,U><S,1*U>,
     Inline: [0] -}
9482e333bc8e9886b67e736aa7fa852d
  $w$smakeSpecialFileNot ::
    Types.Id
    -> Types.Name
    -> [(GHC.Base.String, Types.FType)]
    -> GHC.Base.String
    -> Types.FType
    -> (# [GHC.Types.Char], [GHC.Types.Char] #)
  {- Arity: 5, Strictness: <L,1*U(U)><L,1*U><S,1*U><L,U><L,U>,
     Inline: [0] -}
b5e3e00a23105d99df79033c6bb6a455
  $w$smakeSpecialFileSli ::
    Types.Id
    -> Types.Name
    -> [(GHC.Base.String, Types.FType)]
    -> GHC.Base.String
    -> Types.FType
    -> [GHC.Types.Int]
    -> (# [GHC.Types.Char], GHC.Base.String #)
  {- Arity: 6, Strictness: <L,1*U(U)><L,1*U><S,1*U><L,U><L,U><S,1*U>,
     Inline: [0] -}
56b3ed61a6e9bb6928cd9a75c57f4711
  $wcomponentToSystemC ::
    Types.Name
    -> [Types.TInst]
    -> [Types.CInput]
    -> Types.COutput
    -> [Types.CConn]
    -> Types.CProc
    -> Types.TMM ()
  {- Arity: 6, Strictness: <L,U><L,U><L,1*U><L,U><L,U><L,U>,
     Inline: [0] -}
d49398dd1a4c5bd12c6ff8a8d742bbbe
  $wgetNameFromInstance ::
    Types.Id -> Types.Name -> Types.I -> Types.Name
  {- Arity: 3, Strictness: <L,1*U(U)><L,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Types.Id)
                   (ww1 :: Types.Name)
                   (ww2 :: Types.I) ->
                 case ww2 of wild {
                   DEFAULT -> ww1
                   Types.ConstBinI ds ds1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        ww1
                        (case ww of ww3 { GHC.Types.I# ww4 ->
                         case GHC.Show.$wshowSignedInt
                                0#
                                ww4
                                (GHC.Types.[] @ GHC.Types.Char) of ww5 { (#,#) ww6 ww7 ->
                         GHC.Base.++
                           @ GHC.Types.Char
                           (GHC.Types.: @ GHC.Types.Char ww6 ww7)
                           ToSystemC.includeInstances2 } })
                   Types.ConstHexI ds ds1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        ww1
                        (case ww of ww3 { GHC.Types.I# ww4 ->
                         case GHC.Show.$wshowSignedInt
                                0#
                                ww4
                                (GHC.Types.[] @ GHC.Types.Char) of ww5 { (#,#) ww6 ww7 ->
                         GHC.Base.++
                           @ GHC.Types.Char
                           (GHC.Types.: @ GHC.Types.Char ww6 ww7)
                           ToSystemC.includeInstances2 } })
                   Types.ConstDecI ds ds1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        ww1
                        (case ww of ww3 { GHC.Types.I# ww4 ->
                         case GHC.Show.$wshowSignedInt
                                0#
                                ww4
                                (GHC.Types.[] @ GHC.Types.Char) of ww5 { (#,#) ww6 ww7 ->
                         GHC.Base.++
                           @ GHC.Types.Char
                           (GHC.Types.: @ GHC.Types.Char ww6 ww7)
                           ToSystemC.includeInstances2 } })
                   Types.ConstStrI ds ds1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        ww1
                        (case ww of ww3 { GHC.Types.I# ww4 ->
                         case GHC.Show.$wshowSignedInt
                                0#
                                ww4
                                (GHC.Types.[] @ GHC.Types.Char) of ww5 { (#,#) ww6 ww7 ->
                         GHC.Base.++
                           @ GHC.Types.Char
                           (GHC.Types.: @ GHC.Types.Char ww6 ww7)
                           ToSystemC.includeInstances2 } })
                   Types.SpecialI ds ds1 ds2
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        ww1
                        (case ww of ww3 { GHC.Types.I# ww4 ->
                         case GHC.Show.$wshowSignedInt
                                0#
                                ww4
                                (GHC.Types.[] @ GHC.Types.Char) of ww5 { (#,#) ww6 ww7 ->
                         GHC.Base.++
                           @ GHC.Types.Char
                           (GHC.Types.: @ GHC.Types.Char ww6 ww7)
                           ToSystemC.includeInstances2 } })
                   Types.FifoI ds ds1 -> GHC.Types.[] @ GHC.Types.Char }) -}
ab795bebf086e76680fdb31f2778c72c
  $wgo ::
    [Types.TComp]
    -> Types.TState -> (# [GHC.Base.Maybe ()], Types.TState #)
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
4299535d71a7b87257ca136f7a6453e3
  $winstanceFromFile ::
    Types.Id -> Types.Name -> Types.I -> Types.TM ()
  {- Arity: 3, Strictness: <L,1*U(U)><L,U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: Types.Id)
                   (ww1 :: Types.Name)
                   (ww2 :: Types.I) ->
                 case ww2 of wild {
                   DEFAULT
                   -> ToSystemC.instanceFromFile4
                        `cast`
                      (Trans
                           (<Types.TState>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                          <((), Types.TState)>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N)))
                   Types.ConstBinI bin out
                   -> let {
                        file :: Types.File
                        = case out of ww3 { (,) ww4 ww5 ->
                          case ToSystemC.$w$smakeConstBinFile
                                 ww
                                 ww1
                                 bin
                                 ww4
                                 ww5 of ww6 { (#,#) ww7 ww8 ->
                          (ww7, ww8) } }
                      } in
                      (\ (eta :: Types.TState) ->
                       (GHC.Tuple.(),
                        case eta of wild1 { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                        Types.TState
                          ds
                          ds1
                          ds2
                          ds3
                          ds4
                          ds5
                          ds6
                          ds7
                          ds8
                          ds9
                          ds10
                          ds11
                          ds12
                          ds13
                          ds14
                          (GHC.Types.: @ Types.File file ds15)
                          ds16
                          ds17 }))
                        `cast`
                      (Trans
                           (<Types.TState>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                          <((), Types.TState)>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N)))
                   Types.ConstHexI hex out
                   -> let {
                        file :: Types.File
                        = case out of ww3 { (,) ww4 ww5 ->
                          case ToSystemC.$w$smakeConstHexFile
                                 ww
                                 ww1
                                 hex
                                 ww4
                                 ww5 of ww6 { (#,#) ww7 ww8 ->
                          (ww7, ww8) } }
                      } in
                      (\ (eta :: Types.TState) ->
                       (GHC.Tuple.(),
                        case eta of wild1 { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                        Types.TState
                          ds
                          ds1
                          ds2
                          ds3
                          ds4
                          ds5
                          ds6
                          ds7
                          ds8
                          ds9
                          ds10
                          ds11
                          ds12
                          ds13
                          ds14
                          (GHC.Types.: @ Types.File file ds15)
                          ds16
                          ds17 }))
                        `cast`
                      (Trans
                           (<Types.TState>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                          <((), Types.TState)>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N)))
                   Types.ConstDecI dec out
                   -> let {
                        file :: Types.File
                        = case out of ww3 { (,) ww4 ww5 ->
                          case ToSystemC.$w$smakeConstDecFile
                                 ww
                                 ww1
                                 dec
                                 ww4
                                 ww5 of ww6 { (#,#) ww7 ww8 ->
                          (ww7, ww8) } }
                      } in
                      (\ (eta :: Types.TState) ->
                       (GHC.Tuple.(),
                        case eta of wild1 { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                        Types.TState
                          ds
                          ds1
                          ds2
                          ds3
                          ds4
                          ds5
                          ds6
                          ds7
                          ds8
                          ds9
                          ds10
                          ds11
                          ds12
                          ds13
                          ds14
                          (GHC.Types.: @ Types.File file ds15)
                          ds16
                          ds17 }))
                        `cast`
                      (Trans
                           (<Types.TState>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                          <((), Types.TState)>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N)))
                   Types.ConstStrI str out
                   -> let {
                        file :: Types.File
                        = case out of ww3 { (,) ww4 ww5 ->
                          case ToSystemC.$w$smakeConstStrFile
                                 ww
                                 ww1
                                 str
                                 ww4
                                 ww5 of ww6 { (#,#) ww7 ww8 ->
                          (ww7, ww8) } }
                      } in
                      (\ (eta :: Types.TState) ->
                       (GHC.Tuple.(),
                        case eta of wild1 { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                        Types.TState
                          ds
                          ds1
                          ds2
                          ds3
                          ds4
                          ds5
                          ds6
                          ds7
                          ds8
                          ds9
                          ds10
                          ds11
                          ds12
                          ds13
                          ds14
                          (GHC.Types.: @ Types.File file ds15)
                          ds16
                          ds17 }))
                        `cast`
                      (Trans
                           (<Types.TState>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                          <((), Types.TState)>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N)))
                   Types.SpecialI inps out args
                   -> case Data.OldList.isPrefixOf
                             @ GHC.Types.Char
                             GHC.Classes.$fEqChar
                             ToSystemC.instanceFromFile3
                             ww1 of wild1 {
                        GHC.Types.False
                        -> case Data.OldList.isPrefixOf
                                  @ GHC.Types.Char
                                  GHC.Classes.$fEqChar
                                  ToSystemC.instanceFromFile2
                                  ww1 of wild2 {
                             GHC.Types.False
                             -> case Data.OldList.isPrefixOf
                                       @ GHC.Types.Char
                                       GHC.Classes.$fEqChar
                                       ToSystemC.instanceFromFile1
                                       ww1 of wild3 {
                                  GHC.Types.False
                                  -> let {
                                       file :: Types.File
                                       = case out of ww3 { (,) ww4 ww5 ->
                                         case ToSystemC.$w$smakeSpecialFile
                                                ww
                                                ww1
                                                inps
                                                ww4
                                                ww5
                                                args of ww6 { (#,#) ww7 ww8 ->
                                         (ww7, ww8) } }
                                     } in
                                     (\ (eta :: Types.TState) ->
                                      (GHC.Tuple.(),
                                       case eta of wild4 { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                                       Types.TState
                                         ds
                                         ds1
                                         ds2
                                         ds3
                                         ds4
                                         ds5
                                         ds6
                                         ds7
                                         ds8
                                         ds9
                                         ds10
                                         ds11
                                         ds12
                                         ds13
                                         ds14
                                         (GHC.Types.: @ Types.File file ds15)
                                         ds16
                                         ds17 }))
                                       `cast`
                                     (Trans
                                          (<Types.TState>_R
                                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                         <((), Types.TState)>_R))
                                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                    <Types.TState>_N
                                                    <Data.Functor.Identity.Identity>_R
                                                    <()>_N)))
                                  GHC.Types.True
                                  -> ToSystemC.instanceFromFile4
                                       `cast`
                                     (Trans
                                          (<Types.TState>_R
                                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                         <((), Types.TState)>_R))
                                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                    <Types.TState>_N
                                                    <Data.Functor.Identity.Identity>_R
                                                    <()>_N))) }
                             GHC.Types.True
                             -> ToSystemC.instanceFromFile4
                                  `cast`
                                (Trans
                                     (<Types.TState>_R
                                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                    <((), Types.TState)>_R))
                                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                               <Types.TState>_N
                                               <Data.Functor.Identity.Identity>_R
                                               <()>_N))) }
                        GHC.Types.True
                        -> ToSystemC.instanceFromFile4
                             `cast`
                           (Trans
                                (<Types.TState>_R
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                               <((), Types.TState)>_R))
                                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                          <Types.TState>_N
                                          <Data.Functor.Identity.Identity>_R
                                          <()>_N))) }
                   Types.ForkI n1 inp outs
                   -> let {
                        file :: Types.File
                        = case inp of ww3 { (,) ww4 ww5 ->
                          case ToSystemC.$wmakeForkFile
                                 ww1
                                 ww5
                                 outs of ww6 { (#,#) ww7 ww8 ->
                          (ww7, ww8) } }
                      } in
                      (\ (eta :: Types.TState) ->
                       (GHC.Tuple.(),
                        case eta of wild1 { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                        Types.TState
                          ds
                          ds1
                          ds2
                          ds3
                          ds4
                          ds5
                          ds6
                          ds7
                          ds8
                          ds9
                          ds10
                          ds11
                          ds12
                          ds13
                          ds14
                          (GHC.Types.: @ Types.File file ds15)
                          ds16
                          ds17 }))
                        `cast`
                      (Trans
                           (<Types.TState>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                          <((), Types.TState)>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <Types.TState>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <()>_N))) }) -}
ee2065733768fcf6ab19efd511dfaa9c
  $wintSig ::
    Types.CompName
    -> Types.Name
    -> Types.Id
    -> GHC.Base.String
    -> Types.FType
    -> Types.Name
    -> Types.Id
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 8,
     Strictness: <S,U><S,U><L,1*U(U)><L,1*U><L,1*U><L,U><L,1*U(U)><L,U>,
     Inline: [0],
     Unfolding: (\ (ww :: Types.CompName)
                   (ww1 :: Types.Name)
                   (ww2 :: Types.Id)
                   (ww3 :: GHC.Base.String)
                   (ww4 :: Types.FType)
                   (ww5 :: Types.Name)
                   (ww6 :: Types.Id)
                   (ww7 :: GHC.Base.String) ->
                 let {
                   comp' :: Types.Name
                   = case GHC.Base.eqString ww ToSystemC.changeIfMain2 of wild {
                       GHC.Types.False -> ww GHC.Types.True -> ToSystemC.changeIfMain1 }
                 } in
                 case GHC.Base.eqString ww1 comp' of wild {
                   GHC.Types.False
                   -> case Data.OldList.isPrefixOf
                             @ GHC.Types.Char
                             GHC.Classes.$fEqChar
                             ToSystemC.intermediarySignals2
                             ww1 of wild1 {
                        GHC.Types.False
                        -> case GHC.Base.eqString ww5 comp' of wild2 {
                             GHC.Types.False
                             -> case Data.OldList.isPrefixOf
                                       @ GHC.Types.Char
                                       GHC.Classes.$fEqChar
                                       ToSystemC.intermediarySignals2
                                       ww5 of wild3 {
                                  GHC.Types.False
                                  -> GHC.Base.++
                                       @ GHC.Types.Char
                                       (ToSystemC.makeTypeSignal ww4)
                                       (GHC.CString.unpackAppendCString#
                                          " "#
                                          (GHC.Base.++
                                             @ GHC.Types.Char
                                             (ToSystemC.interSignal_$sinterSignal
                                                ww1
                                                ww2
                                                ww3
                                                ww5
                                                ww6
                                                ww7)
                                             ToSystemC.inputs1))
                                  GHC.Types.True -> GHC.Types.[] @ GHC.Types.Char }
                             GHC.Types.True -> GHC.Types.[] @ GHC.Types.Char }
                        GHC.Types.True -> GHC.Types.[] @ GHC.Types.Char }
                   GHC.Types.True -> GHC.Types.[] @ GHC.Types.Char }) -}
7e7f2ae6b3a52876a6fde06646d3f2fe
  $wmakeConstBinFile ::
    GHC.Show.Show t =>
    t
    -> Types.Name
    -> [GHC.Types.Char]
    -> [GHC.Types.Char]
    -> Types.FType
    -> (# [GHC.Types.Char], [GHC.Types.Char] #)
  {- Arity: 6,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><L,1*U><L,1*U><L,U><L,1*U>,
     Inline: [0] -}
939b3b209c78b2b139ec84d3fa5cf19f
  $wmakeConstDecFile ::
    (GHC.Show.Show t, GHC.Show.Show t1) =>
    t1
    -> Types.Name
    -> t
    -> [GHC.Types.Char]
    -> Types.FType
    -> (# [GHC.Types.Char], [GHC.Types.Char] #)
  {- Arity: 7,
     Strictness: <L,1*U(A,1*C1(U),A)><L,1*U(A,1*C1(U),A)><L,U><L,1*U><L,U><L,U><L,1*U>,
     Inline: [0] -}
0aaa46faf638091be183bad8c1932f09
  $wmakeConstHexFile ::
    GHC.Show.Show t =>
    t
    -> Types.Name
    -> [GHC.Types.Char]
    -> [GHC.Types.Char]
    -> Types.FType
    -> (# [GHC.Types.Char], [GHC.Types.Char] #)
  {- Arity: 6,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><L,1*U><L,1*U><L,U><L,1*U>,
     Inline: [0] -}
1bbb844015c7f8e10649727682ad19b2
  $wmakeConstStrFile ::
    GHC.Show.Show t =>
    t
    -> Types.Name
    -> [Types.FCons]
    -> [GHC.Types.Char]
    -> Types.FType
    -> (# [GHC.Types.Char], [GHC.Types.Char] #)
  {- Arity: 6,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><L,1*U><L,1*U><L,U><L,1*U>,
     Inline: [0] -}
f223828d9bceb8e635fc879d136a6636
  $wmakeForkFile ::
    Types.Name
    -> Types.FType
    -> [Types.COutput]
    -> (# Types.Name, GHC.Base.String #)
  {- Arity: 3, Strictness: <L,U><L,U><L,U>, Inline: [0] -}
a727bd858303f865ebdf37e48f825e59
  $wmakeInput :: [GHC.Types.Char] -> Types.FType -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <L,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: [GHC.Types.Char]) (ww1 :: Types.FType) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (ToSystemC.makeTypeInput ww1)
                   (GHC.CString.unpackAppendCString#
                      " "#
                      (GHC.Base.++ @ GHC.Types.Char ww ToSystemC.inputs1))) -}
bf68a623650da458bda87606eb6b4ee1
  $wmakeOutput :: [GHC.Types.Char] -> Types.FType -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <L,1*U><S,1*U>, Inline: [0],
     Unfolding: (\ (ww :: [GHC.Types.Char]) (ww1 :: Types.FType) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   (ToSystemC.makeTypeOutput ww1)
                   (GHC.CString.unpackAppendCString#
                      " "#
                      (GHC.Base.++ @ GHC.Types.Char ww ToSystemC.inputs1))) -}
1f5e8153db22b60b8a757e464c0264ab
  $wmakeSpecialFile ::
    GHC.Show.Show t =>
    t
    -> Types.Name
    -> [(GHC.Base.String, Types.FType)]
    -> GHC.Base.String
    -> Types.FType
    -> [GHC.Types.Int]
    -> (# [GHC.Types.Char], GHC.Base.String #)
  {- Arity: 7,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><S,U><S,1*U><L,U><L,U><L,1*U>,
     Inline: [0] -}
78a0959b2174c2a3447c574d80ea8975
  $wmakeSpecialFileArith ::
    GHC.Show.Show t =>
    t
    -> Types.Name
    -> [(GHC.Base.String, Types.FType)]
    -> GHC.Base.String
    -> Types.FType
    -> (# [GHC.Types.Char], [GHC.Types.Char] #)
  {- Arity: 6,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><L,U><S,1*U><L,U><L,U>,
     Inline: [0] -}
36e8b59b1e0424be20eff40425b92ead
  $wmakeSpecialFileCat ::
    GHC.Show.Show t =>
    t
    -> Types.Name
    -> [(GHC.Base.String, Types.FType)]
    -> GHC.Base.String
    -> Types.FType
    -> (# [GHC.Types.Char], GHC.Base.String #)
  {- Arity: 6,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><L,1*U><S,1*U><L,U><L,U>,
     Inline: [0] -}
061cceb781c4246cc28339b5c7e889f9
  $wmakeSpecialFileLogic ::
    GHC.Show.Show t =>
    t
    -> Types.Name
    -> [(GHC.Base.String, Types.FType)]
    -> GHC.Base.String
    -> Types.FType
    -> (# [GHC.Types.Char], [GHC.Types.Char] #)
  {- Arity: 6,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><L,U><S,1*U><L,U><L,U>,
     Inline: [0] -}
f25906244f2ad8a4050bd00d7ce96170
  $wmakeSpecialFileMRest ::
    GHC.Show.Show t =>
    t
    -> Types.Name
    -> [(GHC.Base.String, Types.FType)]
    -> GHC.Base.String
    -> Types.FType
    -> [GHC.Types.Int]
    -> (# [GHC.Types.Char], GHC.Base.String #)
  {- Arity: 7,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><L,1*U><S,1*U><L,U><L,U><S,1*U>,
     Inline: [0] -}
68d58914e8f2cd0c712ebaa118bb6e8d
  $wmakeSpecialFileNot ::
    GHC.Show.Show t =>
    t
    -> Types.Name
    -> [(GHC.Base.String, Types.FType)]
    -> GHC.Base.String
    -> Types.FType
    -> (# [GHC.Types.Char], [GHC.Types.Char] #)
  {- Arity: 6,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><L,1*U><S,1*U><L,U><L,U>,
     Inline: [0] -}
9b92f52720860d3f9d1273431fdce797
  $wmakeSpecialFileSli ::
    (GHC.Show.Show t, GHC.Show.Show t1) =>
    t1
    -> Types.Name
    -> [(GHC.Base.String, Types.FType)]
    -> GHC.Base.String
    -> Types.FType
    -> [t]
    -> (# [GHC.Types.Char], GHC.Base.String #)
  {- Arity: 8,
     Strictness: <L,U(A,C(U),A)><L,1*U(A,1*C1(U),A)><L,U><L,1*U><S,1*U><L,U><L,U><S,1*U>,
     Inline: [0] -}
f74fb5f2dad0316f60dc2cb8af702800
  $wtoSystemC ::
    GHC.Base.String
    -> [[GHC.Types.Int]]
    -> Types.TState
    -> (# GHC.Base.Maybe (), Types.TState #)
  {- Arity: 3,
     Strictness: <L,U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: GHC.Base.String)
                   (w1 :: [[GHC.Types.Int]])
                   (w2 :: Types.TState) ->
                 let {
                   ds :: [Types.TComp]
                   = case w2 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                     ds11 }
                 } in
                 case TransformationMonad.$wsearchComponent
                        ToSystemC.changeIfMain2
                        (case w2 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                         Types.TState
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           ds7
                           (GHC.Types.:
                              @ Types.TLog
                              (Types.TLogDebug
                                 (GHC.Show.showList__
                                    @ ([GHC.Types.Char], Types.C)
                                    ToSystemC.$s$fShow[]2
                                    ds
                                    (GHC.Types.[] @ GHC.Types.Char))
                                 ds5)
                              (GHC.Types.:
                                 @ Types.TLog
                                 (Types.TLogDebug
                                    (GHC.CString.unpackAppendCString#
                                       "comps "#
                                       (case GHC.List.$wlenAcc
                                               @ (Types.Name, Types.C)
                                               ds
                                               0# of ww2 { DEFAULT ->
                                        case GHC.Show.$wshowSignedInt
                                               0#
                                               ww2
                                               (GHC.Types.[]
                                                  @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                                        GHC.Types.: @ GHC.Types.Char ww5 ww6 } }))
                                    ds5)
                                 ds8))
                           ds9
                           ds10
                           ds11
                           ds12
                           ds13
                           ds14
                           ds15
                           ds16
                           ds17
                           ds18 }) of ww { (#,#) ww1 ww2 ->
                 case ww1 of wild {
                   GHC.Base.Nothing -> (# GHC.Base.Nothing @ (), ww2 #)
                   GHC.Base.Just ds1
                   -> (# ToSystemC.toSystemC2,
                         case ToSystemC.$wgo
                                ds
                                (case ds1 of ww4 { (,) ww5 ww6 ->
                                 case ww6 of ww7 { Types.C ww8 ww9 ww10 ww11 ww12 ww13 ->
                                 case ((ToSystemC.$wtopLevel w w1 ww10 ww11)
                                         `cast`
                                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                            <Types.TState>_N
                                            <Data.Functor.Identity.Identity>_R
                                            <()>_N)
                                         ww2)
                                        `cast`
                                      (Data.Functor.Identity.N:Identity[0]
                                           <((), Types.TState)>_R) of wild1 { (,) a1 s' ->
                                 s' } } }) of ww4 { (#,#) ww5 ww6 ->
                         ww6 } #) } }) -}
fb41fc98cf7af4dae70c7ae96e6d019d
  $wtopLevel ::
    GHC.Base.String
    -> [[GHC.Types.Int]]
    -> [Types.CInput]
    -> Types.COutput
    -> Types.TM ()
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U(U,U)>, Inline: [0] -}
c685a781078e100462385d0d7b3a6481
  changeIfMain :: Types.Name -> Types.Name
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (name :: Types.Name) ->
                 case GHC.Base.eqString name ToSystemC.changeIfMain2 of wild {
                   GHC.Types.False -> name
                   GHC.Types.True -> ToSystemC.changeIfMain1 }) -}
c253010b4a69af599c099a2201d398a2
  changeIfMain1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "mainFunc"#) -}
5043b245fe8edbf4c94308e44527159e
  changeIfMain2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "main"#) -}
c29113e515f24c032be8d2e37fdde271
  closingBraces :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "}\n\
                   \};"#) -}
e1c826fac98d7e293ea0cd88acbac062
  componentToSystemC :: Types.TComp -> Types.TMM ()
  {- Arity: 1, Strictness: <S(LS),1*U(U,1*U(A,U,1*U,U,U,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Types.TComp) ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww2 of ww3 { Types.C ww4 ww5 ww6 ww7 ww8 ww9 ->
                 ToSystemC.$wcomponentToSystemC ww1 ww5 ww6 ww7 ww8 ww9 } }) -}
b84b44b52bcdc0d2769384efdb737261
  endif :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString# "#endif"#) -}
4671a86658e054376812b4bfc1dc4477
  ifndef :: Types.Name -> GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (name :: Types.Name) ->
                 let {
                   pragma :: GHC.Base.String = ToSystemC.ifndef_go name
                 } in
                 Data.OldList.unlines
                   (GHC.Types.:
                      @ GHC.Base.String
                      (GHC.CString.unpackAppendCString# "#ifndef "# pragma)
                      (GHC.Types.:
                         @ GHC.Base.String
                         (GHC.CString.unpackAppendCString# "#define "# pragma)
                         (GHC.Types.[] @ GHC.Base.String)))) -}
772cabbb76fbd1c22d111ce001135b7f
  ifndef_go :: [GHC.Types.Char] -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U> -}
038959f073b860a4379f57cfdbd5caf2
  includeInstances :: [Types.TInst] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: [Types.TInst]) ->
                 Data.OldList.unlines (ToSystemC.includeInstances1 x)) -}
4d8cafcc0509be92a02ee3ebe9204981
  includeInstances1 :: [Types.TInst] -> [GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: [Types.TInst]) ->
                 ToSystemC.includeInstances_go
                   (Data.OldList.nubBy
                      @ Types.Name
                      GHC.Base.eqString
                      (GHC.Base.map
                         @ (Types.CompName, Types.Id, Types.NameId, Types.I, Types.Used)
                         @ [GHC.Types.Char]
                         ToSystemC.includeInstances_getNameFromInstance
                         x))) -}
95c836436d147f9495f61035926ed19a
  includeInstances2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "_"#) -}
03305cd18c9c6f50cee42da1c1154701
  includeInstances_getNameFromInstance :: Types.TInst -> Types.Name
  {- Arity: 1, Strictness: <S(LLSSL),1*U(A,1*U(U),1*U(1*U,A),1*U,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Types.TInst) ->
                 case w of ww { (,,,,) ww1 ww2 ww3 ww4 ww5 ->
                 case ww3 of ww6 { Types.NameId ww7 ww8 ->
                 ToSystemC.$wgetNameFromInstance ww2 ww7 ww4 } }) -}
d5f3eb0d2279a50c8ac91e3732cdec30
  includeInstances_go :: [[GHC.Types.Char]] -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U> -}
4bb598fc8c5730e534eb34759d799729
  includeSystemC :: GHC.Base.String
  {- Unfolding: (GHC.CString.unpackCString#
                   "#include \"systemc.h\""#) -}
273798f6a9a932a338177cf689525457
  inputs :: [Types.CInput] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: [([GHC.Types.Char], Types.FType)]) ->
                 Data.OldList.unlines
                   (GHC.Base.build
                      @ [GHC.Types.Char]
                      (\ @ b1
                         (c1 :: [GHC.Types.Char] -> b1 -> b1)[OneShot]
                         (n1 :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ ([GHC.Types.Char], Types.FType)
                         @ b1
                         (GHC.Base.mapFB
                            @ [GHC.Types.Char]
                            @ b1
                            @ ([GHC.Types.Char], Types.FType)
                            c1
                            ToSystemC.inputs_makeInput)
                         n1
                         x))) -}
710c2fd6bb5b37af88d8d6fec0cf6318
  inputs1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ";"#) -}
83601d985056e8dc5040726bac87360b
  inputs_makeInput ::
    ([GHC.Types.Char], Types.FType) -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S(LS),1*U(1*U,1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: ([GHC.Types.Char], Types.FType)) ->
                 case w of ww { (,) ww1 ww2 -> ToSystemC.$wmakeInput ww1 ww2 }) -}
db87b1a1d2d0fdc0d90d14e507bb8b30
  instanceDeclaration :: [Types.TInst] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: [Types.TInst]) ->
                 Data.OldList.unlines (ToSystemC.instanceDeclaration1 x)) -}
b57dbfcf1703993237f15b5791410b0d
  instanceDeclaration1 :: [Types.TInst] -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: [Types.TInst]) ->
                 ToSystemC.instanceDeclaration_go x) -}
07e8583f9650055f33dabe61de25181e
  instanceDeclaration_go ::
    [(Types.CompName, Types.Id, Types.NameId, Types.I, Types.Used)]
    -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U> -}
0694126edaa08ea721cd16db5bbcf9eb
  instanceFromFile :: Types.TInst -> Types.TM ()
  {- Arity: 1, Strictness: <S(LLSSL),1*U(A,1*U(U),1*U(U,A),1*U,A)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Types.TInst) ->
                 case w of ww { (,,,,) ww1 ww2 ww3 ww4 ww5 ->
                 case ww3 of ww6 { Types.NameId ww7 ww8 ->
                 ToSystemC.$winstanceFromFile ww2 ww7 ww4 } }) -}
b28a0b4a8bb87d66ff089c641b786a8c
  instanceFromFile1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "consR"#) -}
1e302bb956c87647b3b731221e0cb562
  instanceFromFile2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "rest"#) -}
51332ca706ff49309a88d8beee23d91f
  instanceFromFile3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "now"#) -}
16cc18a0e78e0cfb516898a84a062508
  instanceFromFile4 :: Types.TState -> ((), Types.TState)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ (eta1 :: Types.TState) -> (GHC.Tuple.(), eta1)) -}
b9a9ab64b2bf0ca96f9ffd716925a668
  interSignal ::
    (GHC.Show.Show a, GHC.Show.Show a1) =>
    [GHC.Types.Char]
    -> a1
    -> [GHC.Types.Char]
    -> [GHC.Types.Char]
    -> a
    -> [GHC.Types.Char]
    -> [GHC.Types.Char]
  {- Arity: 8, HasNoCafRefs,
     Strictness: <L,1*U(A,1*C1(U),A)><L,1*U(A,1*C1(U),A)><S,1*U><L,U><L,1*U><L,1*U><L,U><L,U>,
     Unfolding: (\ @ a
                   @ a1
                   ($dShow :: GHC.Show.Show a)
                   ($dShow1 :: GHC.Show.Show a1)
                   (m1 :: [GHC.Types.Char])
                   (id1 :: a1)
                   (p1 :: [GHC.Types.Char])
                   (m2 :: [GHC.Types.Char])
                   (id2 :: a)
                   (p2 :: [GHC.Types.Char]) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   m1
                   (GHC.Base.++
                      @ GHC.Types.Char
                      (GHC.Show.show @ a1 $dShow1 id1)
                      (GHC.CString.unpackAppendCString#
                         "_"#
                         (GHC.Base.++
                            @ GHC.Types.Char
                            p1
                            (GHC.CString.unpackAppendCString#
                               "__"#
                               (GHC.Base.++
                                  @ GHC.Types.Char
                                  m2
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     (GHC.Show.show @ a $dShow id2)
                                     (GHC.CString.unpackAppendCString# "_"# p2)))))))) -}
540952db9faedeeaa7e09414f1471b23
  interSignal_$sinterSignal ::
    [GHC.Types.Char]
    -> Types.Id
    -> [GHC.Types.Char]
    -> [GHC.Types.Char]
    -> Types.Id
    -> [GHC.Types.Char]
    -> [GHC.Types.Char]
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U(U)><L,1*U><L,1*U><L,1*U(U)><L,U>,
     Unfolding: (\ (m1 :: [GHC.Types.Char])
                   (id1 :: Types.Id)
                   (p1 :: [GHC.Types.Char])
                   (m2 :: [GHC.Types.Char])
                   (id2 :: Types.Id)
                   (p2 :: [GHC.Types.Char]) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   m1
                   (case id1 of ww2 { GHC.Types.I# ww3 ->
                    case GHC.Show.$wshowSignedInt
                           0#
                           ww3
                           (GHC.Types.[] @ GHC.Types.Char) of ww4 { (#,#) ww5 ww6 ->
                    GHC.Base.++
                      @ GHC.Types.Char
                      (GHC.Types.: @ GHC.Types.Char ww5 ww6)
                      (GHC.CString.unpackAppendCString#
                         "_"#
                         (GHC.Base.++
                            @ GHC.Types.Char
                            p1
                            (GHC.CString.unpackAppendCString#
                               "__"#
                               (GHC.Base.++
                                  @ GHC.Types.Char
                                  m2
                                  (case id2 of ww1 { GHC.Types.I# ww8 ->
                                   case GHC.Show.$wshowSignedInt
                                          0#
                                          ww8
                                          (GHC.Types.[]
                                             @ GHC.Types.Char) of ww9 { (#,#) ww10 ww11 ->
                                   GHC.Base.++
                                     @ GHC.Types.Char
                                     (GHC.Types.: @ GHC.Types.Char ww10 ww11)
                                     (GHC.CString.unpackAppendCString# "_"# p2) } }))))) } })) -}
af70191f21aff9a54b1aa1f314d4a9b9
  intermediarySignals :: [Types.CConn] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: [Types.CConn]) ->
                 Data.OldList.unlines (ToSystemC.intermediarySignals1 x)) -}
989ca55f5df331f2893e851a500070e8
  intermediarySignals1 :: [Types.CConn] -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: [Types.CConn]) ->
                 GHC.List.filter
                   @ [GHC.Types.Char]
                   ToSystemC.intermediarySignals3
                   (Data.OldList.nubBy
                      @ GHC.Base.String
                      GHC.Base.eqString
                      (GHC.Base.map
                         @ (Types.CompName, (Types.NameId, Types.CSignal),
                            (Types.NameId, Types.CSignal))
                         @ [GHC.Types.Char]
                         ToSystemC.intermediarySignals_intSig
                         x))) -}
944614fe65553eaee7ad1722c5124fe5
  intermediarySignals2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "__fifo__"#) -}
6aac6cea3fb170cb3d5c3952adfa8d57
  intermediarySignals3 :: [GHC.Types.Char] -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: [GHC.Types.Char]) ->
                 case GHC.Classes.$fEq[]_$s$c==1
                        ds
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
fae4ff9b99f2482a1dc1e521ffdf8605
  intermediarySignals_intSig :: Types.CConn -> GHC.Base.String
  {- Arity: 1,
     Strictness: <S(SS(S(SL)S)S(SS)),1*U(U,1*U(1*U(U,1*U(U)),1*U(1*U,1*U)),1*U(1*U(U,1*U(U)),1*U(U,A)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Types.CConn) ->
                 case w of ww { (,,) ww1 ww2 ww3 ->
                 case ww2 of ww4 { (,) ww5 ww6 ->
                 case ww5 of ww7 { Types.NameId ww8 ww9 ->
                 case ww6 of ww10 { (,) ww11 ww12 ->
                 case ww3 of ww13 { (,) ww14 ww15 ->
                 case ww14 of ww16 { Types.NameId ww17 ww18 ->
                 case ww15 of ww19 { (,) ww20 ww21 ->
                 ToSystemC.$wintSig
                   ww1
                   ww8
                   ww9
                   ww11
                   ww12
                   ww17
                   ww18
                   ww20 } } } } } } }) -}
3dbb163a570d67efe5333a70b189442d
  makeConstBinFile ::
    GHC.Show.Show t =>
    t
    -> Types.NameId
    -> [GHC.Types.Char]
    -> ([GHC.Types.Char], Types.FType)
    -> ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 5,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><S,1*U(1*U,A)><L,1*U><S,1*U(U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ t
                   (w :: GHC.Show.Show t)
                   (w1 :: t)
                   (w2 :: Types.NameId)
                   (w3 :: [GHC.Types.Char])
                   (w4 :: ([GHC.Types.Char], Types.FType)) ->
                 case w2 of ww { Types.NameId ww1 ww2 ->
                 case w4 of ww3 { (,) ww4 ww5 ->
                 case ToSystemC.$wmakeConstBinFile
                        @ t
                        w
                        w1
                        ww1
                        w3
                        ww4
                        ww5 of ww6 { (#,#) ww7 ww8 ->
                 (ww7, ww8) } } }) -}
57a70a0343651a6c4b70b4aa2c4f3c18
  makeConstDecFile ::
    (GHC.Show.Show t, GHC.Show.Show t1) =>
    t1
    -> Types.NameId
    -> t
    -> ([GHC.Types.Char], Types.FType)
    -> ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 6,
     Strictness: <L,1*U(A,1*C1(U),A)><L,1*U(A,1*C1(U),A)><L,U><S,1*U(1*U,A)><L,U><S,1*U(U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (6, True, False)
                (\ @ t
                   @ t1
                   (w :: GHC.Show.Show t)
                   (w1 :: GHC.Show.Show t1)
                   (w2 :: t1)
                   (w3 :: Types.NameId)
                   (w4 :: t)
                   (w5 :: ([GHC.Types.Char], Types.FType)) ->
                 case w3 of ww { Types.NameId ww1 ww2 ->
                 case w5 of ww3 { (,) ww4 ww5 ->
                 case ToSystemC.$wmakeConstDecFile
                        @ t
                        @ t1
                        w
                        w1
                        w2
                        ww1
                        w4
                        ww4
                        ww5 of ww6 { (#,#) ww7 ww8 ->
                 (ww7, ww8) } } }) -}
0c3f47a1410ae4d25cfb54b2ce98d68a
  makeConstHexFile ::
    GHC.Show.Show t =>
    t
    -> Types.NameId
    -> [GHC.Types.Char]
    -> ([GHC.Types.Char], Types.FType)
    -> ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 5,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><S,1*U(1*U,A)><L,1*U><S,1*U(U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ t
                   (w :: GHC.Show.Show t)
                   (w1 :: t)
                   (w2 :: Types.NameId)
                   (w3 :: [GHC.Types.Char])
                   (w4 :: ([GHC.Types.Char], Types.FType)) ->
                 case w2 of ww { Types.NameId ww1 ww2 ->
                 case w4 of ww3 { (,) ww4 ww5 ->
                 case ToSystemC.$wmakeConstHexFile
                        @ t
                        w
                        w1
                        ww1
                        w3
                        ww4
                        ww5 of ww6 { (#,#) ww7 ww8 ->
                 (ww7, ww8) } } }) -}
25cf352cd7cb20ea864e179425c97c66
  makeConstStrFile ::
    GHC.Show.Show t =>
    t
    -> Types.NameId
    -> [Types.FCons]
    -> ([GHC.Types.Char], Types.FType)
    -> ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 5,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><S,1*U(1*U,A)><L,1*U><S,1*U(U,1*U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ t
                   (w :: GHC.Show.Show t)
                   (w1 :: t)
                   (w2 :: Types.NameId)
                   (w3 :: [Types.FCons])
                   (w4 :: ([GHC.Types.Char], Types.FType)) ->
                 case w2 of ww { Types.NameId ww1 ww2 ->
                 case w4 of ww3 { (,) ww4 ww5 ->
                 case ToSystemC.$wmakeConstStrFile
                        @ t
                        w
                        w1
                        ww1
                        w3
                        ww4
                        ww5 of ww6 { (#,#) ww7 ww8 ->
                 (ww7, ww8) } } }) -}
198593e71c464be5c53b14531781f5d6
  makeForkFile ::
    Types.NameId
    -> GHC.Types.Int -> Types.CInput -> [Types.COutput] -> Types.File
  {- Arity: 4, Strictness: <S,1*U(U,A)><L,A><S,1*U(A,U)><L,U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: Types.NameId)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Types.CInput)
                   (w3 :: [Types.COutput]) ->
                 case w of ww { Types.NameId ww1 ww2 ->
                 case w2 of ww3 { (,) ww4 ww5 ->
                 case ToSystemC.$wmakeForkFile ww1 ww5 w3 of ww6 { (#,#) ww7 ww8 ->
                 (ww7, ww8) } } }) -}
cab61287e8b997eb874429339788b2cf
  makeSpecialFile ::
    GHC.Show.Show t =>
    t
    -> Types.NameId
    -> [(GHC.Base.String, Types.FType)]
    -> (GHC.Base.String, Types.FType)
    -> [GHC.Types.Int]
    -> ([GHC.Types.Char], GHC.Base.String)
  {- Arity: 6,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><S(SL),1*U(U,A)><S,1*U><S,1*U(U,U)><L,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (6, True, False)
                (\ @ t
                   (w :: GHC.Show.Show t)
                   (w1 :: t)
                   (w2 :: Types.NameId)
                   (w3 :: [(GHC.Base.String, Types.FType)])
                   (w4 :: (GHC.Base.String, Types.FType))
                   (w5 :: [GHC.Types.Int]) ->
                 case w2 of ww { Types.NameId ww1 ww2 ->
                 case w4 of ww3 { (,) ww4 ww5 ->
                 case ToSystemC.$wmakeSpecialFile
                        @ t
                        w
                        w1
                        ww1
                        w3
                        ww4
                        ww5
                        w5 of ww6 { (#,#) ww7 ww8 ->
                 (ww7, ww8) } } }) -}
dda80f3ab838d522995c855929447505
  makeSpecialFileArith ::
    GHC.Show.Show t =>
    t
    -> Types.NameId
    -> [(GHC.Base.String, Types.FType)]
    -> (GHC.Base.String, Types.FType)
    -> ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 5,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><S,1*U(U,A)><S,1*U><S,1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ t
                   (w :: GHC.Show.Show t)
                   (w1 :: t)
                   (w2 :: Types.NameId)
                   (w3 :: [(GHC.Base.String, Types.FType)])
                   (w4 :: (GHC.Base.String, Types.FType)) ->
                 case w2 of ww { Types.NameId ww1 ww2 ->
                 case w4 of ww3 { (,) ww4 ww5 ->
                 case ToSystemC.$wmakeSpecialFileArith
                        @ t
                        w
                        w1
                        ww1
                        w3
                        ww4
                        ww5 of ww6 { (#,#) ww7 ww8 ->
                 (ww7, ww8) } } }) -}
b794df0b384b6f6f7cf0cf140e238315
  makeSpecialFileCat ::
    GHC.Show.Show t =>
    t
    -> Types.NameId
    -> [(GHC.Base.String, Types.FType)]
    -> (GHC.Base.String, Types.FType)
    -> ([GHC.Types.Char], GHC.Base.String)
  {- Arity: 5,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><S,1*U(1*U,A)><S,1*U><S,1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ t
                   (w :: GHC.Show.Show t)
                   (w1 :: t)
                   (w2 :: Types.NameId)
                   (w3 :: [(GHC.Base.String, Types.FType)])
                   (w4 :: (GHC.Base.String, Types.FType)) ->
                 case w2 of ww { Types.NameId ww1 ww2 ->
                 case w4 of ww3 { (,) ww4 ww5 ->
                 case ToSystemC.$wmakeSpecialFileCat
                        @ t
                        w
                        w1
                        ww1
                        w3
                        ww4
                        ww5 of ww6 { (#,#) ww7 ww8 ->
                 (ww7, ww8) } } }) -}
23e70bea3b5d1c3bf28cf9485b5b8445
  makeSpecialFileLogic ::
    GHC.Show.Show t =>
    t
    -> Types.NameId
    -> [(GHC.Base.String, Types.FType)]
    -> (GHC.Base.String, Types.FType)
    -> ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 5,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><S,1*U(U,A)><S,1*U><S,1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ t
                   (w :: GHC.Show.Show t)
                   (w1 :: t)
                   (w2 :: Types.NameId)
                   (w3 :: [(GHC.Base.String, Types.FType)])
                   (w4 :: (GHC.Base.String, Types.FType)) ->
                 case w2 of ww { Types.NameId ww1 ww2 ->
                 case w4 of ww3 { (,) ww4 ww5 ->
                 case ToSystemC.$wmakeSpecialFileLogic
                        @ t
                        w
                        w1
                        ww1
                        w3
                        ww4
                        ww5 of ww6 { (#,#) ww7 ww8 ->
                 (ww7, ww8) } } }) -}
17bc5d81ba03fbfe14cff12bb077e4bc
  makeSpecialFileMRest ::
    GHC.Show.Show t =>
    t
    -> Types.NameId
    -> [(GHC.Base.String, Types.FType)]
    -> (GHC.Base.String, Types.FType)
    -> [GHC.Types.Int]
    -> ([GHC.Types.Char], GHC.Base.String)
  {- Arity: 6,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><S,1*U(1*U,A)><S,1*U><S,1*U(U,U)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (6, True, False)
                (\ @ t
                   (w :: GHC.Show.Show t)
                   (w1 :: t)
                   (w2 :: Types.NameId)
                   (w3 :: [(GHC.Base.String, Types.FType)])
                   (w4 :: (GHC.Base.String, Types.FType))
                   (w5 :: [GHC.Types.Int]) ->
                 case w2 of ww { Types.NameId ww1 ww2 ->
                 case w4 of ww3 { (,) ww4 ww5 ->
                 case ToSystemC.$wmakeSpecialFileMRest
                        @ t
                        w
                        w1
                        ww1
                        w3
                        ww4
                        ww5
                        w5 of ww6 { (#,#) ww7 ww8 ->
                 (ww7, ww8) } } }) -}
5abb60bb90abaa709cb6f919ca6598db
  makeSpecialFileNot ::
    GHC.Show.Show t =>
    t
    -> Types.NameId
    -> [(GHC.Base.String, Types.FType)]
    -> (GHC.Base.String, Types.FType)
    -> ([GHC.Types.Char], [GHC.Types.Char])
  {- Arity: 5,
     Strictness: <L,1*U(A,1*C1(U),A)><L,U><S,1*U(1*U,A)><S,1*U><S,1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ t
                   (w :: GHC.Show.Show t)
                   (w1 :: t)
                   (w2 :: Types.NameId)
                   (w3 :: [(GHC.Base.String, Types.FType)])
                   (w4 :: (GHC.Base.String, Types.FType)) ->
                 case w2 of ww { Types.NameId ww1 ww2 ->
                 case w4 of ww3 { (,) ww4 ww5 ->
                 case ToSystemC.$wmakeSpecialFileNot
                        @ t
                        w
                        w1
                        ww1
                        w3
                        ww4
                        ww5 of ww6 { (#,#) ww7 ww8 ->
                 (ww7, ww8) } } }) -}
be8b493402f65d00f0feda0c9fe33005
  makeSpecialFileSli ::
    (GHC.Show.Show t, GHC.Show.Show t1) =>
    t1
    -> Types.NameId
    -> [(GHC.Base.String, Types.FType)]
    -> (GHC.Base.String, Types.FType)
    -> [t]
    -> ([GHC.Types.Char], GHC.Base.String)
  {- Arity: 7,
     Strictness: <L,U(A,C(U),A)><L,1*U(A,1*C1(U),A)><L,U><S,1*U(1*U,A)><S,1*U><S,1*U(U,U)><S,1*U>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (7, True, False)
                (\ @ t
                   @ t1
                   (w :: GHC.Show.Show t)
                   (w1 :: GHC.Show.Show t1)
                   (w2 :: t1)
                   (w3 :: Types.NameId)
                   (w4 :: [(GHC.Base.String, Types.FType)])
                   (w5 :: (GHC.Base.String, Types.FType))
                   (w6 :: [t]) ->
                 case w3 of ww { Types.NameId ww1 ww2 ->
                 case w5 of ww3 { (,) ww4 ww5 ->
                 case ToSystemC.$wmakeSpecialFileSli
                        @ t
                        @ t1
                        w
                        w1
                        w2
                        ww1
                        w4
                        ww4
                        ww5
                        w6 of ww6 { (#,#) ww7 ww8 ->
                 (ww7, ww8) } } }) -}
23f6dbbfbae05aa44720fca90fac2af6
  makeTypeInput :: Types.FType -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
f51532f7eed334992ce82982990becb8
  makeTypeOutput :: Types.FType -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
1408cf8a932782c5258be97b3091f8e3
  makeTypePure :: Types.FType -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
90cb5834da4c8e20b46c4caa8bfd61a7
  makeTypeSignal :: Types.FType -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
2663b86dac9e9471b6590336fd00c852
  makeTypeVector :: Types.FType -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U> -}
f083488c36f76c88ee19ccb5e740542c
  outputs :: [Types.COutput] -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: [([GHC.Types.Char], Types.FType)]) ->
                 Data.OldList.unlines
                   (GHC.Base.build
                      @ [GHC.Types.Char]
                      (\ @ b1
                         (c1 :: [GHC.Types.Char] -> b1 -> b1)[OneShot]
                         (n1 :: b1)[OneShot] ->
                       GHC.Base.foldr
                         @ ([GHC.Types.Char], Types.FType)
                         @ b1
                         (GHC.Base.mapFB
                            @ [GHC.Types.Char]
                            @ b1
                            @ ([GHC.Types.Char], Types.FType)
                            c1
                            ToSystemC.outputs_makeOutput)
                         n1
                         x))) -}
571619fa0e49c112f0e4d37e56946dd8
  outputs_makeOutput ::
    ([GHC.Types.Char], Types.FType) -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S(LS),1*U(1*U,1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: ([GHC.Types.Char], Types.FType)) ->
                 case w of ww { (,) ww1 ww2 -> ToSystemC.$wmakeOutput ww1 ww2 }) -}
a0d34e6fc722e228c9bf26ae188c24d8
  procedureSignals :: Types.CProc -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: [Types.CProcUnit]) ->
                 Data.OldList.unlines (ToSystemC.procedureSignals1 x)) -}
a138d37a657456943c735560440e8a62
  procedureSignals1 :: [Types.CProcUnit] -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (x :: [Types.CProcUnit]) ->
                 Data.OldList.nubBy
                   @ [GHC.Types.Char]
                   GHC.Base.eqString
                   (ToSystemC.procedureSignals_go x)) -}
e93f5710cabbbaa1c133118da469226d
  procedureSignals_go :: [Types.CProcUnit] -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U> -}
a1431a014cf95f1702f1a2c4b0de9d03
  procedureToSystemC ::
    [GHC.Types.Char] -> [Types.CProcUnit] -> [GHC.Types.Char]
  {- Arity: 2, Strictness: <L,U><S,1*U> -}
7226ce2f1781cddcca8afa13448b7bc6
  processDeclaration :: [t] -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t (ds :: [t]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : ipv ipv1 -> ToSystemC.processDeclaration1 }) -}
1f579127d87fd4fa7d0def42603ea97f
  processDeclaration1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "void proc();"#) -}
91fd5c9cf82ee737dc9749de3f07ce34
  scCtor :: Types.Name -> [Types.TInst] -> GHC.Base.String
  {- Arity: 2, Strictness: <L,U><L,1*U>,
     Unfolding: (\ (name :: Types.Name) (insts :: [Types.TInst]) ->
                 GHC.CString.unpackAppendCString#
                   "SC_CTOR("#
                   (let {
                      arg :: [GHC.Types.Char]
                      = GHC.CString.unpackAppendCString#
                          ")"#
                          (case ToSystemC.scCtor_go insts of wild {
                             [] -> ToSystemC.scCtor2
                             : x ds
                             -> case ds of wild1 {
                                  []
                                  -> GHC.CString.unpackAppendCString#
                                       " : "#
                                       (GHC.Base.++ @ GHC.Types.Char x ToSystemC.scCtor2)
                                  : ipv ipv1
                                  -> GHC.CString.unpackAppendCString#
                                       " : "#
                                       (GHC.Base.++
                                          @ GHC.Types.Char
                                          (Data.OldList.intercalate_$spoly_go
                                             @ GHC.Types.Char
                                             x
                                             (Data.OldList.prependToAll
                                                @ [GHC.Types.Char]
                                                ToSystemC.scCtor1
                                                wild1))
                                          ToSystemC.scCtor2) } })
                    } in
                    case GHC.Base.eqString name ToSystemC.changeIfMain2 of wild {
                      GHC.Types.False -> GHC.Base.++ @ GHC.Types.Char name arg
                      GHC.Types.True
                      -> GHC.Base.++ @ GHC.Types.Char ToSystemC.changeIfMain1 arg })) -}
436a7f22e91c7aa980e8010bb1c46fed
  scCtor1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
332a4133724064241ff0bda68957b53f
  scCtor2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " {"#) -}
2b0e130a2e60419887b9d0a64fdfecbd
  scCtor_go ::
    [(Types.CompName, Types.Id, Types.NameId, Types.I, Types.Used)]
    -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,1*U> -}
38a201fe2f509f73c5ecb2497d4709bc
  scModule :: Types.Name -> GHC.Base.String
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ (name :: Types.Name) ->
                 GHC.CString.unpackAppendCString#
                   "SC_MODULE("#
                   (case GHC.Base.eqString name ToSystemC.changeIfMain2 of wild {
                      GHC.Types.False
                      -> GHC.Base.++ @ GHC.Types.Char name ToSystemC.scModule2
                      GHC.Types.True -> ToSystemC.scModule1 })) -}
b157581d6702e533aae84695f47a8c07
  scModule1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   ToSystemC.changeIfMain1
                   ToSystemC.scModule2) -}
fdae37bad72edfd8adb387a476319d8d
  scModule2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ") {"#) -}
c6fb5484c92f324979ab8c2868199858
  scThread :: [t] -> [GHC.Types.Char]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t (ds :: [t]) ->
                 case ds of wild {
                   [] -> GHC.Types.[] @ GHC.Types.Char
                   : ipv ipv1 -> ToSystemC.scThread1 }) -}
c152aecb7b05e3d9691006ffdba72a52
  scThread1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "SC_THREAD(proc);"#) -}
332811f914d56234a3656d39dbcae277
  sconnections :: [Types.CConn] -> Types.TMM GHC.Base.String
  {- Arity: 1, Strictness: <L,1*U>,
     Unfolding: (\ (conns :: [Types.CConn]) ->
                 let {
                   m1 :: Control.Monad.Trans.State.Lazy.StateT
                           Types.TState
                           Data.Functor.Identity.Identity
                           [GHC.Base.Maybe GHC.Base.String]
                   = ToSystemC.sconnections_go conns
                 } in
                 (\ (s1 :: Types.TState) ->
                  case (m1
                          `cast`
                        (Control.Monad.Trans.State.Lazy.N:StateT[0]
                             <Types.TState>_N
                             <Data.Functor.Identity.Identity>_R
                             <[GHC.Base.Maybe GHC.Base.String]>_N)
                          s1)
                         `cast`
                       (Data.Functor.Identity.N:Identity[0]
                            <([GHC.Base.Maybe GHC.Base.String],
                              Types.TState)>_R) of ww { (,) ww1 ww2 ->
                  case (TransformationMonad.cont5 @ GHC.Base.String ww1)
                         `cast`
                       (Data.Monoid.N:All[0]) of wild {
                    GHC.Types.False
                    -> (GHC.Base.Nothing @ GHC.Base.String, ww2)
                         `cast`
                       (Sym (Data.Functor.Identity.N:Identity[0]
                                 <(GHC.Base.Maybe GHC.Base.String, Types.TState)>_R))
                    GHC.Types.True
                    -> (GHC.Base.Just
                          @ GHC.Base.String
                          (Data.OldList.unlines
                             (GHC.Base.map
                                @ (GHC.Base.Maybe GHC.Base.String)
                                @ [GHC.Types.Char]
                                (Aux.just @ GHC.Base.String)
                                ww1)),
                        ww2)
                         `cast`
                       (Sym (Data.Functor.Identity.N:Identity[0]
                                 <(GHC.Base.Maybe GHC.Base.String, Types.TState)>_R)) } })
                   `cast`
                 (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                           <Types.TState>_N
                           <Data.Functor.Identity.Identity>_R
                           <GHC.Base.Maybe GHC.Base.String>_N))) -}
69f9ab8fcd3e33997a42ef780c53c030
  sconnections_go ::
    [Types.CConn]
    -> Control.Monad.Trans.State.Lazy.StateT
         Types.TState
         Data.Functor.Identity.Identity
         [GHC.Base.Maybe GHC.Base.String]
  {- Arity: 1, Strictness: <S,1*U> -}
d527f7fead252a8e896ae1c435af373b
  toHeader :: Types.Name -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (name :: Types.Name) -> ToSystemC.ifndef_go name) -}
d2edf77556a7b7c03c203fa5ca1a3632
  toSystemC :: GHC.Base.String -> [[GHC.Types.Int]] -> Types.TMM ()
  {- Arity: 3,
     Strictness: <L,U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                ToSystemC.toSystemC1
                  `cast`
                (<GHC.Base.String>_R
                 ->_R <[[GHC.Types.Int]]>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Base.Maybe ()>_N)) -}
1d19e6cd13bb146a8150b8840654b9ad
  toSystemC1 ::
    GHC.Base.String
    -> [[GHC.Types.Int]]
    -> Types.TState
    -> Data.Functor.Identity.Identity (GHC.Base.Maybe (), Types.TState)
  {- Arity: 3,
     Strictness: <L,U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Base.String)
                   (w1 :: [[GHC.Types.Int]])
                   (w2 :: Types.TState) ->
                 case ToSystemC.$wtoSystemC w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(GHC.Base.Maybe (), Types.TState)>_R)) }) -}
4d20f99d464e97a2ccba645ec932e63d
  toSystemC2 :: GHC.Base.Maybe ()
  {- HasNoCafRefs, Unfolding: (GHC.Base.Just @ () GHC.Tuple.()) -}
03de3438cf55752a5bce774412fe3f3b
  topLevel ::
    GHC.Base.String -> [[GHC.Types.Int]] -> Types.TComp -> Types.TM ()
  {- Arity: 3,
     Strictness: <L,U><L,U><S(LS),1*U(A,1*U(A,A,U,U(U,U),A,A))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: GHC.Base.String)
                   (w1 :: [[GHC.Types.Int]])
                   (w2 :: Types.TComp) ->
                 case w2 of ww { (,) ww1 ww2 ->
                 case ww2 of ww3 { Types.C ww4 ww5 ww6 ww7 ww8 ww9 ->
                 ToSystemC.$wtopLevel w w1 ww6 ww7 } }) -}
"SPEC interSignal @ Id @ Id" [ALWAYS] forall ($dShow :: GHC.Show.Show
                                                          Types.Id)
                                             ($dShow1 :: GHC.Show.Show Types.Id)
  ToSystemC.interSignal @ GHC.Types.Int
                        @ GHC.Types.Int
                        $dShow1
                        $dShow
  = ToSystemC.interSignal_$sinterSignal
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

