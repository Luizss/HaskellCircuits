
==================== FINAL INTERFACE ====================
2018-06-09 19:11:53.899349 UTC

interface HaskellCircuits-0.1.0.0-3mIW93ol3alH6nhlDJ7Hzo:TransformationMonad 8002
  interface hash: 43fea5ff33cec4856184e50aeb9a1853
  ABI hash: 9a41a082a5198ad8166e58e36aa95114
  export-list hash: a2f2911707e7fb33be1f875278a27f62
  orphan hash: fc79372ffa527be386e147e3bd901817
  flag hash: cec7e9342ccc77d0feccdf63b5a6ea3b
  sig of: Nothing
  used TH splices: False
  where
exports:
  TransformationMonad.addCFuncType
  TransformationMonad.addComp
  TransformationMonad.addConnection
  TransformationMonad.addData
  TransformationMonad.addForkedIndex
  TransformationMonad.addFunc
  TransformationMonad.addFunctionId
  TransformationMonad.addInstance
  TransformationMonad.addLogicalConnection
  TransformationMonad.addLogicalOutput
  TransformationMonad.addSystemCFile
  TransformationMonad.addTCFunc
  TransformationMonad.addTypeChange
  TransformationMonad.addTypeChangeStream
  TransformationMonad.changeFunction
  TransformationMonad.changeType
  TransformationMonad.cont
  TransformationMonad.cont1
  TransformationMonad.cont2
  TransformationMonad.cont3
  TransformationMonad.contIf
  TransformationMonad.cont_
  TransformationMonad.debug
  TransformationMonad.debugs
  TransformationMonad.doesLogicalConnectionExist
  TransformationMonad.doesLogicalOutputExist
  TransformationMonad.getCFuncTypes
  TransformationMonad.getComponents
  TransformationMonad.getConnections
  TransformationMonad.getCore
  TransformationMonad.getDataDecls
  TransformationMonad.getForkedIndex
  TransformationMonad.getFunctionId
  TransformationMonad.getFunctionIds
  TransformationMonad.getFunctions
  TransformationMonad.getIdForInstance
  TransformationMonad.getInstances
  TransformationMonad.getInstancesFromComponent
  TransformationMonad.getIt
  TransformationMonad.getLogicalConnections
  TransformationMonad.getLogicalOutput
  TransformationMonad.getLogicalOutputs
  TransformationMonad.getNextInstance
  TransformationMonad.getNumberFromType
  TransformationMonad.getSourceCode
  TransformationMonad.getSourceLine
  TransformationMonad.getStage
  TransformationMonad.getTCore
  TransformationMonad.getTimesForked
  TransformationMonad.getTypeChanges
  TransformationMonad.getTypeCheckState
  TransformationMonad.getUniqueInstance
  TransformationMonad.highOrderArgs
  TransformationMonad.incrementForkedIndex
  TransformationMonad.isFunctionHighOrder
  TransformationMonad.isInstanceAdded
  TransformationMonad.isThereTypeChange
  TransformationMonad.isTypeRecursive
  TransformationMonad.log
  TransformationMonad.mayThrow
  TransformationMonad.modifyTypeCheckState
  TransformationMonad.modifyUniqueInstance
  TransformationMonad.newStage
  TransformationMonad.noRet
  TransformationMonad.outTM
  TransformationMonad.popTypeCheckState
  TransformationMonad.putComponents
  TransformationMonad.putDataDecls
  TransformationMonad.putForkedIndex
  TransformationMonad.putFunctions
  TransformationMonad.putInstances
  TransformationMonad.putSourceCode
  TransformationMonad.putTCore
  TransformationMonad.putTimesForked
  TransformationMonad.putTypeCheckState
  TransformationMonad.removeFunction
  TransformationMonad.ret
  TransformationMonad.runTM
  TransformationMonad.searchCFuncType
  TransformationMonad.searchComponent
  TransformationMonad.searchDataDecl
  TransformationMonad.searchFunction
  TransformationMonad.searchFunctionByName
  TransformationMonad.searchInstances
  TransformationMonad.setCore
  TransformationMonad.setDataUsed
  TransformationMonad.setInstanceUsed
  TransformationMonad.testF1
  TransformationMonad.testF2
  TransformationMonad.throw
  TransformationMonad.throwIf
module dependencies: Aux Lexer Parser Types
package dependencies: array-0.5.1.1@array-0.5.1.1 base-4.9.1.0
                      containers-0.5.7.1@containers-0.5.7.1
                      deepseq-1.4.2.0@deepseq-1.4.2.0 ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1 mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6
                      transformers-0.5.2.0@transformers-0.5.2.0
                      utf8-string-1.0.1.1@utf8-string-1.0.1.1-1DpjxLeTvGg7ttZZojxJR5
orphans: HaskellCircuits-0.1.0.0-3mIW93ol3alH6nhlDJ7Hzo:Parser
         base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
         transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.Error
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Complex base-4.9.1.0:Data.Either
                         base-4.9.1.0:Data.Functor.Const base-4.9.1.0:Data.Functor.Identity
                         base-4.9.1.0:Data.List.NonEmpty base-4.9.1.0:Data.Monoid
                         base-4.9.1.0:Data.Semigroup base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:Data.Version base-4.9.1.0:Data.Void
                         base-4.9.1.0:GHC.Exts base-4.9.1.0:GHC.Generics
                         base-4.9.1.0:GHC.IO.Exception base-4.9.1.0:GHC.TypeLits
                         containers-0.5.7.1@containers-0.5.7.1:Data.Map.Base
                         containers-0.5.7.1@containers-0.5.7.1:Data.Set.Base
import  -/  Aux 19066227c591c3746fddc67fa02fb706
  exports: 3c8f8ea3f0430e062a77584d5651b09f
  equalFType 01ca2ee250f718cfd35afe845f680ceb
  fst4 a1b571205bcf4f57645d5beb4b1759d2
  isJust dc83b0ac557f6b9eb3da2ec2084dbef4
  isNothing 65b3e7e824b8d868e2930da83696a3a8
  just 8567f0152f7fceaf161de552d8c51a58
  may 06fd456aa683c3ce5a0cba12fec1b93e
import  -/  Lexer c6174f684585218aa184faedf4ab7f58
  exports: c0fea5fa50c83f412bfcd8243e0a6172
  Dec 8b0f2277218f753a903427d84acf225f
  L aeabd488767cc0257d48246b31a3c8eb
  L b349f6a51d347de013d5c5d3a0eb3033
  NoLoc 1192b825a1bbdd5c089dbb8aeba295bc
  Upp 894a86340c775c101c75dc2b77ce46e2
import  -/  Parser f25442964b616089abfc3d7b05acabc3
  exports: 518f87c40b39394a3af3d07ea4f63fc3
import  -/  Types 757470cca10fe0c859acdd7db069deaa
  exports: 34058aae7a6fb4ed664b025b184c161d
  AllInstancesUsed d642202050db0f37912d01591d1a5e84
  CConn 4d6bbc82c553fb41fbacc4cdf5b0ccd3
  CConstr 406345940f930081e4da3d7c6154c2ec
  CFType 8104f895f8b3e96ad3976476ae2f7330
  CTAExpr d3b8dc074bbd299cf33cd3d29a5ca0ab
  CTApp 350ec496e570c115280dc3989c163e27
  CompName 4228b9a1b27aab3097285eec31223745
  Constraint b52d039eaf4ef6d1a19dae86e8762e00
  Core 438d7d9868420ea466e01d42ff11e8f8
  ErrConstantAsFunction 0e71f051627131931590edf9b6fc7880
  F 6aafaa3aa6b911b99b58a60ba71b52cc
  FGuards f0164379fcbf1ee84d79a6d7cd973f63
  FType 8b9bd064502b5d5eb590940bf149b133
  File 7880caf15877d8eb60f0074a434f4fff
  ForkI 240a61bfc5c93f35049f26a7daf984d8
  Id 2682eaa34ecb623f5ad090b662e6527a
  IsRec ba9812d6a2cf36a79baceb628349d3a4
  ModifyUnexistingInstance 3732ccd1eeb95b184508d0c663dcc50d
  Msg b42d0bf5c885aa03591b69d72d176fcf
  Name 4bbc3da5ef1d02db55291a2a33a7c002
  NameId 206aacfbf28fd58314dcb848f8801aed
  NameId 4aa1b762a773a120e02f482bc8631e08
  SourceCode 53ecf0e062897cbfeda5c1adfc1ddc82
  TCFunc 12aff70e921393996a769ff39cd06cc8
  TComp 512c2abf100124d914051cfc1b1240b4
  TCore fe7322336a92ee2429b6cab0045090f5
  TCore 37b29aaac158f03681018e20b16bb37a
  TErr bd3b322a3f06039eedd1569007f14c0c
  TErr 2ca627f167c05972904f3acdfbba14a6
  TFunc 3c2f7afcecfe357ec2bf84c74b0ec723
  TInst 17bef6e9e2329998cd16deab3a7bfd4a
  TLog 42a894bc351bf4e0bbea37f81ba99005
  TLogDebug 30728fc08d031f8870c5654269b2a2e0
  TLogErr fd0f01e1822a72ecbac42047171fa772
  TM f4ba4f96d9f8dffc5235169391939992
  TMM a7c38748359d680c785978249d7123ff
  TStage 2790536fe3b8b1cd1b284b55137862d3
  TState 40f95c047818067e4f0b74424938b4b0
  UniqueInstanceNotFound c67f9752fcabf300d0dfc55c6288a508
  Used 5aca5da094e92ef0b944df193939f3b1
  actualStage 3f721df435570fa5682ef1954999e28e
  components 8dba763a20197c190eb2249a3f3ab046
  connections 3ebb5752f18daaebdb98a114caee49f3
  core ec551278598a7221aac2af0038b71cc5
  dataDecls cde3c1bf0abb25486cab7c3e8499ca96
  funcTypes 27d3c001c05d12c84223c4b2d421d8f6
  functionIds cc528c32a1b4a88357fb967fbb4c16e6
  initialTState 246bf90dd5a77d0b3d37bcaa9252b14b
  instances 3fdf52168cdb62ee6e4ef8e4481a4ce6
  logicalConnections 5da2d285c59d331b587828538ac41fcd
  logicalOutputs ee8bac27ffd721260adda3ad3218b39b
  sourceCode 616e0b6995fdaf650381e337e08a356b
  systemC c8d0d69bbb8387440fca529d4c8ec5cc
  tCore 0fcfc4ecac49a628942b54ac078904cd
  tFuncs 7c2e74d524abc20cd5c50935988ab20c
  tLogs b7762507a9a72864efc27d6bae262bb0
  timesForked 213761bdee4a917517fdce5431e69cb1
  typeChanges e982020dcfb79f1f12af3489e27d98fe
  typeCheckState ed23ce516438c2751761067070fa2d23
import  -/  base-4.9.1.0:Data.Foldable 3e0b6967a1da89945d0e2d47266337a2
import  -/  base-4.9.1.0:Data.Functor 5ab1dc703df5b482e77efb697833ca3c
import  -/  base-4.9.1.0:Data.List 07ae2acca6538aa0800bd0a993ac6ac1
import  -/  base-4.9.1.0:Data.OldList 27987919d8da2f92e3f472ca81f730f8
import  -/  base-4.9.1.0:Data.Traversable 556020d7cf3c4a34a774600512918a37
import  -/  base-4.9.1.0:Data.Tuple 7dc4bbb45d2e69c991ffac438beeca11
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Err 3bba35a16538d33d424682ce66876cdd
import  -/  base-4.9.1.0:GHC.List ab8c4e523e6c479c549d3bcd5fc4a439
import  -/  base-4.9.1.0:GHC.Num 00bfaa7b2f9d6084913c0697a8a49ec8
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State 749dca8ca0e6625b32091d445bd92b01
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.State.Class 6d31234b0a911b56412061943d18b89e
import  -/  mtl-2.2.1@mtl-2.2.1-BLKBelFsPB3BoFeSWSOYj6:Control.Monad.Trans d69bc2e104a90fb918d853b240f7af2e
import  -/  transformers-0.5.2.0@transformers-0.5.2.0:Control.Monad.Trans.State.Lazy 371607e50dde46b5f4103b3ab334a497
9e438b2aa626d0970d39e7c1775cd06d
  $s$fEq(,,,,) ::
    GHC.Classes.Eq
      ([GHC.Types.Char], GHC.Types.Int, Types.NameId, Types.I,
       GHC.Types.Bool)
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ ([GHC.Types.Char], GHC.Types.Int, Types.NameId, Types.I,
                     GHC.Types.Bool)
                  (GHC.Classes.$fEq(,,,,)_$c==
                     @ [GHC.Types.Char]
                     @ GHC.Types.Int
                     @ Types.NameId
                     @ Types.I
                     @ GHC.Types.Bool
                     TransformationMonad.$s$fEq(,,,,)1
                     GHC.Classes.$fEqInt
                     Types.$fEqNameId
                     Types.$fEqI
                     GHC.Classes.$fEqBool)
                  TransformationMonad.$s$fEq(,,,,)_$s$fEq(,,,,)_$c/= -}
29f980368d38c55700ad9ca7c79f9156
  $s$fEq(,,,,)1 :: GHC.Classes.Eq Types.Name
  {- Strictness: m,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.$fEq[]_$s$fEq[]1 -}
8d4fa9ea6ae64d6a07ff6593b0ccc701
  $s$fEq(,,,,)_$s$fEq(,,,,)_$c/= ::
    ([GHC.Types.Char], GHC.Types.Int, Types.NameId, Types.I,
     GHC.Types.Bool)
    -> ([GHC.Types.Char], GHC.Types.Int, Types.NameId, Types.I,
        GHC.Types.Bool)
    -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(SLLLL),1*U(1*U,1*U(U),1*U(1*U,1*U(U)),1*U,1*U)><S(SLLLL),1*U(1*U,1*U(U),1*U(1*U,1*U(U)),1*U,1*U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (a1 :: ([GHC.Types.Char], GHC.Types.Int, Types.NameId, Types.I,
                           GHC.Types.Bool))
                   (b1 :: ([GHC.Types.Char], GHC.Types.Int, Types.NameId, Types.I,
                           GHC.Types.Bool)) ->
                 case GHC.Classes.$fEq(,,,,)_$c==
                        @ [GHC.Types.Char]
                        @ GHC.Types.Int
                        @ Types.NameId
                        @ Types.I
                        @ GHC.Types.Bool
                        TransformationMonad.$s$fEq(,,,,)1
                        GHC.Classes.$fEqInt
                        Types.$fEqNameId
                        Types.$fEqI
                        GHC.Classes.$fEqBool
                        a1
                        b1 of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
7b720a3ecf6d97a2f145f911a2722c45
  $s$fShow(,)_$cshow4 ::
    ([GHC.Types.Char], [GHC.Types.Char])
    -> GHC.Base.String -> [GHC.Types.Char]
  {- Arity: 2,
     Unfolding: (\ (w3 :: ([GHC.Types.Char], [GHC.Types.Char]))
                   (w4 :: GHC.Base.String)[OneShot] ->
                 case w3 of ww { (,) ww1 ww2 ->
                 GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows7
                   (GHC.Types.:
                      @ GHC.Types.Char
                      GHC.Show.shows6
                      (GHC.Show.showLitString
                         ww1
                         (GHC.Types.:
                            @ GHC.Types.Char
                            GHC.Show.shows6
                            (GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.shows5
                               (GHC.Show.$fShow(,)_$sgo
                                  (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 w4)
                                  (\ (eta1 :: GHC.Base.String) ->
                                   GHC.Show.shows_$cshowList1 ww2 eta1)
                                  (GHC.Types.[] @ GHC.Show.ShowS)))))) }) -}
437c3d04f6087d3f68c9b991d1eac40a
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   TransformationMonad.$trModule2
                   TransformationMonad.$trModule1) -}
b90ca48997c134fabb0d919178b25fc4
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "TransformationMonad"#) -}
c25497869cb7c65e26d0a70773025217
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "HaskellCircuits-0.1.0.0-3mIW93ol3alH6nhlDJ7Hzo"#) -}
933c78ce055a1ee92ccb93fd0f841d50
  $waddTypeChange ::
    Types.Name
    -> GHC.Types.Int -> Types.TState -> (# (), Types.TState #)
  {- Arity: 3,
     Strictness: <L,U><L,1*U(U)><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: Types.Name)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Types.TState) ->
                 (# GHC.Tuple.(),
                    case w2 of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                    Types.TState
                      ds
                      ds1
                      ds2
                      ds3
                      ds4
                      (GHC.Types.:
                         @ (Types.CFType, Types.CFType)
                         (Types.CTAExpr (Lexer.L @ Lexer.Token Lexer.NoLoc (Lexer.Upp w)),
                          case w1 of wild1 { GHC.Types.I# x1 ->
                          case x1 of wild2 {
                            DEFAULT
                            -> Types.CTApp
                                 TransformationMonad.addTypeChange6
                                 (GHC.Types.:
                                    @ Types.CFType
                                    (Types.CTAExpr
                                       (Lexer.L @ Lexer.Token Lexer.NoLoc (Lexer.Dec wild1)))
                                    (GHC.Types.[] @ Types.CFType))
                            1# -> TransformationMonad.addTypeChange2 } })
                         ds5)
                      ds6
                      ds7
                      ds8
                      ds9
                      ds10
                      ds11
                      ds12
                      ds13
                      ds14
                      ds15
                      ds16
                      ds17 } #)) -}
693c4dc71c89e1e1db3ba724288bd403
  $waddTypeChangeStream ::
    Types.Name
    -> GHC.Types.Int -> Types.TState -> (# (), Types.TState #)
  {- Arity: 3,
     Strictness: <L,U><L,1*U(U)><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: Types.Name)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Types.TState) ->
                 (# GHC.Tuple.(),
                    case w2 of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                    Types.TState
                      ds
                      ds1
                      ds2
                      ds3
                      ds4
                      (GHC.Types.:
                         @ (Types.CFType, Types.CFType)
                         (Types.CTAExpr (Lexer.L @ Lexer.Token Lexer.NoLoc (Lexer.Upp w)),
                          case w1 of wild1 { GHC.Types.I# x1 ->
                          case x1 of wild2 {
                            DEFAULT
                            -> Types.CTApp
                                 TransformationMonad.addTypeChangeStream4
                                 (GHC.Types.:
                                    @ Types.CFType
                                    (Types.CTApp
                                       TransformationMonad.addTypeChange6
                                       (GHC.Types.:
                                          @ Types.CFType
                                          (Types.CTAExpr
                                             (Lexer.L @ Lexer.Token Lexer.NoLoc (Lexer.Dec wild1)))
                                          (GHC.Types.[] @ Types.CFType)))
                                    (GHC.Types.[] @ Types.CFType))
                            1# -> TransformationMonad.addTypeChangeStream2 } })
                         ds5)
                      ds6
                      ds7
                      ds8
                      ds9
                      ds10
                      ds11
                      ds12
                      ds13
                      ds14
                      ds15
                      ds16
                      ds17 } #)) -}
42c152d96d3befc88c2583d6cc12b231
  $wchangeFunction ::
    Types.Name
    -> Types.FGuards
    -> Types.TState
    -> (# GHC.Base.Maybe (), Types.TState #)
  {- Arity: 3,
     Strictness: <L,U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: Types.Name)
                   (w1 :: Types.FGuards)
                   (w2 :: Types.TState) ->
                 case TransformationMonad.$wsearchFunction
                        w
                        w2 of ww { (#,#) ww1 ww2 ->
                 case ww1 of wild {
                   GHC.Base.Nothing
                   -> (# GHC.Base.Nothing @ (),
                         case ww2 of wild1 { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                         Types.TState
                           ds
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           ds7
                           (GHC.List.filter
                              @ (Types.Name, Lexer.SrcLoc, Types.F, Types.Arity,
                                 Types.FunctionClassification, Types.HighOrder)
                              (\ (ds18 :: (Types.Name, Lexer.SrcLoc, Types.F, Types.Arity,
                                           Types.FunctionClassification, Types.HighOrder)) ->
                               case ds18 of wild2 { (,,,,,) n ds19 ds20 ds21 ds22 ds23 ->
                               GHC.Classes.$fEq[]_$s$c/=1 n w })
                              ds8)
                           ds9
                           ds10
                           ds11
                           ds12
                           ds13
                           ds14
                           ds15
                           ds16
                           ds17 } #)
                   GHC.Base.Just ds1
                   -> case ds1 of wild1 { (,,,,,) n s ds a fc ho ->
                      case ds of wild2 {
                        Types.F vars ds2 ft
                        -> (# TransformationMonad.changeFunction3,
                              case ww2 of wild3 { Types.TState ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ds20 ->
                              Types.TState
                                ds3
                                ds4
                                ds5
                                ds6
                                ds7
                                ds8
                                ds9
                                ds10
                                (GHC.Types.:
                                   @ Types.TFunc
                                   (n, s, Types.F vars w1 ft, a, fc, ho)
                                   (GHC.List.filter
                                      @ (Types.Name, Lexer.SrcLoc, Types.F, Types.Arity,
                                         Types.FunctionClassification, Types.HighOrder)
                                      (\ (ds21 :: (Types.Name, Lexer.SrcLoc, Types.F, Types.Arity,
                                                   Types.FunctionClassification,
                                                   Types.HighOrder)) ->
                                       case ds21 of wild4 { (,,,,,) n1 ds22 ds23 ds24 ds25 ds26 ->
                                       GHC.Classes.$fEq[]_$s$c/=1 n1 w })
                                      ds11))
                                ds12
                                ds13
                                ds14
                                ds15
                                ds16
                                ds17
                                ds18
                                ds19
                                ds20 } #)
                        Types.SpecialF
                        -> case TransformationMonad.changeFunction2
                           ret_ty (# GHC.Base.Maybe (), Types.TState #)
                           of {} } } } }) -}
50557e8fab8114339ec90fb92861dd84
  $wdoesLogicalOutputExist ::
    Types.Name -> Types.TState -> (# GHC.Types.Bool, Types.TState #)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 (# case w1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                    GHC.List.elem
                      @ Types.Name
                      GHC.Classes.$fEq[]_$s$fEq[]1
                      w
                      (GHC.Base.map
                         @ (Types.Name, Types.Name, Types.FType,
                            GHC.Base.Maybe GHC.Types.Int)
                         @ [GHC.Types.Char]
                         (Aux.fst4
                            @ (GHC.Base.Maybe GHC.Types.Int)
                            @ Types.FType
                            @ Types.Name
                            @ Types.Name)
                         ds15) },
                    case w1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                    case GHC.List.elem
                           @ Types.Name
                           GHC.Classes.$fEq[]_$s$fEq[]1
                           w
                           (GHC.Base.map
                              @ (Types.Name, Types.Name, Types.FType,
                                 GHC.Base.Maybe GHC.Types.Int)
                              @ [GHC.Types.Char]
                              (Aux.fst4
                                 @ (GHC.Base.Maybe GHC.Types.Int)
                                 @ Types.FType
                                 @ Types.Name
                                 @ Types.Name)
                              ds15) of wild1 {
                      GHC.Types.False
                      -> Types.TState
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           ds7
                           (GHC.Types.:
                              @ Types.TLog
                              (Types.TLogDebug (GHC.CString.unpackAppendCString# "Nope "# w) ds5)
                              ds8)
                           ds9
                           ds10
                           ds11
                           ds12
                           ds13
                           ds14
                           ds15
                           ds16
                           ds17
                           ds18
                      GHC.Types.True
                      -> Types.TState
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           ds7
                           (GHC.Types.: @ Types.TLog (Types.TLogDebug w ds5) ds8)
                           ds9
                           ds10
                           ds11
                           ds12
                           ds13
                           ds14
                           ds15
                           ds16
                           ds17
                           ds18 } } #)) -}
cc3b586df76b41f4feb1a08952bb1b40
  $wgetFunctionId ::
    Types.Name
    -> [Types.FType]
    -> Types.SourceCode
    -> [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used)]
    -> [(Types.Name, [Types.Constraint], [Types.CFType])]
    -> [([Types.Constraint], [Types.CFType])]
    -> Types.TStage
    -> [(Types.CFType, Types.CFType)]
    -> Types.TCore
    -> [Types.TLog]
    -> [Types.TFunc]
    -> [(Types.Name, Types.Id, [Types.FType])]
    -> [Types.TComp]
    -> [Types.TInst]
    -> [Types.CConn]
    -> [Types.Name]
    -> [(Types.Name, Types.Name, Types.FType,
         GHC.Base.Maybe GHC.Types.Int)]
    -> Types.SystemC
    -> [(Types.CompName, GHC.Base.String, GHC.Types.Int)]
    -> Types.Core
    -> (# Types.Id, Types.TState #)
  {- Arity: 20,
     Strictness: <L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><S,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Types.Name)
                   (w1 :: [Types.FType])
                   (ww :: Types.SourceCode)
                   (ww1 :: [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                             Types.Used)])
                   (ww2 :: [(Types.Name, [Types.Constraint], [Types.CFType])])
                   (ww3 :: [([Types.Constraint], [Types.CFType])])
                   (ww4 :: Types.TStage)
                   (ww5 :: [(Types.CFType, Types.CFType)])
                   (ww6 :: Types.TCore)
                   (ww7 :: [Types.TLog])
                   (ww8 :: [Types.TFunc])
                   (ww9 :: [(Types.Name, Types.Id, [Types.FType])])
                   (ww10 :: [Types.TComp])
                   (ww11 :: [Types.TInst])
                   (ww12 :: [Types.CConn])
                   (ww13 :: [Types.Name])
                   (ww14 :: [(Types.Name, Types.Name, Types.FType,
                              GHC.Base.Maybe GHC.Types.Int)])
                   (ww15 :: Types.SystemC)
                   (ww16 :: [(Types.CompName, GHC.Base.String, GHC.Types.Int)])
                   (ww17 :: Types.Core) ->
                 case GHC.List.filter
                        @ (Types.Name, Types.Id, [Types.FType])
                        (\ (ds :: (Types.Name, Types.Id, [Types.FType])) ->
                         case ds of wild { (,,) n ds1 ds2 -> GHC.Base.eqString n w })
                        ww9 of wild {
                   []
                   -> (# TransformationMonad.getForkedIndex2,
                         Types.TState
                           ww
                           ww1
                           ww2
                           ww3
                           ww4
                           ww5
                           ww6
                           ww7
                           ww8
                           ww9
                           ww10
                           ww11
                           ww12
                           ww13
                           ww14
                           ww15
                           ww16
                           ww17 #)
                   : ipv ipv1
                   -> letrec {
                        go :: [(Types.Name, Types.Id, [Types.FType])]
                              -> Data.Monoid.First (Types.Name, Types.Id, [Types.FType])
                          {- Arity: 1, Strictness: <S,1*U> -}
                        = \ (ds :: [(Types.Name, Types.Id, [Types.FType])]) ->
                          case ds of wild1 {
                            []
                            -> (GHC.Base.Nothing @ (Types.Name, Types.Id, [Types.FType]))
                                 `cast`
                               (Sym (Data.Monoid.N:First[0]) <(Types.Name, Types.Id,
                                                               [Types.FType])>_N)
                            : y ys
                            -> case y of wild2 { (,,) ds1 ds2 ft ->
                               case (TransformationMonad.getFunctionId_go ft w1)
                                      `cast`
                                    (Data.Monoid.N:All[0]) of wild3 {
                                 GHC.Types.False -> go ys
                                 GHC.Types.True
                                 -> (GHC.Base.Just @ (Types.Name, Types.Id, [Types.FType]) wild2)
                                      `cast`
                                    (Sym (Data.Monoid.N:First[0]) <(Types.Name, Types.Id,
                                                                    [Types.FType])>_N) } } }
                      } in
                      case (go wild)
                             `cast`
                           (Data.Monoid.N:First[0] <(Types.Name, Types.Id,
                                                     [Types.FType])>_N) of wild1 {
                        GHC.Base.Nothing
                        -> (# case GHC.Base.map
                                     @ (Types.Name, Types.Id, [Types.FType])
                                     @ GHC.Types.Int
                                     (TransformationMonad.getFunctionId_takeId
                                        @ [Types.FType]
                                        @ Types.Name
                                        @ Types.Id)
                                     wild of wild2 {
                                [] -> GHC.List.maximum2
                                : ipv2 ipv3
                                -> case ipv2 of ww18 { GHC.Types.I# ww19 ->
                                   case GHC.List.$wgo ipv3 ww19 of ww20 { DEFAULT ->
                                   GHC.Types.I# (GHC.Prim.+# ww20 1#) } } },
                              Types.TState
                                ww
                                ww1
                                ww2
                                ww3
                                ww4
                                ww5
                                ww6
                                ww7
                                ww8
                                ww9
                                ww10
                                ww11
                                ww12
                                ww13
                                ww14
                                ww15
                                ww16
                                ww17 #)
                        GHC.Base.Just ds
                        -> case ds of wild2 { (,,) ds1 i ds2 ->
                           (# i,
                              Types.TState
                                ww
                                ww1
                                ww2
                                ww3
                                ww4
                                ww5
                                ww6
                                ww7
                                ww8
                                ww9
                                ww10
                                ww11
                                ww12
                                ww13
                                ww14
                                ww15
                                ww16
                                ww17 #) } } }) -}
1f2ada62e9c8a6fc9f83e5690a26f5a9
  $wgetLogicalOutput ::
    Types.Name
    -> Types.TState
    -> (# (Types.Name, Types.FType, GHC.Base.Maybe GHC.Types.Int),
          Types.TState #)
  {- Arity: 2,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 (# case w1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                    letrec {
                      go :: [(Types.Name, Types.Name, Types.FType,
                              GHC.Base.Maybe GHC.Types.Int)]
                            -> Data.Monoid.First
                                 (Types.Name, Types.Name, Types.FType, GHC.Base.Maybe GHC.Types.Int)
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [(Types.Name, Types.Name, Types.FType,
                                   GHC.Base.Maybe GHC.Types.Int)]) ->
                        case ds of wild1 {
                          []
                          -> (GHC.Base.Nothing
                                @ (Types.Name, Types.Name, Types.FType,
                                   GHC.Base.Maybe GHC.Types.Int))
                               `cast`
                             (Sym (Data.Monoid.N:First[0]) <(Types.Name, Types.Name,
                                                             Types.FType,
                                                             GHC.Base.Maybe GHC.Types.Int)>_N)
                          : y ys
                          -> case y of wild2 { (,,,) f ds22 ds23 ds24 ->
                             case GHC.Base.eqString f w of wild3 {
                               GHC.Types.False -> go ys
                               GHC.Types.True
                               -> (GHC.Base.Just
                                     @ (Types.Name, Types.Name, Types.FType,
                                        GHC.Base.Maybe GHC.Types.Int)
                                     wild2)
                                    `cast`
                                  (Sym (Data.Monoid.N:First[0]) <(Types.Name, Types.Name,
                                                                  Types.FType,
                                                                  GHC.Base.Maybe
                                                                    GHC.Types.Int)>_N) } } }
                    } in
                    case (go ds15)
                           `cast`
                         (Data.Monoid.N:First[0] <(Types.Name, Types.Name, Types.FType,
                                                   GHC.Base.Maybe GHC.Types.Int)>_N) of wild1 {
                      GHC.Base.Nothing
                      -> case Aux.just1
                         ret_ty (Types.Name, Types.FType, GHC.Base.Maybe GHC.Types.Int)
                         of {}
                      GHC.Base.Just x1
                      -> case x1 of wild2 { (,,,) a b f c -> (b, f, c) } } },
                    w1 #)) -}
19fc30e083a744d8680b5c7136a2ab85
  $wgetNextInstance ::
    Types.CompName
    -> Types.Name
    -> Types.TState
    -> (# GHC.Base.Maybe Types.TInst, Types.TState #)
  {- Arity: 3,
     Strictness: <L,U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: Types.CompName)
                   (w1 :: Types.Name)
                   (w2 :: Types.TState) ->
                 case TransformationMonad.$wsearchInstances
                        w
                        w1
                        w2 of ww { (#,#) ww1 ww2 ->
                 let {
                   allUsed :: Data.Monoid.All
                   = TransformationMonad.getNextInstance_go ww1
                 } in
                 let {
                   karg :: Types.TState
                   = case allUsed `cast` (Data.Monoid.N:All[0]) of wild {
                       GHC.Types.False -> ww2
                       GHC.Types.True
                       -> case ww2 of wild1 { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                          Types.TState
                            ds
                            ds1
                            ds2
                            ds3
                            ds4
                            ds5
                            ds6
                            (GHC.Types.:
                               @ Types.TLog
                               (Types.TLogErr
                                  (Types.TErr
                                     Types.AllInstancesUsed
                                     (GHC.Base.Nothing @ Types.WhereMsg)
                                     (GHC.CString.unpackAppendCString#
                                        "All instances of "#
                                        (GHC.Base.++
                                           @ GHC.Types.Char
                                           w1
                                           (GHC.CString.unpackAppendCString# " in "# w)))
                                     Lexer.NoLoc)
                                  ds4)
                               ds7)
                            ds8
                            ds9
                            ds10
                            ds11
                            ds12
                            ds13
                            ds14
                            ds15
                            ds16
                            ds17 } }
                 } in
                 case allUsed `cast` (Data.Monoid.N:All[0]) of wild {
                   GHC.Types.False
                   -> case karg of ww3 { Types.TState ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ww19 ww20 ww21 ->
                      TransformationMonad.$wgetUniqueInstance
                        w
                        (Types.NameId
                           w1
                           (case GHC.Base.map
                                   @ (Types.CompName, Types.Id, Types.NameId, Types.I, Types.Used)
                                   @ (Types.Id, Types.Used)
                                   TransformationMonad.getNextInstance2
                                   ww1 of wild1 {
                              [] -> case GHC.List.foldl2 ret_ty Types.Id of {}
                              : x1 xs
                              -> case x1 of ww22 { (,) ww23 ww24 ->
                                 case TransformationMonad.$wgo
                                        xs
                                        ww23
                                        ww24 of ww25 { (#,#) ww26 ww27 ->
                                 ww26 } } }))
                        ww4
                        ww5
                        ww6
                        ww7
                        ww8
                        ww9
                        ww10
                        ww11
                        ww12
                        ww13
                        ww14
                        ww15
                        ww16
                        ww17
                        ww18
                        ww19
                        ww20
                        ww21 }
                   GHC.Types.True
                   -> (# GHC.Base.Nothing @ Types.TInst, karg #) } }) -}
8edda5924a884fbfaa5bf4873035a07a
  $wgetUniqueInstance ::
    Types.CompName
    -> Types.NameId
    -> Types.SourceCode
    -> [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used)]
    -> [(Types.Name, [Types.Constraint], [Types.CFType])]
    -> [([Types.Constraint], [Types.CFType])]
    -> Types.TStage
    -> [(Types.CFType, Types.CFType)]
    -> Types.TCore
    -> [Types.TLog]
    -> [Types.TFunc]
    -> [(Types.Name, Types.Id, [Types.FType])]
    -> [Types.TComp]
    -> [Types.TInst]
    -> [Types.CConn]
    -> [Types.Name]
    -> [(Types.Name, Types.Name, Types.FType,
         GHC.Base.Maybe GHC.Types.Int)]
    -> Types.SystemC
    -> [(Types.CompName, GHC.Base.String, GHC.Types.Int)]
    -> Types.Core
    -> (# GHC.Base.Maybe Types.TInst, Types.TState #)
  {- Arity: 20,
     Strictness: <L,U><L,U(U,U(U))><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><S,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Types.CompName)
                   (w1 :: Types.NameId)
                   (ww :: Types.SourceCode)
                   (ww1 :: [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                             Types.Used)])
                   (ww2 :: [(Types.Name, [Types.Constraint], [Types.CFType])])
                   (ww3 :: [([Types.Constraint], [Types.CFType])])
                   (ww4 :: Types.TStage)
                   (ww5 :: [(Types.CFType, Types.CFType)])
                   (ww6 :: Types.TCore)
                   (ww7 :: [Types.TLog])
                   (ww8 :: [Types.TFunc])
                   (ww9 :: [(Types.Name, Types.Id, [Types.FType])])
                   (ww10 :: [Types.TComp])
                   (ww11 :: [Types.TInst])
                   (ww12 :: [Types.CConn])
                   (ww13 :: [Types.Name])
                   (ww14 :: [(Types.Name, Types.Name, Types.FType,
                              GHC.Base.Maybe GHC.Types.Int)])
                   (ww15 :: Types.SystemC)
                   (ww16 :: [(Types.CompName, GHC.Base.String, GHC.Types.Int)])
                   (ww17 :: Types.Core) ->
                 letrec {
                   go :: [(Types.CompName, Types.Id, Types.NameId, Types.I,
                           Types.Used)]
                         -> Data.Monoid.First
                              (Types.CompName, Types.Id, Types.NameId, Types.I, Types.Used)
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(Types.CompName, Types.Id, Types.NameId, Types.I,
                                Types.Used)]) ->
                     case ds of wild {
                       []
                       -> (GHC.Base.Nothing
                             @ (Types.CompName, Types.Id, Types.NameId, Types.I, Types.Used))
                            `cast`
                          (Sym (Data.Monoid.N:First[0]) <(Types.CompName, Types.Id,
                                                          Types.NameId, Types.I, Types.Used)>_N)
                       : y ys
                       -> case y of wild1 { (,,,,) comp' ds1 nameId' ds2 ds3 ->
                          case nameId' of ww18 { Types.NameId ww19 ww20 ->
                          case w1 of ww21 { Types.NameId ww22 ww23 ->
                          case GHC.Base.eqString ww19 ww22 of wild2 {
                            GHC.Types.False -> go ys
                            GHC.Types.True
                            -> case ww20 of wild3 { GHC.Types.I# x1 ->
                               case ww23 of wild4 { GHC.Types.I# y1 ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.==# x1 y1) of wild5 {
                                 GHC.Types.False -> go ys
                                 GHC.Types.True
                                 -> case GHC.Base.eqString comp' w of wild6 {
                                      GHC.Types.False -> go ys
                                      GHC.Types.True
                                      -> (GHC.Base.Just
                                            @ (Types.CompName, Types.Id, Types.NameId, Types.I,
                                               Types.Used)
                                            wild1)
                                           `cast`
                                         (Sym (Data.Monoid.N:First[0]) <(Types.CompName, Types.Id,
                                                                         Types.NameId, Types.I,
                                                                         Types.Used)>_N) } } } } } } } } }
                 } in
                 case (go ww11)
                        `cast`
                      (Data.Monoid.N:First[0] <(Types.CompName, Types.Id, Types.NameId,
                                                Types.I, Types.Used)>_N) of wild {
                   GHC.Base.Nothing
                   -> (# GHC.Base.Nothing @ Types.TInst,
                         Types.TState
                           ww
                           ww1
                           ww2
                           ww3
                           ww4
                           ww5
                           ww6
                           (GHC.Types.:
                              @ Types.TLog
                              (Types.TLogErr
                                 (Types.TErr
                                    Types.UniqueInstanceNotFound
                                    (GHC.Base.Nothing @ Types.WhereMsg)
                                    (GHC.CString.unpackAppendCString#
                                       "Unique instance "#
                                       (case w1 of ww18 { Types.NameId ww19 ww20 ->
                                        GHC.Base.++
                                          @ GHC.Types.Char
                                          (Types.$w$cshowsPrec3
                                             0#
                                             ww19
                                             ww20
                                             (GHC.Types.[] @ GHC.Types.Char))
                                          TransformationMonad.getNextInstance3 }))
                                    Lexer.NoLoc)
                                 ww4)
                              ww7)
                           ww8
                           ww9
                           ww10
                           ww11
                           ww12
                           ww13
                           ww14
                           ww15
                           ww16
                           ww17 #)
                   GHC.Base.Just i
                   -> (# wild,
                         Types.TState
                           ww
                           ww1
                           ww2
                           ww3
                           ww4
                           ww5
                           ww6
                           ww7
                           ww8
                           ww9
                           ww10
                           ww11
                           ww12
                           ww13
                           ww14
                           ww15
                           ww16
                           ww17 #) }) -}
15d3b44caf2846690251a7273bb7e4f0
  $wgo ::
    [(Types.Id, GHC.Types.Bool)]
    -> Types.Id -> GHC.Types.Bool -> (# Types.Id, GHC.Types.Bool #)
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,U(U)><L,U>,
     Inline: [0] -}
320b6a15273e968e819db9e2e610b71c
  $wincrementForkedIndex ::
    Types.CompName
    -> GHC.Base.String
    -> Types.SourceCode
    -> [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used)]
    -> [(Types.Name, [Types.Constraint], [Types.CFType])]
    -> [([Types.Constraint], [Types.CFType])]
    -> Types.TStage
    -> [(Types.CFType, Types.CFType)]
    -> Types.TCore
    -> [Types.TLog]
    -> [Types.TFunc]
    -> [(Types.Name, Types.Id, [Types.FType])]
    -> [Types.TComp]
    -> [Types.TInst]
    -> [Types.CConn]
    -> [Types.Name]
    -> [(Types.Name, Types.Name, Types.FType,
         GHC.Base.Maybe GHC.Types.Int)]
    -> Types.SystemC
    -> [(Types.CompName, GHC.Base.String, GHC.Types.Int)]
    -> Types.Core
    -> (# (), Types.TState #)
  {- Arity: 20, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Types.CompName)
                   (w1 :: GHC.Base.String)
                   (ww :: Types.SourceCode)
                   (ww1 :: [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                             Types.Used)])
                   (ww2 :: [(Types.Name, [Types.Constraint], [Types.CFType])])
                   (ww3 :: [([Types.Constraint], [Types.CFType])])
                   (ww4 :: Types.TStage)
                   (ww5 :: [(Types.CFType, Types.CFType)])
                   (ww6 :: Types.TCore)
                   (ww7 :: [Types.TLog])
                   (ww8 :: [Types.TFunc])
                   (ww9 :: [(Types.Name, Types.Id, [Types.FType])])
                   (ww10 :: [Types.TComp])
                   (ww11 :: [Types.TInst])
                   (ww12 :: [Types.CConn])
                   (ww13 :: [Types.Name])
                   (ww14 :: [(Types.Name, Types.Name, Types.FType,
                              GHC.Base.Maybe GHC.Types.Int)])
                   (ww15 :: Types.SystemC)
                   (ww16 :: [(Types.CompName, GHC.Base.String, GHC.Types.Int)])
                   (ww17 :: Types.Core) ->
                 let {
                   $j :: GHC.Types.Int -> Types.TState -> (# (), Types.TState #)
                     {- Arity: 2 -}
                   = \ (ww18 :: GHC.Types.Int)[OneShot]
                       (ww19 :: Types.TState)[OneShot] ->
                     case ww19 of ww20 { Types.TState ww21 ww22 ww23 ww24 ww25 ww26 ww27 ww28 ww29 ww30 ww31 ww32 ww33 ww34 ww35 ww36 ww37 ww38 ->
                     TransformationMonad.$wputForkedIndex
                       w
                       w1
                       (case ww18 of wild { GHC.Types.I# x1 ->
                        GHC.Types.I# (GHC.Prim.+# x1 1#) })
                       ww21
                       ww22
                       ww23
                       ww24
                       ww25
                       ww26
                       ww27
                       ww28
                       ww29
                       ww30
                       ww31
                       ww32
                       ww33
                       ww34
                       ww35
                       ww36
                       ww37
                       ww38 }
                 } in
                 letrec {
                   go :: [(Types.CompName, GHC.Base.String, GHC.Types.Int)]
                         -> Data.Monoid.First
                              (Types.CompName, GHC.Base.String, GHC.Types.Int)
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(Types.CompName, GHC.Base.String, GHC.Types.Int)]) ->
                     case ds of wild {
                       []
                       -> (GHC.Base.Nothing
                             @ (Types.CompName, GHC.Base.String, GHC.Types.Int))
                            `cast`
                          (Sym (Data.Monoid.N:First[0]) <(Types.CompName, GHC.Base.String,
                                                          GHC.Types.Int)>_N)
                       : y ys
                       -> case y of wild1 { (,,) c i ds1 ->
                          case GHC.Base.eqString c w of wild2 {
                            GHC.Types.False -> go ys
                            GHC.Types.True
                            -> case GHC.Base.eqString i w1 of wild3 {
                                 GHC.Types.False -> go ys
                                 GHC.Types.True
                                 -> (GHC.Base.Just
                                       @ (Types.CompName, GHC.Base.String, GHC.Types.Int)
                                       wild1)
                                      `cast`
                                    (Sym (Data.Monoid.N:First[0]) <(Types.CompName, GHC.Base.String,
                                                                    GHC.Types.Int)>_N) } } } }
                 } in
                 case (go ww16)
                        `cast`
                      (Data.Monoid.N:First[0] <(Types.CompName, GHC.Base.String,
                                                GHC.Types.Int)>_N) of wild {
                   GHC.Base.Nothing
                   -> $j
                        TransformationMonad.getForkedIndex2
                        (Types.TState
                           ww
                           ww1
                           ww2
                           ww3
                           ww4
                           ww5
                           ww6
                           ww7
                           ww8
                           ww9
                           ww10
                           ww11
                           ww12
                           ww13
                           ww14
                           ww15
                           (GHC.Types.:
                              @ (Types.CompName, GHC.Base.String, GHC.Types.Int)
                              (w, w1, TransformationMonad.getForkedIndex2)
                              ww16)
                           ww17)
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,,) ds1 ds2 c ->
                      $j
                        c
                        (Types.TState
                           ww
                           ww1
                           ww2
                           ww3
                           ww4
                           ww5
                           ww6
                           ww7
                           ww8
                           ww9
                           ww10
                           ww11
                           ww12
                           ww13
                           ww14
                           ww15
                           ww16
                           ww17) } }) -}
a67f400c9a52a8bf86773500c7675c42
  $wisThereTypeChange ::
    Types.CFType -> Types.TState -> (# GHC.Types.Bool, Types.TState #)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: Types.CFType) (w1 :: Types.TState) ->
                 (# case w1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                    letrec {
                      go :: [(Types.CFType, Types.CFType)]
                            -> Data.Monoid.First (Types.CFType, Types.CFType)
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [(Types.CFType, Types.CFType)]) ->
                        case ds of wild1 {
                          []
                          -> (GHC.Base.Nothing @ (Types.CFType, Types.CFType))
                               `cast`
                             (Sym (Data.Monoid.N:First[0]) <(Types.CFType, Types.CFType)>_N)
                          : y ys
                          -> case Types.$fEqCFType_$c==
                                    (Data.Tuple.fst @ Types.CFType @ Types.CFType y)
                                    w of wild2 {
                               GHC.Types.False -> go ys
                               GHC.Types.True
                               -> (GHC.Base.Just @ (Types.CFType, Types.CFType) y)
                                    `cast`
                                  (Sym (Data.Monoid.N:First[0]) <(Types.CFType,
                                                                  Types.CFType)>_N) } }
                    } in
                    case (go ds6)
                           `cast`
                         (Data.Monoid.N:First[0] <(Types.CFType,
                                                   Types.CFType)>_N) of wild1 {
                      GHC.Base.Nothing -> GHC.Types.False
                      GHC.Base.Just ds -> GHC.Types.True } },
                    w1 #)) -}
641ef806f74604252fbc9b95f456a6d1
  $wisTypeRecursive ::
    Types.Name -> Types.TState -> (# GHC.Types.Bool, Types.TState #)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 let {
                   ds :: Data.Functor.Identity.Identity ([Types.IsRec], Types.TState)
                   = case w1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                     letrec {
                       $wgo1 :: [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                                  Types.Used)]
                                -> Types.TState -> (# [Types.IsRec], Types.TState #)
                         {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                       = \ (w2 :: [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                                    Types.Used)])
                           (w3 :: Types.TState) ->
                         case w2 of wild1 {
                           [] -> (# GHC.Types.[] @ Types.IsRec, w3 #)
                           : y ys
                           -> let {
                                ds22 :: Data.Functor.Identity.Identity (Types.IsRec, Types.TState)
                                = case y of wild2 { (,,,) ds23 ds24 isRec ds25 ->
                                  case ds23 of wild3 { Lexer.L ds26 n ->
                                  case GHC.Base.eqString n w of wild4 {
                                    GHC.Types.False
                                    -> (GHC.Types.False, w3)
                                         `cast`
                                       (Sym (Data.Functor.Identity.N:Identity[0]
                                                 <(GHC.Types.Bool, Types.TState)>_R))
                                    GHC.Types.True
                                    -> (isRec, w3)
                                         `cast`
                                       (Sym (Data.Functor.Identity.N:Identity[0]
                                                 <(Types.IsRec, Types.TState)>_R)) } } }
                              } in
                              let {
                                ds23 :: Data.Functor.Identity.Identity
                                          ([Types.IsRec], Types.TState)
                                = case $wgo1
                                         ys
                                         (case ds22
                                                 `cast`
                                               (Data.Functor.Identity.N:Identity[0]
                                                    <(Types.IsRec,
                                                      Types.TState)>_R) of wild2 { (,) a1 s' ->
                                          s' }) of ww { (#,#) ww1 ww2 ->
                                  (ww1, ww2)
                                    `cast`
                                  (Sym (Data.Functor.Identity.N:Identity[0]
                                            <([Types.IsRec], Types.TState)>_R)) }
                              } in
                              (# GHC.Types.:
                                   @ Types.IsRec
                                   (case ds22
                                           `cast`
                                         (Data.Functor.Identity.N:Identity[0]
                                              <(Types.IsRec,
                                                Types.TState)>_R) of wild2 { (,) a1 s' ->
                                    a1 })
                                   (case ds23
                                           `cast`
                                         (Data.Functor.Identity.N:Identity[0]
                                              <([Types.IsRec],
                                                Types.TState)>_R) of wild2 { (,) x1 s'' ->
                                    x1 }),
                                 case ds23
                                        `cast`
                                      (Data.Functor.Identity.N:Identity[0]
                                           <([Types.IsRec],
                                             Types.TState)>_R) of wild2 { (,) x1 s'' ->
                                 s'' } #) }
                     } in
                     case $wgo1 ds2 wild of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2)
                       `cast`
                     (Sym (Data.Functor.Identity.N:Identity[0]
                               <([Types.IsRec], Types.TState)>_R)) } }
                 } in
                 (# case ds
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <([Types.IsRec], Types.TState)>_R) of wild { (,) a1 s' ->
                    (TransformationMonad.isTypeRecursive_go a1)
                      `cast`
                    (Data.Monoid.N:Any[0]) },
                    case ds
                           `cast`
                         (Data.Functor.Identity.N:Identity[0]
                              <([Types.IsRec], Types.TState)>_R) of wild { (,) a1 s' ->
                    s' } #)) -}
d4be00f4bb68b7e772c0e372930abf96
  $wmodifyUniqueInstance ::
    Types.CompName
    -> Types.NameId
    -> (Types.TInst -> Types.TInst)
    -> Types.SourceCode
    -> [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used)]
    -> [(Types.Name, [Types.Constraint], [Types.CFType])]
    -> [([Types.Constraint], [Types.CFType])]
    -> Types.TStage
    -> [(Types.CFType, Types.CFType)]
    -> Types.TCore
    -> [Types.TLog]
    -> [Types.TFunc]
    -> [(Types.Name, Types.Id, [Types.FType])]
    -> [Types.TComp]
    -> [Types.TInst]
    -> [Types.CConn]
    -> [Types.Name]
    -> [(Types.Name, Types.Name, Types.FType,
         GHC.Base.Maybe GHC.Types.Int)]
    -> Types.SystemC
    -> [(Types.CompName, GHC.Base.String, GHC.Types.Int)]
    -> Types.Core
    -> (# GHC.Base.Maybe (), Types.TState #)
  {- Arity: 21,
     Strictness: <L,U><L,U(U,U(U))><L,C(U)><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><S,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Types.CompName)
                   (w1 :: Types.NameId)
                   (w2 :: Types.TInst -> Types.TInst)
                   (ww :: Types.SourceCode)
                   (ww1 :: [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                             Types.Used)])
                   (ww2 :: [(Types.Name, [Types.Constraint], [Types.CFType])])
                   (ww3 :: [([Types.Constraint], [Types.CFType])])
                   (ww4 :: Types.TStage)
                   (ww5 :: [(Types.CFType, Types.CFType)])
                   (ww6 :: Types.TCore)
                   (ww7 :: [Types.TLog])
                   (ww8 :: [Types.TFunc])
                   (ww9 :: [(Types.Name, Types.Id, [Types.FType])])
                   (ww10 :: [Types.TComp])
                   (ww11 :: [Types.TInst])
                   (ww12 :: [Types.CConn])
                   (ww13 :: [Types.Name])
                   (ww14 :: [(Types.Name, Types.Name, Types.FType,
                              GHC.Base.Maybe GHC.Types.Int)])
                   (ww15 :: Types.SystemC)
                   (ww16 :: [(Types.CompName, GHC.Base.String, GHC.Types.Int)])
                   (ww17 :: Types.Core) ->
                 case TransformationMonad.$wgetUniqueInstance
                        w
                        w1
                        ww
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        ww6
                        ww7
                        ww8
                        ww9
                        ww10
                        ww11
                        ww12
                        ww13
                        ww14
                        ww15
                        ww16
                        ww17 of ww18 { (#,#) ww19 ww20 ->
                 case ww19 of wild {
                   GHC.Base.Nothing
                   -> (# GHC.Base.Nothing @ (),
                         case ww20 of wild1 { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                         Types.TState
                           ds
                           ds1
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           (GHC.Types.:
                              @ Types.TLog
                              (Types.TLogErr TransformationMonad.modifyUniqueInstance2 ds4)
                              ds7)
                           ds8
                           ds9
                           ds10
                           ds11
                           ds12
                           ds13
                           ds14
                           ds15
                           ds16
                           ds17 } #)
                   GHC.Base.Just ds1
                   -> (# TransformationMonad.changeFunction3,
                         case ww20 of wild1 { Types.TState ds ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                         Types.TState
                           ds
                           ds2
                           ds3
                           ds4
                           ds5
                           ds6
                           ds7
                           ds8
                           ds9
                           ds10
                           ds11
                           (GHC.Base.map
                              @ (Types.CompName, Types.Id, Types.NameId, Types.I, Types.Used)
                              @ (Types.CompName, Types.Id, Types.NameId, Types.I, Types.Used)
                              (\ (i :: (Types.CompName, Types.Id, Types.NameId, Types.I,
                                        Types.Used)) ->
                               case i of wild2 { (,,,,) ds19 ds20 nid' ds21 ds22 ->
                               case w1 of ww21 { Types.NameId ww22 ww23 ->
                               case nid' of ww24 { Types.NameId ww25 ww26 ->
                               case GHC.Base.eqString ww22 ww25 of wild3 {
                                 GHC.Types.False -> wild2
                                 GHC.Types.True
                                 -> case ww23 of wild4 { GHC.Types.I# x1 ->
                                    case ww26 of wild5 { GHC.Types.I# y ->
                                    case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.==# x1 y) of wild6 {
                                      GHC.Types.False -> wild2
                                      GHC.Types.True -> w2 wild2 } } } } } } })
                              ds12)
                           ds13
                           ds14
                           ds15
                           ds16
                           ds17
                           ds18 } #) } }) -}
05e2f91eb33c3e6f924bb1d9354c8603
  $wnewStage ::
    Types.TStage -> Types.TState -> (# (), Types.TState #)
  {- Arity: 2,
     Strictness: <L,U><L,1*U(U,U,U,U,A,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: Types.TStage) (w1 :: Types.TState) ->
                 (# GHC.Tuple.(),
                    case w1 of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                    Types.TState
                      ds
                      ds1
                      ds2
                      ds3
                      w
                      ds5
                      ds6
                      (GHC.Types.:
                         @ Types.TLog
                         (Types.TLog
                            (GHC.CString.unpackAppendCString#
                               "Entering stage "#
                               (case w of wild1 {
                                  Types.TInitialStage -> Types.$fShowTLog5
                                  Types.TInterpretationStage -> Types.$fShowTLog4 }))
                            w)
                         ds7)
                      ds8
                      ds9
                      ds10
                      ds11
                      ds12
                      ds13
                      ds14
                      ds15
                      ds16
                      ds17 } #)) -}
0529b3d99d897c9bd80682ebaef4457a
  $wputForkedIndex ::
    Types.CompName
    -> GHC.Base.String
    -> GHC.Types.Int
    -> Types.SourceCode
    -> [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used)]
    -> [(Types.Name, [Types.Constraint], [Types.CFType])]
    -> [([Types.Constraint], [Types.CFType])]
    -> Types.TStage
    -> [(Types.CFType, Types.CFType)]
    -> Types.TCore
    -> [Types.TLog]
    -> [Types.TFunc]
    -> [(Types.Name, Types.Id, [Types.FType])]
    -> [Types.TComp]
    -> [Types.TInst]
    -> [Types.CConn]
    -> [Types.Name]
    -> [(Types.Name, Types.Name, Types.FType,
         GHC.Base.Maybe GHC.Types.Int)]
    -> Types.SystemC
    -> [(Types.CompName, GHC.Base.String, GHC.Types.Int)]
    -> Types.Core
    -> (# (), Types.TState #)
  {- Arity: 21, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ (w :: Types.CompName)
                   (w1 :: GHC.Base.String)
                   (w2 :: GHC.Types.Int)
                   (ww :: Types.SourceCode)
                   (ww1 :: [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                             Types.Used)])
                   (ww2 :: [(Types.Name, [Types.Constraint], [Types.CFType])])
                   (ww3 :: [([Types.Constraint], [Types.CFType])])
                   (ww4 :: Types.TStage)
                   (ww5 :: [(Types.CFType, Types.CFType)])
                   (ww6 :: Types.TCore)
                   (ww7 :: [Types.TLog])
                   (ww8 :: [Types.TFunc])
                   (ww9 :: [(Types.Name, Types.Id, [Types.FType])])
                   (ww10 :: [Types.TComp])
                   (ww11 :: [Types.TInst])
                   (ww12 :: [Types.CConn])
                   (ww13 :: [Types.Name])
                   (ww14 :: [(Types.Name, Types.Name, Types.FType,
                              GHC.Base.Maybe GHC.Types.Int)])
                   (ww15 :: Types.SystemC)
                   (ww16 :: [(Types.CompName, GHC.Base.String, GHC.Types.Int)])
                   (ww17 :: Types.Core) ->
                 letrec {
                   go :: [(Types.CompName, GHC.Base.String, GHC.Types.Int)]
                         -> Data.Monoid.First
                              (Types.CompName, GHC.Base.String, GHC.Types.Int)
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(Types.CompName, GHC.Base.String, GHC.Types.Int)]) ->
                     case ds of wild {
                       []
                       -> (GHC.Base.Nothing
                             @ (Types.CompName, GHC.Base.String, GHC.Types.Int))
                            `cast`
                          (Sym (Data.Monoid.N:First[0]) <(Types.CompName, GHC.Base.String,
                                                          GHC.Types.Int)>_N)
                       : y ys
                       -> case y of wild1 { (,,) c i ds1 ->
                          case GHC.Base.eqString c w of wild2 {
                            GHC.Types.False -> go ys
                            GHC.Types.True
                            -> case GHC.Base.eqString i w1 of wild3 {
                                 GHC.Types.False -> go ys
                                 GHC.Types.True
                                 -> (GHC.Base.Just
                                       @ (Types.CompName, GHC.Base.String, GHC.Types.Int)
                                       wild1)
                                      `cast`
                                    (Sym (Data.Monoid.N:First[0]) <(Types.CompName, GHC.Base.String,
                                                                    GHC.Types.Int)>_N) } } } }
                 } in
                 case (go ww16)
                        `cast`
                      (Data.Monoid.N:First[0] <(Types.CompName, GHC.Base.String,
                                                GHC.Types.Int)>_N) of wild {
                   GHC.Base.Nothing
                   -> (# GHC.Tuple.(),
                         Types.TState
                           ww
                           ww1
                           ww2
                           ww3
                           ww4
                           ww5
                           ww6
                           ww7
                           ww8
                           ww9
                           ww10
                           ww11
                           ww12
                           ww13
                           ww14
                           ww15
                           ww16
                           ww17 #)
                   GHC.Base.Just ds
                   -> (# GHC.Tuple.(),
                         Types.TState
                           ww
                           ww1
                           ww2
                           ww3
                           ww4
                           ww5
                           ww6
                           ww7
                           ww8
                           ww9
                           ww10
                           ww11
                           ww12
                           ww13
                           ww14
                           ww15
                           (GHC.Base.map
                              @ (Types.CompName, GHC.Base.String, GHC.Types.Int)
                              @ (Types.CompName, GHC.Base.String, GHC.Types.Int)
                              (\ (ds1 :: (Types.CompName, GHC.Base.String, GHC.Types.Int)) ->
                               case ds1 of wild1 { (,,) c i ind ->
                               case GHC.Base.eqString c w of wild2 {
                                 GHC.Types.False -> wild1
                                 GHC.Types.True
                                 -> case GHC.Base.eqString i w1 of wild3 {
                                      GHC.Types.False -> wild1 GHC.Types.True -> (c, i, w2) } } })
                              ww16)
                           ww17 #) }) -}
0ad617c34faecf996b7cf3653686dc20
  $wsearchComponent ::
    Types.Name
    -> Types.TState
    -> (# GHC.Base.Maybe (Types.Name, Types.C), Types.TState #)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 (# case w1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                    letrec {
                      go :: [(Types.Name, Types.C)]
                            -> Data.Monoid.First (Types.Name, Types.C)
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [(Types.Name, Types.C)]) ->
                        case ds of wild1 {
                          []
                          -> (GHC.Base.Nothing @ (Types.Name, Types.C))
                               `cast`
                             (Sym (Data.Monoid.N:First[0]) <(Types.Name, Types.C)>_N)
                          : y ys
                          -> case y of wild2 { (,) n ds22 ->
                             case GHC.Base.eqString n w of wild3 {
                               GHC.Types.False -> go ys
                               GHC.Types.True
                               -> (GHC.Base.Just @ (Types.Name, Types.C) wild2)
                                    `cast`
                                  (Sym (Data.Monoid.N:First[0]) <(Types.Name, Types.C)>_N) } } }
                    } in
                    (go ds11)
                      `cast`
                    (Data.Monoid.N:First[0] <(Types.Name, Types.C)>_N) },
                    w1 #)) -}
2a82f547d2c6e1a2b3729204c0e4b6bf
  $wsearchDataDecl ::
    Types.Name
    -> Types.TState
    -> (# GHC.Base.Maybe
            (Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used),
          Types.TState #)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 (# case w1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                    letrec {
                      go :: [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                              Types.Used)]
                            -> Data.Monoid.First
                                 (Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used)
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                                   Types.Used)]) ->
                        case ds of wild1 {
                          []
                          -> (GHC.Base.Nothing
                                @ (Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used))
                               `cast`
                             (Sym (Data.Monoid.N:First[0]) <(Lexer.L Types.Name,
                                                             [Types.CConstr], Types.IsRec,
                                                             Types.Used)>_N)
                          : y ys
                          -> case y of wild2 { (,,,) ds22 ds23 ds24 ds25 ->
                             case ds22 of wild3 { Lexer.L ds26 n ->
                             case GHC.Base.eqString n w of wild4 {
                               GHC.Types.False -> go ys
                               GHC.Types.True
                               -> (GHC.Base.Just
                                     @ (Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                                        Types.Used)
                                     wild2)
                                    `cast`
                                  (Sym (Data.Monoid.N:First[0]) <(Lexer.L Types.Name,
                                                                  [Types.CConstr], Types.IsRec,
                                                                  Types.Used)>_N) } } } }
                    } in
                    (go ds2)
                      `cast`
                    (Data.Monoid.N:First[0] <(Lexer.L Types.Name, [Types.CConstr],
                                              Types.IsRec, Types.Used)>_N) },
                    w1 #)) -}
c01c236f2bbfeab09bcd355698a20a1a
  $wsearchFunction ::
    Types.Name
    -> Types.TState
    -> (# GHC.Base.Maybe
            (Types.Name, Lexer.SrcLoc, Types.F, Types.Arity,
             Types.FunctionClassification, Types.HighOrder),
          Types.TState #)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 (# case w1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                    letrec {
                      go :: [(Types.Name, Lexer.SrcLoc, Types.F, Types.Arity,
                              Types.FunctionClassification, Types.HighOrder)]
                            -> Data.Monoid.First
                                 (Types.Name, Lexer.SrcLoc, Types.F, Types.Arity,
                                  Types.FunctionClassification, Types.HighOrder)
                        {- Arity: 1, Strictness: <S,1*U> -}
                      = \ (ds :: [(Types.Name, Lexer.SrcLoc, Types.F, Types.Arity,
                                   Types.FunctionClassification, Types.HighOrder)]) ->
                        case ds of wild1 {
                          []
                          -> (GHC.Base.Nothing
                                @ (Types.Name, Lexer.SrcLoc, Types.F, Types.Arity,
                                   Types.FunctionClassification, Types.HighOrder))
                               `cast`
                             (Sym (Data.Monoid.N:First[0]) <(Types.Name, Lexer.SrcLoc, Types.F,
                                                             Types.Arity,
                                                             Types.FunctionClassification,
                                                             Types.HighOrder)>_N)
                          : y ys
                          -> case y of wild2 { (,,,,,) n ds22 ds23 ds24 ds25 ds26 ->
                             case GHC.Base.eqString n w of wild3 {
                               GHC.Types.False -> go ys
                               GHC.Types.True
                               -> (GHC.Base.Just
                                     @ (Types.Name, Lexer.SrcLoc, Types.F, Types.Arity,
                                        Types.FunctionClassification, Types.HighOrder)
                                     wild2)
                                    `cast`
                                  (Sym (Data.Monoid.N:First[0]) <(Types.Name, Lexer.SrcLoc, Types.F,
                                                                  Types.Arity,
                                                                  Types.FunctionClassification,
                                                                  Types.HighOrder)>_N) } } }
                    } in
                    (go ds9)
                      `cast`
                    (Data.Monoid.N:First[0] <(Types.Name, Lexer.SrcLoc, Types.F,
                                              Types.Arity, Types.FunctionClassification,
                                              Types.HighOrder)>_N) },
                    w1 #)) -}
84d779752ccae081370f56900fc87d8a
  $wsearchInstances ::
    Types.CompName
    -> Types.Name
    -> Types.TState
    -> (# [(Types.CompName, Types.Id, Types.NameId, Types.I,
            Types.Used)],
          Types.TState #)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: Types.CompName)
                   (w1 :: Types.Name)
                   (w2 :: Types.TState) ->
                 (# case w2 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                    GHC.List.filter
                      @ (Types.CompName, Types.Id, Types.NameId, Types.I, Types.Used)
                      (\ (ds :: (Types.CompName, Types.Id, Types.NameId, Types.I,
                                 Types.Used)) ->
                       case ds of wild1 { (,,,,) c ds22 ds23 ds24 ds25 ->
                       case ds23 of wild2 { Types.NameId n ds26 ->
                       case GHC.Base.eqString n w1 of wild3 {
                         GHC.Types.False -> GHC.Types.False
                         GHC.Types.True -> GHC.Base.eqString c w } } })
                      ds12 },
                    w2 #)) -}
d8ad91d044932bb7e7e511434991b0fa
  $wsetDataUsed ::
    Types.Name -> Types.TState -> (# GHC.Base.Maybe (), Types.TState #)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Inline: [0],
     Unfolding: (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 case TransformationMonad.$wsearchDataDecl
                        w
                        w1 of ww { (#,#) ww1 ww2 ->
                 case ww1 of wild {
                   GHC.Base.Nothing -> (# GHC.Base.Nothing @ (), ww2 #)
                   GHC.Base.Just ds1
                   -> case ds1 of wild1 { (,,,) ln ccs isr ds ->
                      (# TransformationMonad.changeFunction3,
                         case ww2 of wild2 { Types.TState ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ds19 ->
                         Types.TState
                           ds2
                           (GHC.Types.:
                              @ (Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                                 GHC.Types.Bool)
                              (ln, ccs, isr, GHC.Types.True)
                              (case w1 of wild3 { Types.TState ds20 ds21 ds22 ds23 ds24 ds25 ds26 ds27 ds28 ds29 ds30 ds31 ds32 ds33 ds34 ds35 ds36 ds37 ->
                               GHC.List.filter
                                 @ (Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used)
                                 (\ (ds38 :: (Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                                              Types.Used)) ->
                                  case ds38 of wild4 { (,,,) ds39 ds40 ds41 ds42 ->
                                  case ds39 of wild5 { Lexer.L ds43 n ->
                                  GHC.Classes.$fEq[]_$s$c/=1 n w } })
                                 ds21 }))
                           ds4
                           ds5
                           ds6
                           ds7
                           ds8
                           ds9
                           ds10
                           ds11
                           ds12
                           ds13
                           ds14
                           ds15
                           ds16
                           ds17
                           ds18
                           ds19 } #) } } }) -}
8ed20ecec98f8f0b49bf2d27c640593e
  addCFuncType ::
    (Types.Name, [Types.Constraint], [Types.CFType]) -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.addCFuncType1
                  `cast`
                (<(Types.Name, [Types.Constraint], [Types.CFType])>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
662bee6d8616cb59b88127dff103c5a4
  addCFuncType1 ::
    (Types.Name, [Types.Constraint], [Types.CFType])
    -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: (Types.Name, [Types.Constraint], [Types.CFType]))
                   (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    (GHC.Types.:
                       @ (Types.Name, [Types.Constraint], [Types.CFType])
                       x1
                       ds2)
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
7a72848ffad21f3c0e0c19c0d325dcef
  addComp :: Types.TComp -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.addComp1
                  `cast`
                (<Types.TComp>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
032c74af95129bf47dd5cd93c3f7ed32
  addComp1 :: Types.TComp -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: Types.TComp) (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    ds8
                    ds9
                    (GHC.Types.: @ Types.TComp x1 ds10)
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
fdc8be5bf5352312f67e4db8285673ef
  addConnection :: Types.CConn -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.addConnection1
                  `cast`
                (<Types.CConn>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
135a63c00f0f94d03aa76bc59fc3d53c
  addConnection1 :: Types.CConn -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (conn :: Types.CConn) (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    ds8
                    ds9
                    ds10
                    ds11
                    (GHC.Types.: @ Types.CConn conn ds12)
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
8f4c7a67603fabef57711a50bb589d14
  addData ::
    (Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used)
    -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.addData1
                  `cast`
                (<(Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used)>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
645e50c8e2529feae95986e2a40620e1
  addData1 ::
    (Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used)
    -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: (Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                           Types.Used))
                   (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    (GHC.Types.:
                       @ (Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used)
                       x1
                       ds1)
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
f6dd3737a3fc289f060578ed833c3c23
  addForkedIndex ::
    (Types.CompName, GHC.Base.String, GHC.Types.Int) -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.addForkedIndex1
                  `cast`
                (<(Types.CompName, GHC.Base.String, GHC.Types.Int)>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
2bdc26748ed7ad63ead2a51045a78a1b
  addForkedIndex1 ::
    (Types.CompName, GHC.Base.String, GHC.Types.Int)
    -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: (Types.CompName, GHC.Base.String, GHC.Types.Int))
                   (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    (GHC.Types.:
                       @ (Types.CompName, GHC.Base.String, GHC.Types.Int)
                       x1
                       ds16)
                    ds17 })) -}
7c89b1e0557c5b793ef5d3b7569e7d6e
  addFunc :: Types.TFunc -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.addFunc1
                  `cast`
                (<Types.TFunc>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
e5c6e3df1131f9b337eeb3d950bcf7ae
  addFunc1 :: Types.TFunc -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: Types.TFunc) (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    (GHC.Types.: @ Types.TFunc x1 ds8)
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
87fb2b85841f28c35a38b2bcaa9bf420
  addFunctionId ::
    (Types.Name, Types.Id, [Types.FType]) -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.addFunctionId1
                  `cast`
                (<(Types.Name, Types.Id, [Types.FType])>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
422051a393cb6818208bc0dbe3623eca
  addFunctionId1 ::
    (Types.Name, Types.Id, [Types.FType])
    -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: (Types.Name, Types.Id, [Types.FType]))
                   (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    ds8
                    (GHC.Types.: @ (Types.Name, Types.Id, [Types.FType]) x1 ds9)
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
4b13051e887503a91cad2d6d4d7467df
  addInstance :: Types.TInst -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.addInstance1
                  `cast`
                (<Types.TInst>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
71f72c22229c1fdaa48ac5a46aae7834
  addInstance1 :: Types.TInst -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (inst :: Types.TInst) (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    ds8
                    ds9
                    ds10
                    (GHC.Types.: @ Types.TInst inst ds11)
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
9b55b4ac40c9d10e20f50b583724bfa9
  addLogicalConnection :: Types.Name -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.addLogicalConnection1
                  `cast`
                (<Types.Name>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
c7e05eac29bb7ab519918ccb1f02e158
  addLogicalConnection1 ::
    Types.Name -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (conn :: Types.Name) (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    (GHC.Types.: @ Types.Name conn ds13)
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
c507afeb5740932ee1cbc8e9746eb185
  addLogicalOutput ::
    (Types.Name, Types.Name, Types.FType, GHC.Base.Maybe GHC.Types.Int)
    -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.addLogicalOutput1
                  `cast`
                (<(Types.Name, Types.Name, Types.FType,
                   GHC.Base.Maybe GHC.Types.Int)>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
cd88594a5b48093dda1123594eb5ed42
  addLogicalOutput1 ::
    (Types.Name, Types.Name, Types.FType, GHC.Base.Maybe GHC.Types.Int)
    -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (x1 :: (Types.Name, Types.Name, Types.FType,
                           GHC.Base.Maybe GHC.Types.Int))
                   (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    (GHC.Types.:
                       @ (Types.Name, Types.Name, Types.FType,
                          GHC.Base.Maybe GHC.Types.Int)
                       x1
                       ds14)
                    ds15
                    ds16
                    ds17 })) -}
3dc53e7627b3226cd384c0224f42cd72
  addSystemCFile :: Types.File -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.addSystemCFile1
                  `cast`
                (<Types.File>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
c5f1aa25a01b4633360753bd04150112
  addSystemCFile1 :: Types.File -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (file :: Types.File) (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    (GHC.Types.: @ Types.File file ds15)
                    ds16
                    ds17 })) -}
0d49d88e24e3b0e4107e2d50d106ecec
  addTCFunc :: Types.TCFunc -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><S(LLLLLLSLLLLLLLLLLL),1*U(U,U,U,U,U,U,1*U(U),U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.addTCFunc1
                  `cast`
                (<Types.TCFunc>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N)) -}
4b92633ed3c9b739d14ffbeea8736335
  addTCFunc1 ::
    Types.TCFunc
    -> Types.TState
    -> Data.Functor.Identity.Identity ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><S(LLLLLLSLLLLLLLLLLL),1*U(U,U,U,U,U,U,1*U(U),U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (f :: Types.TCFunc) (eta :: Types.TState) ->
                 case eta of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                 case ds7 of wild1 { Types.TCore fs ->
                 (GHC.Tuple.(),
                  Types.TState
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    (Types.TCore (GHC.Types.: @ Types.TCFunc f fs))
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17
                    ds18)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <((), Types.TState)>_R)) } }) -}
481bc38d2d9f04b79a36ec30985cf32f
  addTypeChange :: Types.Name -> GHC.Types.Int -> Types.TM ()
  {- Arity: 3,
     Strictness: <L,U><L,1*U(U)><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.addTypeChange1
                  `cast`
                (<Types.Name>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
181d43fee00b0f1fde4aa1f9118aa75b
  addTypeChange1 ::
    Types.Name -> GHC.Types.Int -> Types.TState -> ((), Types.TState)
  {- Arity: 3,
     Strictness: <L,U><L,1*U(U)><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.Name) (w1 :: GHC.Types.Int) (w2 :: Types.TState) ->
                 case TransformationMonad.$waddTypeChange
                        w
                        w1
                        w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
30bd39318d01d9aebf83b998ee396e8d
  addTypeChange2 :: Types.CFType
  {- Strictness: m3,
     Unfolding: (Types.CTAExpr TransformationMonad.addTypeChange3) -}
06c8bbd7be1c758483a65133d2fd8d64
  addTypeChange3 :: Lexer.L Lexer.Token
  {- Strictness: m,
     Unfolding: (Lexer.L
                   @ Lexer.Token
                   Lexer.NoLoc
                   TransformationMonad.addTypeChange4) -}
5e0f43b636bdecf1aca0e636798951ed
  addTypeChange4 :: Lexer.Token
  {- Strictness: m8,
     Unfolding: (Lexer.Upp TransformationMonad.addTypeChange5) -}
c1fc4c8e694328c4fd614eebbf5a965f
  addTypeChange5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Bit"#) -}
c613547da4bc7def4e04b1bb9d8e27f8
  addTypeChange6 :: Lexer.L Lexer.Token
  {- Strictness: m,
     Unfolding: (Lexer.L
                   @ Lexer.Token
                   Lexer.NoLoc
                   TransformationMonad.addTypeChange7) -}
d31eb2282dab819e6e9126216531b302
  addTypeChange7 :: Lexer.Token
  {- Strictness: m8,
     Unfolding: (Lexer.Upp TransformationMonad.addTypeChange8) -}
41f61bc7b316eb8e7a3ea4ea19fe4fce
  addTypeChange8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Vec"#) -}
658e2893372d54e23e8d6f50906affc3
  addTypeChangeStream :: Types.Name -> GHC.Types.Int -> Types.TM ()
  {- Arity: 3,
     Strictness: <L,U><L,1*U(U)><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.addTypeChangeStream1
                  `cast`
                (<Types.Name>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
ee7607ae6ea7f3cc9d8adcadf02b8b47
  addTypeChangeStream1 ::
    Types.Name -> GHC.Types.Int -> Types.TState -> ((), Types.TState)
  {- Arity: 3,
     Strictness: <L,U><L,1*U(U)><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.Name) (w1 :: GHC.Types.Int) (w2 :: Types.TState) ->
                 case TransformationMonad.$waddTypeChangeStream
                        w
                        w1
                        w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
25881d013b8588112af1625b0981c720
  addTypeChangeStream2 :: Types.CFType
  {- Strictness: m1,
     Unfolding: (Types.CTApp
                   TransformationMonad.addTypeChangeStream4
                   TransformationMonad.addTypeChangeStream3) -}
a591eeacac98ac7649370d271db5c4db
  addTypeChangeStream3 :: [Types.CFType]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Types.CFType
                   TransformationMonad.addTypeChange2
                   (GHC.Types.[] @ Types.CFType)) -}
6a9883eec47810476eb8caa441598d24
  addTypeChangeStream4 :: Lexer.L Lexer.Token
  {- Strictness: m,
     Unfolding: (Lexer.L
                   @ Lexer.Token
                   Lexer.NoLoc
                   TransformationMonad.addTypeChangeStream5) -}
7c9359003cf50236bd38115f1836a3ea
  addTypeChangeStream5 :: Lexer.Token
  {- Strictness: m8,
     Unfolding: (Lexer.Upp TransformationMonad.addTypeChangeStream6) -}
570ed97dae0d2a0f3de003ae47b38b2c
  addTypeChangeStream6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Stream"#) -}
115fca06dc9a5b723dbbf7b95f4a727c
  changeFunction :: Types.Name -> Types.FGuards -> Types.TMM ()
  {- Arity: 3,
     Strictness: <L,U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.changeFunction1
                  `cast`
                (<Types.Name>_R
                 ->_R <Types.FGuards>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Base.Maybe ()>_N)) -}
0c6bdb53a4454aace05159118312dc15
  changeFunction1 ::
    Types.Name
    -> Types.FGuards
    -> Types.TState
    -> Data.Functor.Identity.Identity (GHC.Base.Maybe (), Types.TState)
  {- Arity: 3,
     Strictness: <L,U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.Name) (w1 :: Types.FGuards) (w2 :: Types.TState) ->
                 case TransformationMonad.$wchangeFunction
                        w
                        w1
                        w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(GHC.Base.Maybe (), Types.TState)>_R)) }) -}
5dfafac5f6e8533a7994dc62aa1a8acf
  changeFunction2 :: Types.TMM ()
  {- Strictness: x -}
d53da6ca995af7b61b425fbebc84afd7
  changeFunction3 :: GHC.Base.Maybe ()
  {- HasNoCafRefs, Unfolding: (GHC.Base.Just @ () GHC.Tuple.()) -}
e501ceee34c373f8f82622fbb6ecaf5f
  changeType :: Types.CFType -> Types.TMM Types.CFType
  {- Arity: 1, Strictness: <S,U> -}
15ef40196d547ee7c1c037a71afb7acd
  cont :: [GHC.Base.Maybe a] -> Types.TMM b -> Types.TMM b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: (\ @ a
                   @ b
                   (maybes :: [GHC.Base.Maybe a])
                   (cont6 :: Types.TMM b) ->
                 case (TransformationMonad.cont5 @ a maybes)
                        `cast`
                      (Data.Monoid.N:All[0]) of wild {
                   GHC.Types.False
                   -> (TransformationMonad.cont4 @ b)
                        `cast`
                      (Trans
                           (<Types.TState>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                          <(GHC.Base.Maybe b, Types.TState)>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <Types.TState>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <GHC.Base.Maybe b>_N)))
                   GHC.Types.True -> cont6 }) -}
863999094999483849ffafa9f0237d73
  cont1 :: GHC.Base.Maybe a -> (a -> Types.TMM b) -> Types.TMM b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*C1(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a
                   @ b
                   (maybe :: GHC.Base.Maybe a)
                   (cont6 :: a -> Types.TMM b) ->
                 case maybe of wild {
                   GHC.Base.Nothing
                   -> (TransformationMonad.cont4 @ b)
                        `cast`
                      (Trans
                           (<Types.TState>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                          <(GHC.Base.Maybe b, Types.TState)>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <Types.TState>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <GHC.Base.Maybe b>_N)))
                   GHC.Base.Just ds1 -> cont6 ds1 }) -}
4c4faac896508b22afecd9aa4fb01dbf
  cont2 ::
    GHC.Base.Maybe a
    -> GHC.Base.Maybe b -> (a -> b -> Types.TMM c) -> Types.TMM c
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*C1(C1(U))>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   @ c
                   (m1 :: GHC.Base.Maybe a)
                   (m2 :: GHC.Base.Maybe b)
                   (cont6 :: a -> b -> Types.TMM c) ->
                 case m1 of wild {
                   GHC.Base.Nothing
                   -> (TransformationMonad.cont4 @ c)
                        `cast`
                      (Trans
                           (<Types.TState>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                          <(GHC.Base.Maybe c, Types.TState)>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <Types.TState>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <GHC.Base.Maybe c>_N)))
                   GHC.Base.Just ds1
                   -> case m2 of wild1 {
                        GHC.Base.Nothing
                        -> (TransformationMonad.cont4 @ c)
                             `cast`
                           (Trans
                                (<Types.TState>_R
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                               <(GHC.Base.Maybe c, Types.TState)>_R))
                                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                          <Types.TState>_N
                                          <Data.Functor.Identity.Identity>_R
                                          <GHC.Base.Maybe c>_N)))
                        GHC.Base.Just ds2 -> cont6 ds1 ds2 } }) -}
94c917a2f5a59c14a9ac54294c495155
  cont3 ::
    GHC.Base.Maybe a
    -> GHC.Base.Maybe b
    -> GHC.Base.Maybe c
    -> (a -> b -> c -> Types.TMM d)
    -> Types.TMM d
  {- Arity: 4, HasNoCafRefs,
     Strictness: <S,1*U><L,1*U><L,1*U><L,1*C1(C1(C1(U)))>,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   @ b
                   @ c
                   @ d
                   (m1 :: GHC.Base.Maybe a)
                   (m2 :: GHC.Base.Maybe b)
                   (m3 :: GHC.Base.Maybe c)
                   (cont6 :: a -> b -> c -> Types.TMM d) ->
                 case m1 of wild {
                   GHC.Base.Nothing
                   -> (TransformationMonad.cont4 @ d)
                        `cast`
                      (Trans
                           (<Types.TState>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                          <(GHC.Base.Maybe d, Types.TState)>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <Types.TState>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <GHC.Base.Maybe d>_N)))
                   GHC.Base.Just ds1
                   -> case m2 of wild1 {
                        GHC.Base.Nothing
                        -> (TransformationMonad.cont4 @ d)
                             `cast`
                           (Trans
                                (<Types.TState>_R
                                 ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                               <(GHC.Base.Maybe d, Types.TState)>_R))
                                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                          <Types.TState>_N
                                          <Data.Functor.Identity.Identity>_R
                                          <GHC.Base.Maybe d>_N)))
                        GHC.Base.Just ds2
                        -> case m3 of wild2 {
                             GHC.Base.Nothing
                             -> (TransformationMonad.cont4 @ d)
                                  `cast`
                                (Trans
                                     (<Types.TState>_R
                                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                    <(GHC.Base.Maybe d, Types.TState)>_R))
                                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                               <Types.TState>_N
                                               <Data.Functor.Identity.Identity>_R
                                               <GHC.Base.Maybe d>_N)))
                             GHC.Base.Just ds3 -> cont6 ds1 ds2 ds3 } } }) -}
18069204c2f9eefc6a82a65fc3b51625
  cont4 :: Types.TState -> (GHC.Base.Maybe a, Types.TState)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (eta1 :: Types.TState) -> (GHC.Base.Nothing @ a, eta1)) -}
e6cc9732814ec3ed6aa585c6d1e40a11
  cont5 :: [GHC.Base.Maybe a] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
93552f3e9f9e4c3429f92941bc9472e8
  contIf :: GHC.Types.Bool -> Types.TMM b -> Types.TMM b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ b (bool :: GHC.Types.Bool) (cont6 :: Types.TMM b) ->
                 case bool of wild {
                   GHC.Types.False
                   -> (TransformationMonad.cont4 @ b)
                        `cast`
                      (Trans
                           (<Types.TState>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                          <(GHC.Base.Maybe b, Types.TState)>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <Types.TState>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <GHC.Base.Maybe b>_N)))
                   GHC.Types.True -> cont6 }) -}
eeaa22547872c98097fe900855fef26c
  cont_ :: [GHC.Base.Maybe a] -> ([a] -> Types.TMM b) -> Types.TMM b
  {- Arity: 2, Strictness: <S,U><L,1*C1(U)>,
     Unfolding: (\ @ a
                   @ b
                   (maybes :: [GHC.Base.Maybe a])
                   (cont6 :: [a] -> Types.TMM b) ->
                 case (TransformationMonad.cont_1 @ a maybes)
                        `cast`
                      (Data.Monoid.N:All[0]) of wild {
                   GHC.Types.False
                   -> (TransformationMonad.cont4 @ b)
                        `cast`
                      (Trans
                           (<Types.TState>_R
                            ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                          <(GHC.Base.Maybe b, Types.TState)>_R))
                           (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                     <Types.TState>_N
                                     <Data.Functor.Identity.Identity>_R
                                     <GHC.Base.Maybe b>_N)))
                   GHC.Types.True
                   -> cont6
                        (GHC.Base.map @ (GHC.Base.Maybe a) @ a (Aux.just @ a) maybes) }) -}
93b645cc3d2ace37cbcd97e63ffe3df7
  cont_1 :: [GHC.Base.Maybe a] -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
f46f4739191d885fb6b73c306966ed95
  debug :: Types.Msg -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.debug1
                  `cast`
                (<Types.Msg>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
8ce7819260af25331346288a0023e61a
  debug1 :: Types.Msg -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (msg :: Types.Msg) (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    (GHC.Types.: @ Types.TLog (Types.TLogDebug msg ds4) ds7)
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
49755239830dc452d4e4b0a31d3ed2f3
  debugs :: GHC.Show.Show a => a -> Types.TM ()
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*C1(U),A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.debugs2
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Show.Show a>_R
                 ->_R <a>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N)) -}
69161538f7a533fd5a1c1f43cacdd1d1
  debugs2 ::
    GHC.Show.Show a =>
    a
    -> Types.TState
    -> Data.Functor.Identity.Identity ((), Types.TState)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U(A,1*C1(U),A)><L,U>,
     Unfolding: (\ @ a ($dShow :: GHC.Show.Show a) (eta :: a) ->
                 let {
                   msg :: Types.Msg = GHC.Show.show @ a $dShow eta
                 } in
                 (\ (eta1 :: Types.TState) ->
                  (GHC.Tuple.(),
                   case eta1 of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                   Types.TState
                     ds
                     ds1
                     ds2
                     ds3
                     ds4
                     ds5
                     ds6
                     (GHC.Types.: @ Types.TLog (Types.TLogDebug msg ds4) ds7)
                     ds8
                     ds9
                     ds10
                     ds11
                     ds12
                     ds13
                     ds14
                     ds15
                     ds16
                     ds17 }))
                   `cast`
                 (<Types.TState>_R
                  ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                <((), Types.TState)>_R))) -}
251e73b5d08977d51f1145238c753204
  doesLogicalConnectionExist :: Types.Name -> Types.TM GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.doesLogicalConnectionExist1
                  `cast`
                (<Types.Name>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(GHC.Types.Bool, Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Types.Bool>_N))) -}
d9513102470254eb74e516009bd74cd6
  doesLogicalConnectionExist1 ::
    Types.Name -> Types.TState -> (GHC.Types.Bool, Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (conn :: Types.Name) (eta :: Types.TState) ->
                 (case eta of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  GHC.List.elem
                    @ Types.Name
                    GHC.Classes.$fEq[]_$s$fEq[]1
                    conn
                    ds14 },
                  eta)) -}
932d1bb9b226e2216889adb20c5eb993
  doesLogicalOutputExist :: Types.Name -> Types.TM GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.doesLogicalOutputExist1
                  `cast`
                (<Types.Name>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(GHC.Types.Bool, Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Types.Bool>_N))) -}
9efbdc64665caa82243ad5826fd3f68b
  doesLogicalOutputExist1 ::
    Types.Name -> Types.TState -> (GHC.Types.Bool, Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 case TransformationMonad.$wdoesLogicalOutputExist
                        w
                        w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
28b4d6291cb6cc95dbafbde5708df41d
  getCFuncTypes ::
    Types.TM [(Types.Name, [Types.Constraint], [Types.CFType])]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getCFuncTypes1
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <([(Types.Name, [Types.Constraint], [Types.CFType])],
                                      Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <[(Types.Name, [Types.Constraint], [Types.CFType])]>_N))) -}
a5ea5cae532e600f4d9da69ed2717abf
  getCFuncTypes1 ::
    Types.TState
    -> ([(Types.Name, [Types.Constraint], [Types.CFType])],
        Types.TState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) ->
                 (case s1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  ds3 },
                  s1)) -}
38dd7bff2f354a252badf35042538148
  getComponents :: Types.TM [Types.TComp]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getComponents1
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <([Types.TComp], Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <[Types.TComp]>_N))) -}
6f146afe6eada1c7544c3e4628789f89
  getComponents1 :: Types.TState -> ([Types.TComp], Types.TState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) ->
                 (case s1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  ds11 },
                  s1)) -}
3a3ae6773b52b022ad415a8bf2c8e7c8
  getConnections :: Types.CompName -> Types.TM [Types.CConn]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getConnections1
                  `cast`
                (<Types.CompName>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <([(Types.CompName, (Types.NameId, Types.CSignal),
                                             (Types.NameId, Types.CSignal))],
                                           Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <[Types.CConn]>_N))) -}
bf37ea9d177c4298d4e24481d6cca274
  getConnections1 ::
    Types.CompName
    -> Types.TState
    -> ([(Types.CompName, (Types.NameId, Types.CSignal),
          (Types.NameId, Types.CSignal))],
        Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.CompName) (w1 :: Types.TState) ->
                 (case w1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  GHC.List.filter
                    @ (Types.CompName, (Types.NameId, Types.CSignal),
                       (Types.NameId, Types.CSignal))
                    (\ (ds :: (Types.CompName, (Types.NameId, Types.CSignal),
                               (Types.NameId, Types.CSignal))) ->
                     case ds of wild1 { (,,) cname ds22 ds23 ->
                     GHC.Base.eqString cname w })
                    ds13 },
                  w1)) -}
21daede51fb79e659b4e46f69a8ed81a
  getCore :: Types.TM Types.Core
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getCore1
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <(Types.Core, Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <Types.Core>_N))) -}
2705abdc7089e56536457b8a36f67942
  getCore1 :: Types.TState -> (Types.Core, Types.TState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) ->
                 (case s1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  ds18 },
                  s1)) -}
3d049fd385338ccf03562269b2106ef2
  getDataDecls ::
    Types.TM
      [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used)]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getDataDecls1
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <([(Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                                        Types.Used)],
                                      Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <[(Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                                  Types.Used)]>_N))) -}
1c6d3d35d0baf6e2be5131e15296b35a
  getDataDecls1 ::
    Types.TState
    -> ([(Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
          Types.Used)],
        Types.TState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) ->
                 (case s1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  ds2 },
                  s1)) -}
87f0ff6f90844d75ccd83f5f229b33d8
  getForkedIndex ::
    Types.CompName -> GHC.Base.String -> Types.TM GHC.Types.Int
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,U><S(LLLLLLLLLLLLLLLLSL),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getForkedIndex1
                  `cast`
                (<Types.CompName>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Types.Int>_N)) -}
db42d878ccac6bd6b2debf39b2f41fc6
  getForkedIndex1 ::
    Types.CompName
    -> GHC.Base.String
    -> Types.TState
    -> Data.Functor.Identity.Identity (GHC.Types.Int, Types.TState)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,U><S(LLLLLLLLLLLLLLLLSL),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.CompName)
                   (w1 :: GHC.Base.String)
                   (w2 :: Types.TState) ->
                 case w2 of ww { Types.TState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ->
                 letrec {
                   go :: [(Types.CompName, GHC.Base.String, GHC.Types.Int)]
                         -> Data.Monoid.First
                              (Types.CompName, GHC.Base.String, GHC.Types.Int)
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [(Types.CompName, GHC.Base.String, GHC.Types.Int)]) ->
                     case ds of wild {
                       []
                       -> (GHC.Base.Nothing
                             @ (Types.CompName, GHC.Base.String, GHC.Types.Int))
                            `cast`
                          (Sym (Data.Monoid.N:First[0]) <(Types.CompName, GHC.Base.String,
                                                          GHC.Types.Int)>_N)
                       : y ys
                       -> case y of wild1 { (,,) c i ds1 ->
                          case GHC.Base.eqString c w of wild2 {
                            GHC.Types.False -> go ys
                            GHC.Types.True
                            -> case GHC.Base.eqString i w1 of wild3 {
                                 GHC.Types.False -> go ys
                                 GHC.Types.True
                                 -> (GHC.Base.Just
                                       @ (Types.CompName, GHC.Base.String, GHC.Types.Int)
                                       wild1)
                                      `cast`
                                    (Sym (Data.Monoid.N:First[0]) <(Types.CompName, GHC.Base.String,
                                                                    GHC.Types.Int)>_N) } } } }
                 } in
                 case (go ww17)
                        `cast`
                      (Data.Monoid.N:First[0] <(Types.CompName, GHC.Base.String,
                                                GHC.Types.Int)>_N) of wild {
                   GHC.Base.Nothing
                   -> (TransformationMonad.getForkedIndex2,
                       Types.TState
                         ww1
                         ww2
                         ww3
                         ww4
                         ww5
                         ww6
                         ww7
                         ww8
                         ww9
                         ww10
                         ww11
                         ww12
                         ww13
                         ww14
                         ww15
                         ww16
                         (GHC.Types.:
                            @ (Types.CompName, GHC.Base.String, GHC.Types.Int)
                            (w, w1, TransformationMonad.getForkedIndex2)
                            ww17)
                         ww18)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Int, Types.TState)>_R))
                   GHC.Base.Just ds
                   -> case ds of wild1 { (,,) ds1 ds2 c ->
                      (c,
                       Types.TState
                         ww1
                         ww2
                         ww3
                         ww4
                         ww5
                         ww6
                         ww7
                         ww8
                         ww9
                         ww10
                         ww11
                         ww12
                         ww13
                         ww14
                         ww15
                         ww16
                         ww17
                         ww18)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Int, Types.TState)>_R)) } } }) -}
d5184d240ce3a8b16f172e13e8e974be
  getForkedIndex2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1#) -}
220455cf2c5d998ea83fc389efd68096
  getFunctionId :: Types.Name -> [Types.FType] -> Types.TM Types.Id
  {- Arity: 3,
     Strictness: <L,U><L,U><S(LLLLLLLLLSLLLLLLLL),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getFunctionId1
                  `cast`
                (<Types.Name>_R
                 ->_R <[Types.FType]>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <Types.Id>_N)) -}
55c31d518e6f8c74b5ea28f5f00af6e3
  getFunctionId1 ::
    Types.Name
    -> [Types.FType]
    -> Types.TState
    -> Data.Functor.Identity.Identity (Types.Id, Types.TState)
  {- Arity: 3,
     Strictness: <L,U><L,U><S(LLLLLLLLLSLLLLLLLL),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.Name) (w1 :: [Types.FType]) (w2 :: Types.TState) ->
                 case w2 of ww { Types.TState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ->
                 case TransformationMonad.$wgetFunctionId
                        w
                        w1
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        ww6
                        ww7
                        ww8
                        ww9
                        ww10
                        ww11
                        ww12
                        ww13
                        ww14
                        ww15
                        ww16
                        ww17
                        ww18 of ww19 { (#,#) ww20 ww21 ->
                 (ww20, ww21)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(Types.Id, Types.TState)>_R)) } }) -}
79f58e480b737f28a49be16140a0a592
  getFunctionId_go ::
    [Types.FType] -> [Types.FType] -> Data.Monoid.All
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U> -}
535dc6d952501edae7c576d7d8b45ece
  getFunctionId_takeId :: (t1, t2, t) -> t2
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSL),1*U(A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ t @ t1 @ t2 (ds :: (t1, t2, t)) ->
                 case ds of wild { (,,) ds1 id ds2 -> id }) -}
97536f9f5f10236dfc0e9cecd8f2ac01
  getFunctionIds :: Types.TM [(Types.Name, Types.Id, [Types.FType])]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getFunctionIds1
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <([(Types.Name, Types.Id, [Types.FType])], Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <[(Types.Name, Types.Id, [Types.FType])]>_N))) -}
f4894148ec13bf56e2cae95d18929bbe
  getFunctionIds1 ::
    Types.TState
    -> ([(Types.Name, Types.Id, [Types.FType])], Types.TState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) ->
                 (case s1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  ds10 },
                  s1)) -}
eab9116df7e74b5aa756b4bf445934d5
  getFunctions :: Types.TM [Types.TFunc]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getFunctions1
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <([Types.TFunc], Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <[Types.TFunc]>_N))) -}
ec011bcbed5f002ca578376b637bc430
  getFunctions1 :: Types.TState -> ([Types.TFunc], Types.TState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) ->
                 (case s1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  ds9 },
                  s1)) -}
d7b2c9baf8e526d2d8988c1fe3e744e4
  getIdForInstance ::
    Types.CompName -> Types.Name -> Types.TM GHC.Types.Int
  {- Arity: 3,
     Strictness: <L,U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getIdForInstance1
                  `cast`
                (<Types.CompName>_R
                 ->_R <Types.Name>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Types.Int>_N)) -}
8e7969c350c4b9fdfdda71aff195e6d6
  getIdForInstance1 ::
    Types.CompName
    -> Types.Name
    -> Types.TState
    -> Data.Functor.Identity.Identity (GHC.Types.Int, Types.TState)
  {- Arity: 3,
     Strictness: <L,U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.CompName) (w1 :: Types.Name) (w2 :: Types.TState) ->
                 case TransformationMonad.$wsearchInstances
                        w
                        w1
                        w2 of ww { (#,#) ww1 ww2 ->
                 case ww1 of wild {
                   []
                   -> (TransformationMonad.getForkedIndex2, ww2)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Int, Types.TState)>_R))
                   : ipv ipv1
                   -> (case GHC.Base.map
                              @ (Types.CompName, Types.Id, Types.NameId, Types.I, GHC.Types.Bool)
                              @ GHC.Types.Int
                              (TransformationMonad.getIdForInstance_getId
                                 @ Types.Id
                                 @ Types.CompName)
                              wild of wild1 {
                         [] -> GHC.List.maximum2
                         : ipv2 ipv3
                         -> case ipv2 of ww3 { GHC.Types.I# ww4 ->
                            case GHC.List.$wgo ipv3 ww4 of ww5 { DEFAULT ->
                            GHC.Types.I# ww5 } } },
                       ww2)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Types.Int, Types.TState)>_R)) } }) -}
332f2bdab952bdb3f4e10f64c2da0ccb
  getIdForInstance_getId ::
    (t1, t, Types.NameId, Types.I, GHC.Types.Bool) -> Types.Id
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSL),1*U(A,A,1*U(A,1*U(U)),U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ t
                   @ t1
                   (w :: (t1, t, Types.NameId, Types.I, GHC.Types.Bool)) ->
                 case w of ww { (,,,,) ww1 ww2 ww3 ww4 ww5 ->
                 case ww4 of wild {
                   DEFAULT
                   -> case ww3 of wild1 { Types.NameId ds id ->
                      case id of wild2 { GHC.Types.I# x1 ->
                      GHC.Types.I# (GHC.Prim.+# x1 1#) } }
                   Types.ForkI ds ds1 o
                   -> case ww5 of wild1 {
                        GHC.Types.False -> GHC.Types.I# 1#
                        GHC.Types.True
                        -> case ww3 of wild2 { Types.NameId ds2 id ->
                           case id of wild3 { GHC.Types.I# x1 ->
                           GHC.Types.I# (GHC.Prim.+# x1 1#) } } } } }) -}
2f3edf6751ce0df4a97be312c4331fe7
  getInstances :: Types.TM [Types.TInst]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getInstances1
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <([Types.TInst], Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <[Types.TInst]>_N))) -}
6ea7f33322f957069fef1344ded76593
  getInstances1 :: Types.TState -> ([Types.TInst], Types.TState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) ->
                 (case s1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  ds12 },
                  s1)) -}
87732c3d011b39a91755bf6e1c5a0cd5
  getInstancesFromComponent ::
    Types.CompName -> Types.TM [Types.TInst]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getInstancesFromComponent1
                  `cast`
                (<Types.CompName>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <([(Types.CompName, Types.Id, Types.NameId, Types.I,
                                             Types.Used)],
                                           Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <[Types.TInst]>_N))) -}
f89a8739ef7deead787ed981565a3dd6
  getInstancesFromComponent1 ::
    Types.CompName
    -> Types.TState
    -> ([(Types.CompName, Types.Id, Types.NameId, Types.I,
          Types.Used)],
        Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.CompName) (w1 :: Types.TState) ->
                 (case w1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  GHC.List.filter
                    @ (Types.CompName, Types.Id, Types.NameId, Types.I, Types.Used)
                    (\ (ds :: (Types.CompName, Types.Id, Types.NameId, Types.I,
                               Types.Used)) ->
                     case ds of wild1 { (,,,,) c ds22 ds23 ds24 ds25 ->
                     GHC.Base.eqString c w })
                    ds12 },
                  w1)) -}
cea5706c11a76509825eab1a7f4f872a
  getIt :: Types.TM [([Types.Constraint], [Types.CFType])]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getIt1
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <([([Types.Constraint], [Types.CFType])], Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <[([Types.Constraint], [Types.CFType])]>_N))) -}
ace17b2699abd76bc8927a043faabb63
  getIt1 ::
    Types.TState
    -> ([([Types.Constraint], [Types.CFType])], Types.TState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) ->
                 (case s1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  ds4 },
                  s1)) -}
085ab0af4e351106c0b5675ae61d2784
  getLogicalConnections :: Types.TM [Types.Name]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getLogicalConnections1
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <([Types.Name], Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <[Types.Name]>_N))) -}
3723b3f9d1baa645648eb92413a1f00f
  getLogicalConnections1 ::
    Types.TState -> ([Types.Name], Types.TState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) -> (Types.logicalConnections s1, s1)) -}
31c787188ae6f9cbfa2be908e2f58e9c
  getLogicalOutput ::
    Types.Name
    -> Types.TM (Types.Name, Types.FType, GHC.Base.Maybe GHC.Types.Int)
  {- Arity: 2,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getLogicalOutput1
                  `cast`
                (<Types.Name>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((Types.Name, Types.FType, GHC.Base.Maybe GHC.Types.Int),
                                           Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <(Types.Name, Types.FType,
                                      GHC.Base.Maybe GHC.Types.Int)>_N))) -}
0b61b6e10a9ebd7a1d869242017e5580
  getLogicalOutput1 ::
    Types.Name
    -> Types.TState
    -> ((Types.Name, Types.FType, GHC.Base.Maybe GHC.Types.Int),
        Types.TState)
  {- Arity: 2,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 case TransformationMonad.$wgetLogicalOutput
                        w
                        w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
983a9b368e0a926bdef512a25ebcb84c
  getLogicalOutputs ::
    Types.TM
      [(Types.Name, Types.Name, Types.FType,
        GHC.Base.Maybe GHC.Types.Int)]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getLogicalOutputs1
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <([(Types.Name, Types.Name, Types.FType,
                                        GHC.Base.Maybe GHC.Types.Int)],
                                      Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <[(Types.Name, Types.Name, Types.FType,
                                  GHC.Base.Maybe GHC.Types.Int)]>_N))) -}
da4d51061463d92933730c386c85e209
  getLogicalOutputs1 ::
    Types.TState
    -> ([(Types.Name, Types.Name, Types.FType,
          GHC.Base.Maybe GHC.Types.Int)],
        Types.TState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) -> (Types.logicalOutputs s1, s1)) -}
a2fadd8a84cc1853a6eb4c10f0ba8aaa
  getNextInstance ::
    Types.CompName -> Types.Name -> Types.TMM Types.TInst
  {- Arity: 3,
     Strictness: <L,U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getNextInstance1
                  `cast`
                (<Types.CompName>_R
                 ->_R <Types.Name>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Base.Maybe Types.TInst>_N)) -}
81ec24b694caaf78b2e7c8e3fdbe3fb0
  getNextInstance1 ::
    Types.CompName
    -> Types.Name
    -> Types.TState
    -> Data.Functor.Identity.Identity
         (GHC.Base.Maybe Types.TInst, Types.TState)
  {- Arity: 3,
     Strictness: <L,U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.CompName) (w1 :: Types.Name) (w2 :: Types.TState) ->
                 case TransformationMonad.$wgetNextInstance
                        w
                        w1
                        w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(GHC.Base.Maybe Types.TInst, Types.TState)>_R)) }) -}
03c46c42d74d886907fb4dd189454df1
  getNextInstance2 ::
    (Types.CompName, Types.Id, Types.NameId, Types.I, Types.Used)
    -> (Types.Id, Types.Used)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLSLL),1*U(A,A,1*U(A,U),A,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Types.CompName, Types.Id, Types.NameId, Types.I,
                           Types.Used)) ->
                 case ds of wild { (,,,,) ds1 ds2 ds3 ds4 used ->
                 case ds3 of wild1 { Types.NameId ds5 id -> (id, used) } }) -}
75c87a293850c975443c478253dafa35
  getNextInstance3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " not found."#) -}
12db76d955696613351f5eb440708cde
  getNextInstance_go ::
    [(Types.CompName, Types.Id, Types.NameId, Types.I, Types.Used)]
    -> Data.Monoid.All
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
421b76418ccbe9be9627f5053aa89941
  getNumberFromType :: Types.CFType -> GHC.Types.Int
  {- Arity: 1, Strictness: <S,1*U> -}
4971dbf1d0f764fb9c4ebcfe359b9546
  getSourceCode :: Types.TM Types.SourceCode
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getSourceCode1
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <(Types.SourceCode, Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <Types.SourceCode>_N))) -}
f0f72f94125e6485f2898ad96a7aa284
  getSourceCode1 :: Types.TState -> (Types.SourceCode, Types.TState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) ->
                 (case s1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  ds1 },
                  s1)) -}
923dd75392e711add63807c078f21b3e
  getSourceLine :: GHC.Types.Int -> Types.TM GHC.Base.String
  {- Arity: 2,
     Strictness: <L,1*U(U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getSourceLine1
                  `cast`
                (<GHC.Types.Int>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(GHC.Base.String, Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Base.String>_N))) -}
435430a283d705b377b4c7f5508e9365
  getSourceLine1 ::
    GHC.Types.Int -> Types.TState -> (GHC.Base.String, Types.TState)
  {- Arity: 2,
     Strictness: <L,1*U(U)><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (n :: GHC.Types.Int) (eta :: Types.TState) ->
                 (case eta of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  case n of ww { GHC.Types.I# ww1 ->
                  GHC.List.$w!! @ GHC.Base.String (Data.OldList.lines ds1) ww1 } },
                  eta)) -}
d62263e695ef7271bc8aaf9ab193d0e7
  getStage :: Types.TM Types.TStage
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getStage1
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <(Types.TStage, Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <Types.TStage>_N))) -}
86edfb8e97f4afc44e06727e3d6c6382
  getStage1 :: Types.TState -> (Types.TStage, Types.TState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) ->
                 (case s1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  ds5 },
                  s1)) -}
b41dd4b0a6125d315ab2917092260814
  getTCore :: Types.TM Types.TCore
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U(U),U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getTCore1
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <(Types.TCore, Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <Types.TCore>_N))) -}
345ec0818638e054e9bb8474e87bb33c
  getTCore1 :: Types.TState -> (Types.TCore, Types.TState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U(U),U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) -> (Types.tCore s1, s1)) -}
99cf21eeb24068a17e021e62c301e7a7
  getTimesForked ::
    Types.TM [(Types.CompName, GHC.Base.String, GHC.Types.Int)]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getTimesForked1
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <([(Types.CompName, GHC.Base.String, GHC.Types.Int)],
                                      Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <[(Types.CompName, GHC.Base.String, GHC.Types.Int)]>_N))) -}
5f7ee1e5236a46845dd8d9719b34054c
  getTimesForked1 ::
    Types.TState
    -> ([(Types.CompName, GHC.Base.String, GHC.Types.Int)],
        Types.TState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) ->
                 (case s1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  ds17 },
                  s1)) -}
d6776b207c8458ab0d3e6b9645750a0b
  getTypeChanges :: Types.TM [(Types.CFType, Types.CFType)]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getTypeChanges1
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <([(Types.CFType, Types.CFType)], Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <[(Types.CFType, Types.CFType)]>_N))) -}
a8aa2f2e59aedb60cc78409913ace34d
  getTypeChanges1 ::
    Types.TState -> ([(Types.CFType, Types.CFType)], Types.TState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) -> (Types.typeChanges s1, s1)) -}
9f6d2c40ea84fc6e07a9f87ccf413bd3
  getTypeCheckState :: Types.TMM ([Types.Constraint], [Types.CFType])
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLLLLLLLLLLLLL),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getTypeCheckState1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <Types.TState>_N
                          <Data.Functor.Identity.Identity>_R
                          <GHC.Base.Maybe ([Types.Constraint], [Types.CFType])>_N)) -}
8b6bd080c035814b3bbc78bb1a5bc566
  getTypeCheckState1 ::
    Types.TState
    -> Data.Functor.Identity.Identity
         (GHC.Base.Maybe ([Types.Constraint], [Types.CFType]), Types.TState)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LLLSLLLLLLLLLLLLLL),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) ->
                 case s1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                 case ds4 of wild1 {
                   []
                   -> (GHC.Base.Nothing @ ([Types.Constraint], [Types.CFType]), wild)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Base.Maybe ([Types.Constraint], [Types.CFType]),
                                  Types.TState)>_R))
                   : x1 xs
                   -> (GHC.Base.Just @ ([Types.Constraint], [Types.CFType]) x1, wild)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <(GHC.Base.Maybe ([Types.Constraint], [Types.CFType]),
                                  Types.TState)>_R)) } }) -}
d31bf954a42616fbecd6ccf467852bc0
  getUniqueInstance ::
    Types.CompName -> Types.NameId -> Types.TMM Types.TInst
  {- Arity: 3,
     Strictness: <L,U><L,U(U,U(U))><S(LLLLLLLLLLLSLLLLLL),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.getUniqueInstance1
                  `cast`
                (<Types.CompName>_R
                 ->_R <Types.NameId>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Base.Maybe Types.TInst>_N)) -}
8a9104c94be28f841394ade2d75fa83f
  getUniqueInstance1 ::
    Types.CompName
    -> Types.NameId
    -> Types.TState
    -> Data.Functor.Identity.Identity
         (GHC.Base.Maybe Types.TInst, Types.TState)
  {- Arity: 3,
     Strictness: <L,U><L,U(U,U(U))><S(LLLLLLLLLLLSLLLLLL),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.CompName)
                   (w1 :: Types.NameId)
                   (w2 :: Types.TState) ->
                 case w2 of ww { Types.TState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ->
                 case TransformationMonad.$wgetUniqueInstance
                        w
                        w1
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        ww6
                        ww7
                        ww8
                        ww9
                        ww10
                        ww11
                        ww12
                        ww13
                        ww14
                        ww15
                        ww16
                        ww17
                        ww18 of ww19 { (#,#) ww20 ww21 ->
                 (ww20, ww21)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(GHC.Base.Maybe Types.TInst, Types.TState)>_R)) } }) -}
36772d9d8702d0afd4c58c74f8f412bf
  highOrderArgs :: Types.Name -> Types.TM [GHC.Types.Int]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.highOrderArgs1
                  `cast`
                (<Types.Name>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <[GHC.Types.Int]>_N)) -}
6bc819639d9b5acd08d54b537d242afd
  highOrderArgs1 ::
    Types.Name
    -> Types.TState
    -> Data.Functor.Identity.Identity ([GHC.Types.Int], Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 let {
                   ds :: (GHC.Base.Maybe
                            (Types.Name, Lexer.SrcLoc, Types.F, Types.Arity,
                             Types.FunctionClassification, Types.HighOrder),
                          Types.TState)
                   = case TransformationMonad.$wsearchFunction
                            w
                            w1 of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) }
                 } in
                 (case ds of wild { (,) a1 s' ->
                  case a1 of wild1 {
                    GHC.Base.Nothing -> GHC.Types.[] @ GHC.Types.Int
                    GHC.Base.Just ds1
                    -> case ds1 of wild2 { (,,,,,) ds2 ds3 ds4 ds5 ds6 xs -> xs } } },
                  case ds of wild { (,) a1 s' -> s' })
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <([GHC.Types.Int], Types.TState)>_R))) -}
799175fb7f70939ad3d69b0802f8c98c
  incrementForkedIndex ::
    Types.CompName -> GHC.Base.String -> Types.TM ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,U><S(LLLLLLLLLLLLLLLLSL),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.incrementForkedIndex1
                  `cast`
                (<Types.CompName>_R
                 ->_R <GHC.Base.String>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N)) -}
767e1e58b332be78188d7c4607402660
  incrementForkedIndex1 ::
    Types.CompName
    -> GHC.Base.String
    -> Types.TState
    -> Data.Functor.Identity.Identity ((), Types.TState)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,U><S(LLLLLLLLLLLLLLLLSL),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.CompName)
                   (w1 :: GHC.Base.String)
                   (w2 :: Types.TState) ->
                 case w2 of ww { Types.TState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ->
                 case TransformationMonad.$wincrementForkedIndex
                        w
                        w1
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        ww6
                        ww7
                        ww8
                        ww9
                        ww10
                        ww11
                        ww12
                        ww13
                        ww14
                        ww15
                        ww16
                        ww17
                        ww18 of ww19 { (#,#) ww20 ww21 ->
                 (ww20, ww21)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <((), Types.TState)>_R)) } }) -}
1587384c8c618f627528d5d863e2f740
  isFunctionHighOrder :: Types.Name -> Types.TM GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.isFunctionHighOrder1
                  `cast`
                (<Types.Name>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Types.Bool>_N)) -}
f142d92d5d80cbf61b0a828a67846e90
  isFunctionHighOrder1 ::
    Types.Name
    -> Types.TState
    -> Data.Functor.Identity.Identity (GHC.Types.Bool, Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 let {
                   ds :: (GHC.Base.Maybe
                            (Types.Name, Lexer.SrcLoc, Types.F, Types.Arity,
                             Types.FunctionClassification, Types.HighOrder),
                          Types.TState)
                   = case TransformationMonad.$wsearchFunction
                            w
                            w1 of ww { (#,#) ww1 ww2 ->
                     (ww1, ww2) }
                 } in
                 (case ds of wild { (,) a1 s' ->
                  case a1 of wild1 {
                    GHC.Base.Nothing -> GHC.Types.False
                    GHC.Base.Just ds1
                    -> case ds1 of wild2 { (,,,,,) ds2 ds3 ds4 ds5 ds6 ds7 ->
                       case ds7 of wild3 {
                         [] -> GHC.Types.False : ipv ipv1 -> GHC.Types.True } } } },
                  case ds of wild { (,) a1 s' -> s' })
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(GHC.Types.Bool, Types.TState)>_R))) -}
97f7a4599f01abb477024d7f28708cfb
  isInstanceAdded :: Types.TInst -> Types.TM GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.isInstanceAdded1
                  `cast`
                (<Types.TInst>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(GHC.Types.Bool, Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Types.Bool>_N))) -}
f6b539ef8db844d5f5bcb1ad08bad7a7
  isInstanceAdded1 ::
    Types.TInst -> Types.TState -> (GHC.Types.Bool, Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (inst :: Types.TInst) (eta :: Types.TState) ->
                 (case eta of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  GHC.List.elem
                    @ Types.TInst
                    TransformationMonad.$s$fEq(,,,,)
                    inst
                    ds12 },
                  eta)) -}
32b0bab52622aecfb6d9e95c51668320
  isThereTypeChange :: Types.CFType -> Types.TM GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.isThereTypeChange1
                  `cast`
                (<Types.CFType>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(GHC.Types.Bool, Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Types.Bool>_N))) -}
0f5efab39a9e921bf2a4997c3252bfad
  isThereTypeChange1 ::
    Types.CFType -> Types.TState -> (GHC.Types.Bool, Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.CFType) (w1 :: Types.TState) ->
                 case TransformationMonad.$wisThereTypeChange
                        w
                        w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
392217388e700cc7d0911caec794fbb3
  isTypeRecursive :: Types.Name -> Types.TM GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.isTypeRecursive1
                  `cast`
                (<Types.Name>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Types.Bool>_N)) -}
bdd4efca332d8dc66ac48486828f05a4
  isTypeRecursive1 ::
    Types.Name
    -> Types.TState
    -> Data.Functor.Identity.Identity (GHC.Types.Bool, Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 case TransformationMonad.$wisTypeRecursive
                        w
                        w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(GHC.Types.Bool, Types.TState)>_R)) }) -}
225468daf982370a719435bb45061da2
  isTypeRecursive_go :: [GHC.Types.Bool] -> Data.Monoid.Any
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
263d7269c9089743379b011b944aba91
  log :: Types.Msg -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.log1
                  `cast`
                (<Types.Msg>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
eb442587bb19c399810276f106379a21
  log1 :: Types.Msg -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (msg :: Types.Msg) (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    (GHC.Types.: @ Types.TLog (Types.TLog msg ds4) ds7)
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
08e546f9fad0ec51e91a62e86e16573a
  mayThrow :: GHC.Base.Maybe a -> Types.TErr -> Types.TM ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.mayThrow1
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Base.Maybe a>_R
                 ->_R <Types.TErr>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N)) -}
e7fe7eaf744655c8fe04948d009a450c
  mayThrow1 ::
    GHC.Base.Maybe a
    -> Types.TErr
    -> Types.TState
    -> Data.Functor.Identity.Identity ((), Types.TState)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (val :: GHC.Base.Maybe a)
                   (err :: Types.TErr)
                   (eta :: Types.TState) ->
                 case val of wild {
                   GHC.Base.Nothing
                   -> (GHC.Tuple.(),
                       case eta of wild1 { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                       Types.TState
                         ds
                         ds1
                         ds2
                         ds3
                         ds4
                         ds5
                         ds6
                         (GHC.Types.: @ Types.TLog (Types.TLogErr err ds4) ds7)
                         ds8
                         ds9
                         ds10
                         ds11
                         ds12
                         ds13
                         ds14
                         ds15
                         ds16
                         ds17 })
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0] <((), Types.TState)>_R))
                   GHC.Base.Just ipv
                   -> (GHC.Tuple.(), eta)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <((), Types.TState)>_R)) }) -}
6d78a97f7a7e3b2b67ecb0b058248b91
  modifyTypeCheckState ::
    ([Types.CFType] -> [Types.CFType]) -> Types.TM ()
  {- Arity: 2,
     Strictness: <L,1*C1(U)><S(LLLSLLLLLLLLLLLLLL),1*U(U,U,U,1*U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.modifyTypeCheckState1
                  `cast`
                (<[Types.CFType] -> [Types.CFType]>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N)) -}
047dba46e68bb14524b9b961a3a82cb0
  modifyTypeCheckState1 ::
    ([Types.CFType] -> [Types.CFType])
    -> Types.TState
    -> Data.Functor.Identity.Identity ((), Types.TState)
  {- Arity: 2,
     Strictness: <L,1*C1(U)><S(LLLSLLLLLLLLLLLLLL),1*U(U,U,U,1*U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: [Types.CFType] -> [Types.CFType]) (w1 :: Types.TState) ->
                 case w1 of ww { Types.TState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ->
                 case ww4 of wild {
                   []
                   -> (GHC.Tuple.(),
                       Types.TState
                         ww1
                         ww2
                         ww3
                         (GHC.Types.[] @ ([Types.Constraint], [Types.CFType]))
                         ww5
                         ww6
                         ww7
                         (GHC.Types.:
                            @ Types.TLog
                            (Types.TLogDebug TransformationMonad.modifyTypeCheckState2 ww5)
                            ww8)
                         ww9
                         ww10
                         ww11
                         ww12
                         ww13
                         ww14
                         ww15
                         ww16
                         ww17
                         ww18)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0] <((), Types.TState)>_R))
                   : ds xs
                   -> case ds of wild1 { (,) cs x1 ->
                      (GHC.Tuple.(),
                       Types.TState
                         ww1
                         ww2
                         ww3
                         (GHC.Types.: @ ([Types.Constraint], [Types.CFType]) (cs, w x1) xs)
                         ww5
                         ww6
                         ww7
                         (GHC.Types.:
                            @ Types.TLog
                            (Types.TLogDebug TransformationMonad.modifyTypeCheckState2 ww5)
                            ww8)
                         ww9
                         ww10
                         ww11
                         ww12
                         ww13
                         ww14
                         ww15
                         ww16
                         ww17
                         ww18)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <((), Types.TState)>_R)) } } }) -}
31771d8f83e5e51af1c438bfe7e23eb4
  modifyTypeCheckState2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "STATE MODIFIED"#) -}
23cd70552f3bea96f2d13bd1bdee10aa
  modifyUniqueInstance ::
    Types.CompName
    -> Types.NameId -> (Types.TInst -> Types.TInst) -> Types.TMM ()
  {- Arity: 4,
     Strictness: <L,U><L,U(U,U(U))><L,C(U)><S(LLLLLLLLLLLSLLLLLL),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.modifyUniqueInstance1
                  `cast`
                (<Types.CompName>_R
                 ->_R <Types.NameId>_R
                 ->_R <Types.TInst -> Types.TInst>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Base.Maybe ()>_N)) -}
7e37d33cd65c9d8ff4898f4c60797422
  modifyUniqueInstance1 ::
    Types.CompName
    -> Types.NameId
    -> (Types.TInst -> Types.TInst)
    -> Types.TState
    -> Data.Functor.Identity.Identity (GHC.Base.Maybe (), Types.TState)
  {- Arity: 4,
     Strictness: <L,U><L,U(U,U(U))><L,C(U)><S(LLLLLLLLLLLSLLLLLL),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: Types.CompName)
                   (w1 :: Types.NameId)
                   (w2 :: Types.TInst -> Types.TInst)
                   (w3 :: Types.TState) ->
                 case w3 of ww { Types.TState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ->
                 case TransformationMonad.$wmodifyUniqueInstance
                        w
                        w1
                        w2
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        ww6
                        ww7
                        ww8
                        ww9
                        ww10
                        ww11
                        ww12
                        ww13
                        ww14
                        ww15
                        ww16
                        ww17
                        ww18 of ww19 { (#,#) ww20 ww21 ->
                 (ww20, ww21)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(GHC.Base.Maybe (), Types.TState)>_R)) } }) -}
6c5e311b9d70c93a292b55523580b35f
  modifyUniqueInstance2 :: Types.TErr
  {- Strictness: m,
     Unfolding: (Types.TErr
                   Types.ModifyUnexistingInstance
                   (GHC.Base.Nothing @ Types.WhereMsg)
                   TransformationMonad.modifyUniqueInstance3
                   Lexer.NoLoc) -}
7e7c13a6abac3a62ef92b6576e059a2b
  modifyUniqueInstance3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "Tried to modify instance that does not exist"#) -}
087fdfc0cc39df143a765b026c2c84ce
  newStage :: Types.TStage -> Types.TM ()
  {- Arity: 2,
     Strictness: <L,U><L,1*U(U,U,U,U,A,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.newStage1
                  `cast`
                (<Types.TStage>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
657cf7645fe239c6f84205c5b0548c16
  newStage1 :: Types.TStage -> Types.TState -> ((), Types.TState)
  {- Arity: 2,
     Strictness: <L,U><L,1*U(U,U,U,U,A,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.TStage) (w1 :: Types.TState) ->
                 case TransformationMonad.$wnewStage w w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
f27a766fc8906feee50ef508c6ef3ff0
  noRet :: Types.TMM a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.cont4
                  `cast`
                (forall (a :: <*>_N).
                 Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <(GHC.Base.Maybe a, Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Base.Maybe a>_N))) -}
e60e693541890eaebeb93a8d9414f9c5
  outTM :: Types.TM a -> a
  {- Arity: 1, Strictness: <C(S(SL)),1*C1(U(1*U,A))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (tm :: Types.TM a) ->
                 case (tm
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <Types.TState>_N <Data.Functor.Identity.Identity>_R <a>_N)
                         Types.initialTState)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <(a, Types.TState)>_R) of wild { (,) x1 ds1 ->
                 x1 }) -}
752190041fb14bc403158b3131a2d630
  popTypeCheckState :: Types.TM ()
  {- Arity: 1,
     Strictness: <S(LLLSLLLLLLLLLLLLLL),1*U(U,U,U,1*U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.popTypeCheckState1
                  `cast`
                (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                          <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N)) -}
874c2bb9b4a6a3fe06ac516982bec73a
  popTypeCheckState1 ::
    Types.TState -> Data.Functor.Identity.Identity ((), Types.TState)
  {- Arity: 1,
     Strictness: <S(LLLSLLLLLLLLLLLLLL),1*U(U,U,U,1*U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) ->
                 case s1 of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                 case ds3 of wild1 {
                   []
                   -> case TransformationMonad.popTypeCheckState3
                      ret_ty (Data.Functor.Identity.Identity ((), Types.TState))
                      of {}
                   : x1 xs
                   -> (GHC.Tuple.(),
                       Types.TState
                         ds
                         ds1
                         ds2
                         xs
                         ds4
                         ds5
                         ds6
                         (GHC.Types.:
                            @ Types.TLog
                            (Types.TLogDebug TransformationMonad.popTypeCheckState2 ds4)
                            ds7)
                         ds8
                         ds9
                         ds10
                         ds11
                         ds12
                         ds13
                         ds14
                         ds15
                         ds16
                         ds17)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <((), Types.TState)>_R)) } }) -}
db12c9ccc195f56cc57d041d23e0e591
  popTypeCheckState2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "STATE POP"#) -}
6fce5f01f95853aae3e0aa038f3d4c0b
  popTypeCheckState3 ::
    Control.Monad.Trans.State.Lazy.StateT
      Types.TState Data.Functor.Identity.Identity ()
  {- Strictness: x -}
b3f40202fd9bd1b520b298a515f695f6
  putComponents :: [Types.TComp] -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,A,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.putComponents1
                  `cast`
                (<[Types.TComp]>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
091af3f2a131b57ec832ffce051af280
  putComponents1 ::
    [Types.TComp] -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,A,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (comps :: [Types.TComp]) (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    ds8
                    ds9
                    comps
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
60f84ca5c372ffed19a901406d7620cf
  putDataDecls ::
    [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used)]
    -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,A,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.putDataDecls1
                  `cast`
                (<[(Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                    Types.Used)]>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
94904537c5043350e6849f97ed45a194
  putDataDecls1 ::
    [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used)]
    -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,A,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (dds :: [(Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                             Types.Used)])
                   (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    dds
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
9c13acd131589e422db1336f25ec05ee
  putForkedIndex ::
    Types.CompName -> GHC.Base.String -> GHC.Types.Int -> Types.TM ()
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><S(LLLLLLLLLLLLLLLLSL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.putForkedIndex1
                  `cast`
                (<Types.CompName>_R
                 ->_R <GHC.Base.String>_R
                 ->_R <GHC.Types.Int>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N)) -}
09b5bb0eef0b9301c05e4d97b3a5a74a
  putForkedIndex1 ::
    Types.CompName
    -> GHC.Base.String
    -> GHC.Types.Int
    -> Types.TState
    -> Data.Functor.Identity.Identity ((), Types.TState)
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U><S(LLLLLLLLLLLLLLLLSL),U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (4, True, False)
                (\ (w :: Types.CompName)
                   (w1 :: GHC.Base.String)
                   (w2 :: GHC.Types.Int)
                   (w3 :: Types.TState) ->
                 case w3 of ww { Types.TState ww1 ww2 ww3 ww4 ww5 ww6 ww7 ww8 ww9 ww10 ww11 ww12 ww13 ww14 ww15 ww16 ww17 ww18 ->
                 case TransformationMonad.$wputForkedIndex
                        w
                        w1
                        w2
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5
                        ww6
                        ww7
                        ww8
                        ww9
                        ww10
                        ww11
                        ww12
                        ww13
                        ww14
                        ww15
                        ww16
                        ww17
                        ww18 of ww19 { (#,#) ww20 ww21 ->
                 (ww20, ww21)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <((), Types.TState)>_R)) } }) -}
9ed607010e3ebae4916b4556e489ab81
  putFunctions :: [Types.TFunc] -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,A,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.putFunctions1
                  `cast`
                (<[Types.TFunc]>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
96f6beaeaa9a4a274a3ac1697200bdf6
  putFunctions1 ::
    [Types.TFunc] -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,A,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (fs :: [Types.TFunc]) (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    fs
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
02201222a9bcf4d5abeaca3f9c9c04eb
  putInstances :: [Types.TInst] -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,A,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.putInstances1
                  `cast`
                (<[Types.TInst]>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
ff60ab2b4677a0e121294a2e430424e8
  putInstances1 ::
    [Types.TInst] -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,A,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (insts :: [Types.TInst]) (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    ds8
                    ds9
                    ds10
                    insts
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
e4384852b8cbf5223fdd7c8aa1c6df4b
  putSourceCode :: Types.SourceCode -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(A,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.putSourceCode1
                  `cast`
                (<Types.SourceCode>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
cc4a79b80e01e36e634063c8b50b489c
  putSourceCode1 ::
    Types.SourceCode -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(A,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (s :: Types.SourceCode) (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    s
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
4d3b26ae8230244c0323bb0950777ee4
  putTCore :: Types.TCore -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,A,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.putTCore1
                  `cast`
                (<Types.TCore>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
00ab8ca1987ceaa7d3e1b24672fa1403
  putTCore1 :: Types.TCore -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,A,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (tCore' :: Types.TCore) (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    tCore'
                    ds7
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
57707e5854f3c365f6e29223a6506cb7
  putTimesForked ::
    [(Types.CompName, GHC.Base.String, GHC.Types.Int)] -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,A,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.putTimesForked1
                  `cast`
                (<[(Types.CompName, GHC.Base.String, GHC.Types.Int)]>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
0a35c850efc3e9cb276bb0f466060188
  putTimesForked1 ::
    [(Types.CompName, GHC.Base.String, GHC.Types.Int)]
    -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,A,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (tf :: [(Types.CompName, GHC.Base.String, GHC.Types.Int)])
                   (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    tf
                    ds17 })) -}
008c3803a7b1a36d151f678ab35f8b74
  putTypeCheckState ::
    ([Types.Constraint], [Types.CFType]) -> Types.TM ()
  {- Arity: 1, Strictness: <L,U(U,U)>,
     Unfolding: (\ (ft :: ([Types.Constraint], [Types.CFType])) ->
                 let {
                   m1 :: [GHC.Types.Char]
                   = GHC.CString.unpackAppendCString#
                       "STATEPUT: "#
                       (case ft of ww { (,) ww1 ww2 ->
                        GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.shows7
                          (GHC.Show.showList__
                             @ ([GHC.Types.Char], [GHC.Types.Char])
                             TransformationMonad.$s$fShow(,)_$cshow4
                             ww1
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.shows5
                                (GHC.Show.$fShow(,)_$sgo
                                   TransformationMonad.putTypeCheckState1
                                   (\ (eta :: GHC.Base.String) ->
                                    GHC.Show.showList__ @ Types.CFType Types.$fShowCConstr2 ww2 eta)
                                   (GHC.Types.[] @ GHC.Show.ShowS)))) })
                 } in
                 (\ (s1 :: Types.TState) ->
                  (GHC.Tuple.(),
                   case s1 of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                   Types.TState
                     ds
                     ds1
                     ds2
                     (GHC.Types.: @ ([Types.Constraint], [Types.CFType]) ft ds3)
                     ds4
                     ds5
                     ds6
                     (GHC.Types.: @ Types.TLog (Types.TLogDebug m1 ds4) ds7)
                     ds8
                     ds9
                     ds10
                     ds11
                     ds12
                     ds13
                     ds14
                     ds15
                     ds16
                     ds17 }))
                   `cast`
                 (Trans
                      (<Types.TState>_R
                       ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                     <((), Types.TState)>_R))
                      (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N)))) -}
5e5180dab44c71d971c38965711e9d4c
  putTypeCheckState1 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows4
                   (GHC.Types.[] @ GHC.Types.Char)) -}
fdd7f8c6acb7427a6e5d5bbe70b6fda6
  removeFunction :: Types.Name -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,1*U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.removeFunction1
                  `cast`
                (<Types.Name>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
284db417307ea52da1bb61af8819df78
  removeFunction1 :: Types.Name -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,1*U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 (GHC.Tuple.(),
                  case w1 of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    (GHC.List.filter
                       @ (Types.Name, Lexer.SrcLoc, Types.F, Types.Arity,
                          Types.FunctionClassification, Types.HighOrder)
                       (\ (ds18 :: (Types.Name, Lexer.SrcLoc, Types.F, Types.Arity,
                                    Types.FunctionClassification, Types.HighOrder)) ->
                        case ds18 of wild1 { (,,,,,) n ds19 ds20 ds21 ds22 ds23 ->
                        GHC.Classes.$fEq[]_$s$c/=1 n w })
                       ds8)
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
8f8ddfb5f423bc7b265fdcea5121253c
  ret :: a -> Types.TMM a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.ret1
                  `cast`
                (forall (a :: <*>_N).
                 <a>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(GHC.Base.Maybe a, Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Base.Maybe a>_N))) -}
5c93bf62d8c0c5564905de707714da67
  ret1 :: a -> Types.TState -> (GHC.Base.Maybe a, Types.TState)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ a (x1 :: a) (eta :: Types.TState) ->
                 (GHC.Base.Just @ a x1, eta)) -}
caced3e1ce89eb6bb511c117c867723f
  runTM :: Types.TM a -> Types.TState
  {- Arity: 1,
     Strictness: <C(S(LS)),1*C1(U(A,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)))>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (tm :: Types.TM a) ->
                 case (tm
                         `cast`
                       (Control.Monad.Trans.State.Lazy.N:StateT[0]
                            <Types.TState>_N <Data.Functor.Identity.Identity>_R <a>_N)
                         Types.initialTState)
                        `cast`
                      (Data.Functor.Identity.N:Identity[0]
                           <(a, Types.TState)>_R) of wild { (,) ds1 y ->
                 y }) -}
b2983a43f90db815a4fe20763340de2e
  searchCFuncType ::
    Types.Name
    -> Types.CFType
    -> Types.TMM (Types.Name, [Types.Constraint], [Types.CFType])
  {- Arity: 2, Strictness: <S,U><L,U> -}
33483cce5ecac629c9e4358ef89e1cd1
  searchComponent :: Types.Name -> Types.TMM Types.TComp
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.searchComponent1
                  `cast`
                (<Types.Name>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(GHC.Base.Maybe (Types.Name, Types.C), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Base.Maybe Types.TComp>_N))) -}
c6c39374307b0a37628eed169b310498
  searchComponent1 ::
    Types.Name
    -> Types.TState
    -> (GHC.Base.Maybe (Types.Name, Types.C), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 case TransformationMonad.$wsearchComponent
                        w
                        w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
dad87bcda41e4cd10d09051d0eb58fed
  searchDataDecl ::
    Types.Name
    -> Types.TMM
         (Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.searchDataDecl1
                  `cast`
                (<Types.Name>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(GHC.Base.Maybe
                                             (Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                                              Types.Used),
                                           Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Base.Maybe
                                       (Lexer.L Types.Name, [Types.CConstr], Types.IsRec,
                                        Types.Used)>_N))) -}
0fb6be0c64008dd007070cf7a648ff77
  searchDataDecl1 ::
    Types.Name
    -> Types.TState
    -> (GHC.Base.Maybe
          (Lexer.L Types.Name, [Types.CConstr], Types.IsRec, Types.Used),
        Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 case TransformationMonad.$wsearchDataDecl
                        w
                        w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
97f22c4d4851b9009b389285b009c4ea
  searchFunction :: Types.Name -> Types.TMM Types.TFunc
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.searchFunction1
                  `cast`
                (<Types.Name>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <(GHC.Base.Maybe
                                             (Types.Name, Lexer.SrcLoc, Types.F, Types.Arity,
                                              Types.FunctionClassification, Types.HighOrder),
                                           Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <GHC.Base.Maybe Types.TFunc>_N))) -}
dd62f232a02a4bc5d3a4e3ac3c63f01b
  searchFunction1 ::
    Types.Name
    -> Types.TState
    -> (GHC.Base.Maybe
          (Types.Name, Lexer.SrcLoc, Types.F, Types.Arity,
           Types.FunctionClassification, Types.HighOrder),
        Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 case TransformationMonad.$wsearchFunction
                        w
                        w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
3e8b7363d47de0cbcbc0ac98fc811f6b
  searchFunctionByName ::
    Types.Name -> Types.TM [(Types.Name, Types.Id, [Types.FType])]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.searchFunctionByName1
                  `cast`
                (<Types.Name>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <([(Types.Name, Types.Id, [Types.FType])],
                                           Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <[(Types.Name, Types.Id, [Types.FType])]>_N))) -}
9d8ca7bb51acef0ac493f6000af98456
  searchFunctionByName1 ::
    Types.Name
    -> Types.TState
    -> ([(Types.Name, Types.Id, [Types.FType])], Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 (case w1 of wild { Types.TState ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ds18 ->
                  GHC.List.filter
                    @ (Types.Name, Types.Id, [Types.FType])
                    (\ (ds :: (Types.Name, Types.Id, [Types.FType])) ->
                     case ds of wild1 { (,,) n ds22 ds23 -> GHC.Base.eqString n w })
                    ds10 },
                  w1)) -}
af388d7df6eed09141130906c831d524
  searchInstances ::
    Types.CompName -> Types.Name -> Types.TM [Types.TInst]
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.searchInstances1
                  `cast`
                (<Types.CompName>_R
                 ->_R <Types.Name>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <([(Types.CompName, Types.Id, Types.NameId, Types.I,
                                             Types.Used)],
                                           Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <[Types.TInst]>_N))) -}
b4f0f252aedb7ed8acb32f21972cef79
  searchInstances1 ::
    Types.CompName
    -> Types.Name
    -> Types.TState
    -> ([(Types.CompName, Types.Id, Types.NameId, Types.I,
          Types.Used)],
        Types.TState)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ (w :: Types.CompName) (w1 :: Types.Name) (w2 :: Types.TState) ->
                 case TransformationMonad.$wsearchInstances
                        w
                        w1
                        w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
cda73ea8ca7c82e99078637a27e1a3e1
  setCore :: Types.Core -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,A)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.setCore1
                  `cast`
                (<Types.Core>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
b3e73844283e1278570f69938ad16bcf
  setCore1 :: Types.Core -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,A)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (core' :: Types.Core) (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    ds7
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    core' })) -}
316b9b902ab149602109b81451a701c2
  setDataUsed :: Types.Name -> Types.TMM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.setDataUsed1
                  `cast`
                (<Types.Name>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Base.Maybe ()>_N)) -}
a2623737a5107ef77c6be7a5b6431792
  setDataUsed1 ::
    Types.Name
    -> Types.TState
    -> Data.Functor.Identity.Identity (GHC.Base.Maybe (), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: Types.Name) (w1 :: Types.TState) ->
                 case TransformationMonad.$wsetDataUsed
                        w
                        w1 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2)
                   `cast`
                 (Sym (Data.Functor.Identity.N:Identity[0]
                           <(GHC.Base.Maybe (), Types.TState)>_R)) }) -}
79e79b47fdea098289fc46fdc559677c
  setInstanceUsed :: Types.CompName -> Types.NameId -> Types.TMM ()
  {- Arity: 3,
     Strictness: <L,U><L,U(U,U(U))><S(LLLLLLLLLLLSLLLLLL),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.setInstanceUsed1
                  `cast`
                (<Types.CompName>_R
                 ->_R <Types.NameId>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Base.Maybe ()>_N)) -}
ef460d975ec2a1014ceff4f1128c93a4
  setInstanceUsed1 ::
    Types.CompName
    -> Types.NameId
    -> Types.TState
    -> Data.Functor.Identity.Identity (GHC.Base.Maybe (), Types.TState)
  {- Arity: 3,
     Strictness: <L,U><L,U(U,U(U))><S(LLLLLLLLLLLSLLLLLL),1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (comp :: Types.CompName)
                   (nid :: Types.NameId)
                   (eta :: Types.TState) ->
                 TransformationMonad.modifyUniqueInstance1
                   comp
                   nid
                   TransformationMonad.setInstanceUsed2
                   eta) -}
9ea8bc6be1559fb0e0b2d35f73f30f0d
  setInstanceUsed2 ::
    (Types.CompName, Types.Id, Types.NameId, Types.I, Types.Used)
    -> Types.TInst
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U,U,U,U,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: (Types.CompName, Types.Id, Types.NameId, Types.I,
                           Types.Used)) ->
                 case ds of wild { (,,,,) cn id nid' i ds1 ->
                 (cn, id, nid', i, GHC.Types.True) }) -}
27d0b2824078b991414fde200052158a
  testF1 :: Types.TM (GHC.Base.Maybe GHC.Types.Int)
  {- Arity: 1,
     Strictness: <L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.testF4
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <(GHC.Base.Maybe GHC.Types.Int, Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Base.Maybe GHC.Types.Int>_N))) -}
152d07038343a4cc156e729dc3d46c13
  testF1_err :: Types.TErr
  {- Strictness: m,
     Unfolding: (Types.TErr
                   Types.ErrConstantAsFunction
                   (GHC.Base.Nothing @ Types.WhereMsg)
                   TransformationMonad.testF6
                   Lexer.NoLoc) -}
b8525bb6c088e14b0d05be8ed3f48b64
  testF2 :: Types.TM (GHC.Base.Maybe GHC.Types.Int)
  {- Arity: 1,
     Strictness: <L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.testF7
                  `cast`
                (Trans
                     (<Types.TState>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <(GHC.Base.Maybe GHC.Types.Int, Types.TState)>_R))
                     (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N
                               <Data.Functor.Identity.Identity>_R
                               <GHC.Base.Maybe GHC.Types.Int>_N))) -}
ec9a04838a1a203df2b6c3e9530fe054
  testF4 ::
    Types.TState -> (GHC.Base.Maybe GHC.Types.Int, Types.TState)
  {- Arity: 1,
     Strictness: <L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (1, True, False)
                (\ (s1 :: Types.TState) ->
                 (GHC.Base.Nothing @ GHC.Types.Int,
                  case s1 of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    (GHC.Types.:
                       @ Types.TLog
                       (Types.TLogErr TransformationMonad.testF1_err ds4)
                       (GHC.Types.:
                          @ Types.TLog
                          (Types.TLog TransformationMonad.testF5 ds4)
                          ds7))
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
cf2e51c52ff08ddde53b75f4f4eb32b5
  testF5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "At f"#) -}
c691f3896f560eb0cd65edf5d0bdbd95
  testF6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "aaaaaaaaaaaaa"#) -}
356b87951429e06136b0590a90c10825
  testF7 ::
    Types.TState -> (GHC.Base.Maybe GHC.Types.Int, Types.TState)
  {- Arity: 1,
     Strictness: <L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: Types.TState) ->
                 (GHC.Base.Nothing @ GHC.Types.Int,
                  case w of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    (GHC.Types.:
                       @ Types.TLog
                       (Types.TLogErr
                          (Types.TErr
                             Types.ErrConstantAsFunction
                             (GHC.Base.Nothing @ Types.WhereMsg)
                             GHC.Show.$fShowMaybe3
                             Lexer.NoLoc)
                          ds4)
                       (GHC.Types.:
                          @ Types.TLog
                          (Types.TLogErr TransformationMonad.testF1_err ds4)
                          (GHC.Types.:
                             @ Types.TLog
                             (Types.TLog TransformationMonad.testF5 ds4)
                             ds7)))
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
fd22a7ad31f6177a0a7c3d0b74f70074
  throw :: Types.TErr -> Types.TM ()
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.throw1
                  `cast`
                (<Types.TErr>_R
                 ->_R Trans
                          (<Types.TState>_R
                           ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                         <((), Types.TState)>_R))
                          (Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                    <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N))) -}
a126b830d799cba225d4aa7a28c53ce0
  throw1 :: Types.TErr -> Types.TState -> ((), Types.TState)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ (err :: Types.TErr) (eta :: Types.TState) ->
                 (GHC.Tuple.(),
                  case eta of wild { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                  Types.TState
                    ds
                    ds1
                    ds2
                    ds3
                    ds4
                    ds5
                    ds6
                    (GHC.Types.: @ Types.TLog (Types.TLogErr err ds4) ds7)
                    ds8
                    ds9
                    ds10
                    ds11
                    ds12
                    ds13
                    ds14
                    ds15
                    ds16
                    ds17 })) -}
423d53c55c180b22d88e335b21964e56
  throwIf :: GHC.Types.Bool -> Types.TErr -> Types.TM ()
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (0, True, True)
                TransformationMonad.throwIf1
                  `cast`
                (<GHC.Types.Bool>_R
                 ->_R <Types.TErr>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Types.TState>_N <Data.Functor.Identity.Identity>_R <()>_N)) -}
c09355c7365482a09d4258f6af60d69c
  throwIf1 ::
    GHC.Types.Bool
    -> Types.TErr
    -> Types.TState
    -> Data.Functor.Identity.Identity ((), Types.TState)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S,1*U><L,U><L,U(U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>m,
     Unfolding: InlineRule (3, True, False)
                (\ (bool :: GHC.Types.Bool)
                   (err :: Types.TErr)
                   (eta :: Types.TState) ->
                 case bool of wild {
                   GHC.Types.False
                   -> (GHC.Tuple.(), eta)
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0] <((), Types.TState)>_R))
                   GHC.Types.True
                   -> (GHC.Tuple.(),
                       case eta of wild1 { Types.TState ds ds1 ds2 ds3 ds4 ds5 ds6 ds7 ds8 ds9 ds10 ds11 ds12 ds13 ds14 ds15 ds16 ds17 ->
                       Types.TState
                         ds
                         ds1
                         ds2
                         ds3
                         ds4
                         ds5
                         ds6
                         (GHC.Types.: @ Types.TLog (Types.TLogErr err ds4) ds7)
                         ds8
                         ds9
                         ds10
                         ds11
                         ds12
                         ds13
                         ds14
                         ds15
                         ds16
                         ds17 })
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <((), Types.TState)>_R)) }) -}
"SPEC/TransformationMonad $fEq(,,,,) @ [Char] @ Int @ NameId @ I @ Bool" [ALWAYS] forall ($dEq4 :: GHC.Classes.Eq
                                                                                                     GHC.Types.Bool)
                                                                                         ($dEq3 :: GHC.Classes.Eq
                                                                                                     Types.I)
                                                                                         ($dEq2 :: GHC.Classes.Eq
                                                                                                     Types.NameId)
                                                                                         ($dEq1 :: GHC.Classes.Eq
                                                                                                     GHC.Types.Int)
                                                                                         ($dEq :: GHC.Classes.Eq
                                                                                                    [GHC.Types.Char])
  GHC.Classes.$fEq(,,,,) @ [GHC.Types.Char]
                         @ GHC.Types.Int
                         @ Types.NameId
                         @ Types.I
                         @ GHC.Types.Bool
                         $dEq
                         $dEq1
                         $dEq2
                         $dEq3
                         $dEq4
  = TransformationMonad.$s$fEq(,,,,)
"SPEC/TransformationMonad $fEq(,,,,)_$c/= @ [Char] @ Int @ NameId @ I @ Bool" [ALWAYS] forall ($dEq4 :: GHC.Classes.Eq
                                                                                                          GHC.Types.Bool)
                                                                                              ($dEq3 :: GHC.Classes.Eq
                                                                                                          Types.I)
                                                                                              ($dEq2 :: GHC.Classes.Eq
                                                                                                          Types.NameId)
                                                                                              ($dEq1 :: GHC.Classes.Eq
                                                                                                          GHC.Types.Int)
                                                                                              ($dEq :: GHC.Classes.Eq
                                                                                                         [GHC.Types.Char])
  GHC.Classes.$fEq(,,,,)_$c/= @ [GHC.Types.Char]
                              @ GHC.Types.Int
                              @ Types.NameId
                              @ Types.I
                              @ GHC.Types.Bool
                              $dEq
                              $dEq1
                              $dEq2
                              $dEq3
                              $dEq4
  = TransformationMonad.$s$fEq(,,,,)_$s$fEq(,,,,)_$c/=
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

